{
  "version": 3,
  "sources": ["../packages/kartoffelgames.environment.core/source/cli/cli-parameter.ts", "../packages/kartoffelgames.environment.core/source/cli/cli-command.ts", "../packages/kartoffelgames.environment.core/source/project/import.ts", "oazmi-loader-http:https://jsr.io/@std/path/1.0.8/_os.ts", "oazmi-loader-http:https://jsr.io/@std/path/1.0.8/_common/assert_path.ts", "oazmi-loader-http:https://jsr.io/@std/path/1.0.8/_common/normalize.ts", "oazmi-loader-http:https://jsr.io/@std/path/1.0.8/_common/constants.ts", "oazmi-loader-http:https://jsr.io/@std/path/1.0.8/_common/normalize_string.ts", "oazmi-loader-http:https://jsr.io/@std/path/1.0.8/posix/_util.ts", "oazmi-loader-http:https://jsr.io/@std/path/1.0.8/posix/normalize.ts", "oazmi-loader-http:https://jsr.io/@std/path/1.0.8/posix/join.ts", "oazmi-loader-http:https://jsr.io/@std/path/1.0.8/windows/_util.ts", "oazmi-loader-http:https://jsr.io/@std/path/1.0.8/windows/normalize.ts", "oazmi-loader-http:https://jsr.io/@std/path/1.0.8/windows/join.ts", "oazmi-loader-http:https://jsr.io/@std/path/1.0.8/join.ts", "oazmi-loader-http:https://jsr.io/@std/path/1.0.8/_common/from_file_url.ts", "oazmi-loader-http:https://jsr.io/@std/path/1.0.8/posix/from_file_url.ts", "oazmi-loader-http:https://jsr.io/@std/path/1.0.8/windows/from_file_url.ts", "oazmi-loader-http:https://jsr.io/@std/path/1.0.8/from_file_url.ts", "oazmi-loader-http:https://jsr.io/@std/fs/1.0.16/_to_path_string.ts", "oazmi-loader-http:https://jsr.io/@std/fs/1.0.16/empty_dir.ts", "oazmi-loader-http:https://jsr.io/@std/fs/1.0.16/_get_file_info_type.ts", "oazmi-loader-http:https://jsr.io/@std/fs/1.0.16/ensure_dir.ts", "oazmi-loader-http:https://jsr.io/@std/path/1.0.8/_common/dirname.ts", "oazmi-loader-http:https://jsr.io/@std/path/1.0.8/_common/strip_trailing_separators.ts", "oazmi-loader-http:https://jsr.io/@std/path/1.0.8/posix/dirname.ts", "oazmi-loader-http:https://jsr.io/@std/path/1.0.8/windows/dirname.ts", "oazmi-loader-http:https://jsr.io/@std/path/1.0.8/dirname.ts", "oazmi-loader-http:https://jsr.io/@std/fs/1.0.16/ensure_file.ts", "oazmi-loader-http:https://jsr.io/@std/fs/1.0.16/ensure_link.ts", "oazmi-loader-http:https://jsr.io/@std/path/1.0.8/posix/resolve.ts", "oazmi-loader-http:https://jsr.io/@std/path/1.0.8/windows/resolve.ts", "oazmi-loader-http:https://jsr.io/@std/path/1.0.8/resolve.ts", "oazmi-loader-http:https://jsr.io/@std/fs/1.0.16/ensure_symlink.ts", "oazmi-loader-http:https://jsr.io/@std/fs/1.0.16/exists.ts", "oazmi-loader-http:https://jsr.io/@std/path/1.0.8/_common/glob_to_reg_exp.ts", "oazmi-loader-http:https://jsr.io/@std/path/1.0.8/posix/glob_to_regexp.ts", "oazmi-loader-http:https://jsr.io/@std/path/1.0.8/windows/glob_to_regexp.ts", "oazmi-loader-http:https://jsr.io/@std/path/1.0.8/glob_to_regexp.ts", "oazmi-loader-http:https://jsr.io/@std/path/1.0.8/posix/constants.ts", "oazmi-loader-http:https://jsr.io/@std/path/1.0.8/posix/normalize_glob.ts", "oazmi-loader-http:https://jsr.io/@std/path/1.0.8/posix/join_globs.ts", "oazmi-loader-http:https://jsr.io/@std/path/1.0.8/windows/constants.ts", "oazmi-loader-http:https://jsr.io/@std/path/1.0.8/windows/normalize_glob.ts", "oazmi-loader-http:https://jsr.io/@std/path/1.0.8/windows/join_globs.ts", "oazmi-loader-http:https://jsr.io/@std/path/1.0.8/join_globs.ts", "oazmi-loader-http:https://jsr.io/@std/path/1.0.8/is_glob.ts", "oazmi-loader-http:https://jsr.io/@std/path/1.0.8/posix/is_absolute.ts", "oazmi-loader-http:https://jsr.io/@std/path/1.0.8/windows/is_absolute.ts", "oazmi-loader-http:https://jsr.io/@std/path/1.0.8/is_absolute.ts", "oazmi-loader-http:https://jsr.io/@std/path/1.0.8/constants.ts", "oazmi-loader-http:https://jsr.io/@std/path/1.0.8/_common/basename.ts", "oazmi-loader-http:https://jsr.io/@std/path/1.0.8/posix/basename.ts", "oazmi-loader-http:https://jsr.io/@std/path/1.0.8/windows/basename.ts", "oazmi-loader-http:https://jsr.io/@std/path/1.0.8/basename.ts", "oazmi-loader-http:https://jsr.io/@std/path/1.0.8/normalize.ts", "oazmi-loader-http:https://jsr.io/@std/fs/1.0.16/_create_walk_entry.ts", "oazmi-loader-http:https://jsr.io/@std/fs/1.0.16/walk.ts", "oazmi-loader-http:https://jsr.io/@std/fs/1.0.16/expand_glob.ts", "oazmi-loader-http:https://jsr.io/@std/fs/1.0.16/_is_subdir.ts", "oazmi-loader-http:https://jsr.io/@std/fs/1.0.16/_is_same_path.ts", "oazmi-loader-http:https://jsr.io/@std/fs/1.0.16/move.ts", "oazmi-loader-http:https://jsr.io/@std/fs/1.0.16/copy.ts", "oazmi-loader-http:https://jsr.io/@std/fs/1.0.16/eol.ts", "oazmi-loader-http:https://jsr.io/@std/fs/1.0.16/mod.ts", "oazmi-loader-http:https://jsr.io/@std/path/1.0.8/posix/extname.ts", "oazmi-loader-http:https://jsr.io/@std/path/1.0.8/windows/extname.ts", "oazmi-loader-http:https://jsr.io/@std/path/1.0.8/extname.ts", "oazmi-loader-http:https://jsr.io/@std/path/1.0.8/_common/format.ts", "oazmi-loader-http:https://jsr.io/@std/path/1.0.8/posix/format.ts", "oazmi-loader-http:https://jsr.io/@std/path/1.0.8/windows/format.ts", "oazmi-loader-http:https://jsr.io/@std/path/1.0.8/format.ts", "oazmi-loader-http:https://jsr.io/@std/path/1.0.8/posix/parse.ts", "oazmi-loader-http:https://jsr.io/@std/path/1.0.8/windows/parse.ts", "oazmi-loader-http:https://jsr.io/@std/path/1.0.8/parse.ts", "oazmi-loader-http:https://jsr.io/@std/path/1.0.8/_common/relative.ts", "oazmi-loader-http:https://jsr.io/@std/path/1.0.8/posix/relative.ts", "oazmi-loader-http:https://jsr.io/@std/path/1.0.8/windows/relative.ts", "oazmi-loader-http:https://jsr.io/@std/path/1.0.8/relative.ts", "oazmi-loader-http:https://jsr.io/@std/path/1.0.8/_common/to_file_url.ts", "oazmi-loader-http:https://jsr.io/@std/path/1.0.8/posix/to_file_url.ts", "oazmi-loader-http:https://jsr.io/@std/path/1.0.8/windows/to_file_url.ts", "oazmi-loader-http:https://jsr.io/@std/path/1.0.8/to_file_url.ts", "oazmi-loader-http:https://jsr.io/@std/path/1.0.8/posix/to_namespaced_path.ts", "oazmi-loader-http:https://jsr.io/@std/path/1.0.8/windows/to_namespaced_path.ts", "oazmi-loader-http:https://jsr.io/@std/path/1.0.8/to_namespaced_path.ts", "oazmi-loader-http:https://jsr.io/@std/path/1.0.8/_common/common.ts", "oazmi-loader-http:https://jsr.io/@std/path/1.0.8/common.ts", "oazmi-loader-http:https://jsr.io/@std/path/1.0.8/types.ts", "oazmi-loader-http:https://jsr.io/@std/path/1.0.8/normalize_glob.ts", "oazmi-loader-http:https://jsr.io/@std/path/1.0.8/mod.ts", "../packages/kartoffelgames.environment.core/source/system/file-system.ts", "../packages/kartoffelgames.environment.core/source/project/package.ts", "../packages/kartoffelgames.environment.core/source/project/project.ts", "../packages/kartoffelgames.environment.core/source/cli/cli-packages.ts", "../packages/kartoffelgames.environment.core/source/process/process-context.ts", "../packages/kartoffelgames.environment.core/source/process/process-parameter.ts", "../packages/kartoffelgames.environment.core/source/process/process.ts", "../packages/kartoffelgames.environment.core/source/system/console.ts", "../packages/kartoffelgames.environment.core/source/index.ts", "../packages/kartoffelgames.environment.test_package/page/source/index.ts", "../packages/kartoffelgames.environment.test_package/page/source/standard-input-file.ts"],
  "sourcesContent": ["import type { ICliPackageCommand } from './i-cli-package-command.interface.ts';\r\n\r\n/**\r\n * The `CliParameter` class provides methods to manage command-line parameters.\r\n * It allows extracting the root command, checking for the existence of parameters,\r\n * retrieving parameter values, setting parameter values, and deleting parameters.\r\n */\r\nexport class CliParameter {\r\n    private static readonly mGlobalParameters: Map<string, CliParameterOptionalParameter> = (() => {\r\n        const lGlobalParameters: Map<string, CliParameterOptionalParameter> = new Map<string, CliParameterOptionalParameter>();\r\n\r\n        // Add the --all parameter.\r\n        lGlobalParameters.set('--all', { fullname: 'all', shortName: 'a', default: null });\r\n        lGlobalParameters.set('-a', { fullname: 'all', shortName: 'a', default: null });\r\n\r\n        // Add the --package parameter.\r\n        lGlobalParameters.set('--package', { fullname: 'package', shortName: 'p', default: null });\r\n        lGlobalParameters.set('-p', { fullname: 'package', shortName: 'p', default: null });\r\n\r\n        return lGlobalParameters;\r\n    })();\r\n\r\n    /**\r\n     * Creates a `CliParameter` instance for a given command and its parameters.\r\n     *\r\n     * @param pCliCommand - The CLI command package containing command information.\r\n     * @param pParameter - An array of strings representing the parameters passed to the command.\r\n     * \r\n     * @returns A `CliParameter` instance populated with the provided parameters.\r\n     * \r\n     * @throws {@link Error}\r\n     * Will throw an error if no parameters are provided.\r\n     * @throws {@link Error}\r\n     * Will throw an error if the root parameter does not match the expected value.\r\n     * @throws {@link Error}\r\n     * Will throw an error if a required parameter is missing or starts with a dash.\r\n     * @throws {@link Error}\r\n     * Will throw an error if an unexpected parameter is encountered.\r\n     */\r\n    public static forCommand(pCliCommand: ICliPackageCommand, pParameter: Array<string>): CliParameter {\r\n        // At least one parameter (the root) is required.\r\n        if (pParameter.length === 0) {\r\n            throw new Error('No command parameter found');\r\n        }\r\n\r\n        // Create copy specified parameter.\r\n        const lUncheckedParameters: Array<string> = [...pParameter];\r\n\r\n        // Remove the root parameter from the parameter list. No need to check it.\r\n        if (pCliCommand.information.command.parameters.root !== lUncheckedParameters.shift()!) {\r\n            throw new Error(`Root parameter does not match the expected value \"${pCliCommand.information.command.parameters.root}\".`);\r\n        }\r\n\r\n        // Construct cli parameter with the root parameter.\r\n        const lCliParameter: CliParameter = new CliParameter(pCliCommand.information.command.parameters.root);\r\n\r\n        // Read all required parameter. Required parameters musn't start with dashes.\r\n        for (const lRequiredParameter of pCliCommand.information.command.parameters.required ?? []) {\r\n            // Read next parameter.\r\n            let lParameter: string | undefined = lUncheckedParameters.shift();\r\n            if (!lParameter) {\r\n                throw `Required parameter \"${lRequiredParameter}\" is missing`;\r\n            }\r\n\r\n            // Required parameters musn't start with dashes.\r\n            if (lParameter.startsWith('-')) {\r\n                throw `Unexpected parameter \"${lParameter}\". Required parameters musn't start with dashes`;\r\n            }\r\n\r\n            // Format parameter when it is set as string.\r\n            if (lParameter.startsWith('\"')) {\r\n                lParameter = lParameter.substring(1, lParameter.length - 1);\r\n            }\r\n\r\n            // Set required parameter as value.\r\n            lCliParameter.set(lRequiredParameter, lParameter);\r\n        }\r\n\r\n        // Convert all optional parameters to a map.\r\n        const lOptionalParameters: Map<string, CliParameterOptionalParameter> = new Map<string, CliParameterOptionalParameter>();\r\n        for (const [lOptionalParameterName, lOptionalParameter] of Object.entries(pCliCommand.information.command.parameters.optional ?? {})) {\r\n            const lConfiguration: CliParameterOptionalParameter = {\r\n                fullname: lOptionalParameterName,\r\n                shortName: lOptionalParameter.shortName ?? null,\r\n                default: lOptionalParameter.default ?? null\r\n            };\r\n\r\n            // Set long name with value.\r\n            lOptionalParameters.set(`--${lOptionalParameterName}`, lConfiguration);\r\n\r\n            // Set shortname with value.\r\n            if (lOptionalParameter.shortName) {\r\n                lOptionalParameters.set(`-${lOptionalParameter.shortName}`, lConfiguration);\r\n            }\r\n        }\r\n\r\n        // Add global parameters pattern.\r\n        for(const [lGlobalParameterName, lGlobalParameter] of CliParameter.mGlobalParameters.entries()) {\r\n            lOptionalParameters.set(lGlobalParameterName, lGlobalParameter);\r\n        }\r\n\r\n        // Read all optional parameters. Optional parameters must start with dashes.\r\n        // Convert and check all optional named parameters.\r\n        while (lUncheckedParameters.length > 0) {\r\n            // Read next parameter.\r\n            const lParameter: string = lUncheckedParameters.shift()!;\r\n\r\n            // Fail when parameter is a not a named parameter.\r\n            if (!lParameter.startsWith('-')) {\r\n                throw new Error(`Unexpected parameter \"${lParameter}\". Expected named parameter starting with \"--\" or \"-\".`);\r\n            }\r\n\r\n            // Get parameter name.\r\n            const [lParameterName, lParameterValue] = lParameter.split('=');\r\n\r\n            // Get parameter configuration by name.\r\n            const lOptionalParameter: CliParameterOptionalParameter | undefined = lOptionalParameters.get(lParameterName);\r\n            if (!lOptionalParameter) {\r\n                throw new Error(`Unexpected parameter \"${lParameter}\". Parameter does not exist.`);\r\n            }\r\n\r\n            let lClearedParameterValue: string = lParameterValue;\r\n\r\n            // Format parameter value when it is set as string.\r\n            if (lClearedParameterValue && lClearedParameterValue.startsWith('\"')) {\r\n                lClearedParameterValue = lParameter.substring(1, lParameter.length - 1);\r\n            }\r\n            // Set optional named parameter.\r\n            lCliParameter.set(lOptionalParameter.fullname, lClearedParameterValue);\r\n        }\r\n\r\n        // Fill in default values for optional parameters.\r\n        for (const [lOptionalParameterName, lOptionalParameter] of Object.entries(pCliCommand.information.command.parameters.optional ?? {})) {\r\n            if (!lOptionalParameter.default) {\r\n                continue;\r\n            }\r\n\r\n            // Set default value when parameter is not set.\r\n            if (!lCliParameter.has(lOptionalParameterName)) {\r\n                lCliParameter.set(lOptionalParameterName, lOptionalParameter.default);\r\n            }\r\n        }\r\n\r\n        return lCliParameter;\r\n    }\r\n\r\n    /**\r\n     * Parses an array of command-line parameters and constructs a `CliParameter` object that only contains global parameters.\r\n     * \r\n     * @param pParameter - An array of strings representing the command-line parameters.\r\n     * \r\n     * @returns A `CliParameter` object constructed from the provided parameters.\r\n     * \r\n     * @throws {Error} If no command parameter value was specified.\r\n     */\r\n    public static globals(pParameter: Array<string>): CliParameter {\r\n        // At least one parameter (the root) is required.\r\n        if (pParameter.length === 0) {\r\n            throw new Error('No command parameter found');\r\n        }\r\n\r\n        // Create copy specified parameter.\r\n        const lUncheckedParameters: Array<string> = [...pParameter];\r\n\r\n        // Read root command.\r\n        const lRootCommand: string = lUncheckedParameters.shift()!;\r\n\r\n        // Construct cli parameter with the root parameter.\r\n        const lCliParameter: CliParameter = new CliParameter(lRootCommand);\r\n\r\n        // Read all optional parameters. Optional parameters must start with dashes.\r\n        // Convert and check all optional named parameters.\r\n        while (lUncheckedParameters.length > 0) {\r\n            // Read next parameter.\r\n            const lParameter: string = lUncheckedParameters.shift()!;\r\n\r\n            // Continue when parameter is a not a named parameter.\r\n            if (!lParameter.startsWith('-')) {\r\n                continue;\r\n            }\r\n\r\n            // Get parameter name.\r\n            const [lParameterName, lParameterValue] = lParameter.split('=');\r\n\r\n            // Get parameter configuration by name.\r\n            const lOptionalParameter: CliParameterOptionalParameter | undefined = CliParameter.mGlobalParameters.get(lParameterName);\r\n            if (!lOptionalParameter) {\r\n                continue;\r\n            }\r\n\r\n            let lClearedParameterValue: string = lParameterValue;\r\n\r\n            // Format parameter value when it is set as string.\r\n            if (lClearedParameterValue && lClearedParameterValue.startsWith('\"')) {\r\n                lClearedParameterValue = lParameter.substring(1, lParameter.length - 1);\r\n            }\r\n            // Set optional named parameter.\r\n            lCliParameter.set(lOptionalParameter.fullname, lClearedParameterValue);\r\n        }\r\n\r\n        return lCliParameter;\r\n    }\r\n\r\n    private readonly mParameters: Map<string, string | null>;\r\n    private readonly mRootParameter: string;\r\n\r\n    /**\r\n     * Root parameter name.\r\n     */\r\n    public get rootParameter(): string {\r\n        return this.mRootParameter;\r\n    }\r\n\r\n    /**\r\n     * Constructor.\r\n     * \r\n     * @param pRootParameter - Root parameter.\r\n     */\r\n    public constructor(pRootParameter: string) {\r\n        this.mRootParameter = pRootParameter;\r\n        this.mParameters = new Map<string, string | null>();\r\n    }\r\n\r\n    /**\r\n     * Delete parameter.\r\n     * \r\n     * @param pParameterName - Parameter name.\r\n     */\r\n    public delete(pParameterName: string): void {\r\n        this.mParameters.delete(pParameterName);\r\n    }\r\n\r\n    \r\n    /**\r\n     * Retrieves the value of a specified parameter.\r\n     *\r\n     * @param pParameterName - The name of the parameter to retrieve.\r\n     * \r\n     * @returns The value of the specified parameter.\r\n     * \r\n     * @throws {@link Error} \r\n     * Will throw an error if the parameter does not exist.\r\n     * @throws {@link Error} \r\n     * Will throw an error if the parameter exists but does not have a value.\r\n     */\r\n    public get(pParameterName: string): string {\r\n        // Check if parameter exists.\r\n        if (!this.has(pParameterName)) {\r\n            throw new Error(`Parameter \"${pParameterName}\" does not exist`);\r\n        }\r\n\r\n        // Get parameter value and check if it has a value.\r\n        const lValue: string | null = this.mParameters.get(pParameterName)!;\r\n        if (!lValue) {\r\n            throw new Error(`Parameter \"${pParameterName}\" needs a value`);\r\n        }\r\n\r\n        return lValue;\r\n    }\r\n\r\n    /**\r\n     * Check if parameter exists.\r\n     * Parameter can exist but have no value.\r\n     * \r\n     * @param pParameterName - Parameter name.\r\n     * \r\n     * @returns - True if parameter exists.\r\n     */\r\n    public has(pParameterName: string): boolean {\r\n        return this.mParameters.has(pParameterName);\r\n    }\r\n\r\n    /**\r\n     * Set parameter value.\r\n     * Setting null value sets parameter to exist but have no value.\r\n     * \r\n     * @param pParameterName - Parameter name.\r\n     * @param pValue - Parameter value.\r\n     */\r\n    public set(pParameterName: string, pValue: string | null): void {\r\n        this.mParameters.set(pParameterName, pValue);\r\n    }\r\n}\r\n\r\ntype CliParameterOptionalParameter = {\r\n    fullname: string;\r\n    shortName: string | null;\r\n    default: string | null;\r\n};", "import type { Package } from '../project/package.ts';\r\nimport type { Project } from '../project/project.ts';\r\nimport { CliParameter } from './cli-parameter.ts';\r\nimport type { ICliPackageCommand } from './i-cli-package-command.interface.ts';\r\n\r\n/**\r\n * Command line interface command that can be executed.\r\n * Converts and validates environment split commands into a easy to use command pattern.\r\n */\r\nexport class CliCommand {\r\n    private readonly mCliPackageCommand: ICliPackageCommand;\r\n    private readonly mProject: Project;\r\n    \r\n    /**\r\n     * Gets the CLI package command.\r\n     */\r\n    public get cliPackageCommand(): ICliPackageCommand {\r\n        return this.mCliPackageCommand; \r\n    }\r\n\r\n    /**\r\n     * Cli packages.\r\n     */\r\n    public get project(): Project {\r\n        return this.mProject;\r\n    }\r\n\r\n    /**\r\n     * Constructor.\r\n     * \r\n     * @param pCommandName - Command name.\r\n     * @param pParameter - Command parameter.\r\n     * @param pCliPackages - Cli packages.\r\n     */\r\n    public constructor(pProject: Project, pCliPackageCommand: ICliPackageCommand) {\r\n        this.mCliPackageCommand = pCliPackageCommand;\r\n        this.mProject = pProject;\r\n    }\r\n\r\n    /**\r\n     * Execute command.\r\n     * @param pParameterInput - Command parameter.\r\n     * @param pPackage -  Package the command should be applied to.\r\n     * \r\n     */\r\n    public async execute(pPackage: Package | null, pParameterInput: Array<string>): Promise<void> {\r\n        // Validate command pattern for cli package configuration.\r\n        const lCommandParameter: CliParameter = CliParameter.forCommand(this.mCliPackageCommand, pParameterInput);\r\n\r\n        // Build project handler.\r\n        await this.mCliPackageCommand.run(this.mProject, pPackage, lCommandParameter);\r\n    }\r\n}\r\n", "/**\r\n * Package import and resolve helper.\r\n */\r\nexport class Import {\r\n    /**\r\n     * Import a package.\r\n     * \r\n     * @param pImportPath - Import. Uses default import or path.\r\n     * \r\n     * @returns imported package. \r\n     */\r\n    public static async import(pImportPath: string): Promise<any> {\r\n        return import(pImportPath, {});\r\n    }\r\n\r\n    /**\r\n     * Import a json file.\r\n     * \r\n     * @param pImportPath - Import. Uses default import or path.\r\n     * \r\n     * @returns imported package. \r\n     */\r\n    public static async importJson(pImportPath: string): Promise<any> {\r\n        return import(pImportPath, { with: { type: 'json' } });\r\n    }\r\n\r\n    /**\r\n     * Resolve a package import as a path.\r\n     * \r\n     * @param pImportPath - Import. Uses default import or path.\r\n     * \r\n     * @returns resolved path. \r\n     */\r\n    public static resolveToUrl(pImportPath: string): URL {\r\n        return new URL(import.meta.resolve(pImportPath));\r\n    }\r\n}", "// deno-lint-ignore-file no-explicit-any\n// Copyright 2018-2024 the Deno authors. All rights reserved. MIT license.\n// This module is browser compatible.\n\n// Check Deno, then the remaining runtimes (e.g. Node, Bun and the browser)\nexport const isWindows: boolean =\n  (globalThis as any).Deno?.build.os === \"windows\" ||\n  (globalThis as any).navigator?.platform?.startsWith(\"Win\") ||\n  (globalThis as any).process?.platform?.startsWith(\"win\") ||\n  false;\n", "// Copyright 2018-2024 the Deno authors. All rights reserved. MIT license.\n// Copyright the Browserify authors. MIT License.\n\nexport function assertPath(path?: string) {\n  if (typeof path !== \"string\") {\n    throw new TypeError(\n      `Path must be a string, received \"${JSON.stringify(path)}\"`,\n    );\n  }\n}\n", "// Copyright 2018-2024 the Deno authors. All rights reserved. MIT license.\n// This module is browser compatible.\n\nimport { assertPath } from \"./assert_path.ts\";\n\nexport function assertArg(path: string) {\n  assertPath(path);\n  if (path.length === 0) return \".\";\n}\n", "// Copyright 2018-2024 the Deno authors. All rights reserved. MIT license.\n// Copyright the Browserify authors. MIT License.\n// Ported from https://github.com/browserify/path-browserify/\n// This module is browser compatible.\n\n// Alphabet chars.\nexport const CHAR_UPPERCASE_A = 65; /* A */\nexport const CHAR_LOWERCASE_A = 97; /* a */\nexport const CHAR_UPPERCASE_Z = 90; /* Z */\nexport const CHAR_LOWERCASE_Z = 122; /* z */\n\n// Non-alphabetic chars.\nexport const CHAR_DOT = 46; /* . */\nexport const CHAR_FORWARD_SLASH = 47; /* / */\nexport const CHAR_BACKWARD_SLASH = 92; /* \\ */\nexport const CHAR_VERTICAL_LINE = 124; /* | */\nexport const CHAR_COLON = 58; /* : */\nexport const CHAR_QUESTION_MARK = 63; /* ? */\nexport const CHAR_UNDERSCORE = 95; /* _ */\nexport const CHAR_LINE_FEED = 10; /* \\n */\nexport const CHAR_CARRIAGE_RETURN = 13; /* \\r */\nexport const CHAR_TAB = 9; /* \\t */\nexport const CHAR_FORM_FEED = 12; /* \\f */\nexport const CHAR_EXCLAMATION_MARK = 33; /* ! */\nexport const CHAR_HASH = 35; /* # */\nexport const CHAR_SPACE = 32; /*   */\nexport const CHAR_NO_BREAK_SPACE = 160; /* \\u00A0 */\nexport const CHAR_ZERO_WIDTH_NOBREAK_SPACE = 65279; /* \\uFEFF */\nexport const CHAR_LEFT_SQUARE_BRACKET = 91; /* [ */\nexport const CHAR_RIGHT_SQUARE_BRACKET = 93; /* ] */\nexport const CHAR_LEFT_ANGLE_BRACKET = 60; /* < */\nexport const CHAR_RIGHT_ANGLE_BRACKET = 62; /* > */\nexport const CHAR_LEFT_CURLY_BRACKET = 123; /* { */\nexport const CHAR_RIGHT_CURLY_BRACKET = 125; /* } */\nexport const CHAR_HYPHEN_MINUS = 45; /* - */\nexport const CHAR_PLUS = 43; /* + */\nexport const CHAR_DOUBLE_QUOTE = 34; /* \" */\nexport const CHAR_SINGLE_QUOTE = 39; /* ' */\nexport const CHAR_PERCENT = 37; /* % */\nexport const CHAR_SEMICOLON = 59; /* ; */\nexport const CHAR_CIRCUMFLEX_ACCENT = 94; /* ^ */\nexport const CHAR_GRAVE_ACCENT = 96; /* ` */\nexport const CHAR_AT = 64; /* @ */\nexport const CHAR_AMPERSAND = 38; /* & */\nexport const CHAR_EQUAL = 61; /* = */\n\n// Digits\nexport const CHAR_0 = 48; /* 0 */\nexport const CHAR_9 = 57; /* 9 */\n", "// Copyright 2018-2024 the Deno authors. All rights reserved. MIT license.\n// Copyright the Browserify authors. MIT License.\n// Ported from https://github.com/browserify/path-browserify/\n// This module is browser compatible.\n\nimport { CHAR_DOT, CHAR_FORWARD_SLASH } from \"./constants.ts\";\n\n// Resolves . and .. elements in a path with directory names\nexport function normalizeString(\n  path: string,\n  allowAboveRoot: boolean,\n  separator: string,\n  isPathSeparator: (code: number) => boolean,\n): string {\n  let res = \"\";\n  let lastSegmentLength = 0;\n  let lastSlash = -1;\n  let dots = 0;\n  let code: number | undefined;\n  for (let i = 0; i <= path.length; ++i) {\n    if (i < path.length) code = path.charCodeAt(i);\n    else if (isPathSeparator(code!)) break;\n    else code = CHAR_FORWARD_SLASH;\n\n    if (isPathSeparator(code!)) {\n      if (lastSlash === i - 1 || dots === 1) {\n        // NOOP\n      } else if (lastSlash !== i - 1 && dots === 2) {\n        if (\n          res.length < 2 ||\n          lastSegmentLength !== 2 ||\n          res.charCodeAt(res.length - 1) !== CHAR_DOT ||\n          res.charCodeAt(res.length - 2) !== CHAR_DOT\n        ) {\n          if (res.length > 2) {\n            const lastSlashIndex = res.lastIndexOf(separator);\n            if (lastSlashIndex === -1) {\n              res = \"\";\n              lastSegmentLength = 0;\n            } else {\n              res = res.slice(0, lastSlashIndex);\n              lastSegmentLength = res.length - 1 - res.lastIndexOf(separator);\n            }\n            lastSlash = i;\n            dots = 0;\n            continue;\n          } else if (res.length === 2 || res.length === 1) {\n            res = \"\";\n            lastSegmentLength = 0;\n            lastSlash = i;\n            dots = 0;\n            continue;\n          }\n        }\n        if (allowAboveRoot) {\n          if (res.length > 0) res += `${separator}..`;\n          else res = \"..\";\n          lastSegmentLength = 2;\n        }\n      } else {\n        if (res.length > 0) res += separator + path.slice(lastSlash + 1, i);\n        else res = path.slice(lastSlash + 1, i);\n        lastSegmentLength = i - lastSlash - 1;\n      }\n      lastSlash = i;\n      dots = 0;\n    } else if (code === CHAR_DOT && dots !== -1) {\n      ++dots;\n    } else {\n      dots = -1;\n    }\n  }\n  return res;\n}\n", "// Copyright 2018-2024 the Deno authors. All rights reserved. MIT license.\n// Copyright the Browserify authors. MIT License.\n// Ported from https://github.com/browserify/path-browserify/\n// This module is browser compatible.\n\nimport { CHAR_FORWARD_SLASH } from \"../_common/constants.ts\";\n\nexport function isPosixPathSeparator(code: number): boolean {\n  return code === CHAR_FORWARD_SLASH;\n}\n", "// Copyright 2018-2024 the Deno authors. All rights reserved. MIT license.\n// This module is browser compatible.\n\nimport { assertArg } from \"../_common/normalize.ts\";\nimport { normalizeString } from \"../_common/normalize_string.ts\";\nimport { isPosixPathSeparator } from \"./_util.ts\";\n\n/**\n * Normalize the `path`, resolving `'..'` and `'.'` segments.\n * Note that resolving these segments does not necessarily mean that all will be eliminated.\n * A `'..'` at the top-level will be preserved, and an empty path is canonically `'.'`.\n *\n * @example Usage\n * ```ts\n * import { normalize } from \"@std/path/posix/normalize\";\n * import { assertEquals } from \"@std/assert\";\n *\n * const path = normalize(\"/foo/bar//baz/asdf/quux/..\");\n * assertEquals(path, \"/foo/bar/baz/asdf\");\n * ```\n *\n * @example Working with URLs\n *\n * Note: This function will remove the double slashes from a URL's scheme.\n * Hence, do not pass a full URL to this function. Instead, pass the pathname of\n * the URL.\n *\n * ```ts\n * import { normalize } from \"@std/path/posix/normalize\";\n * import { assertEquals } from \"@std/assert\";\n *\n * const url = new URL(\"https://deno.land\");\n * url.pathname = normalize(\"//std//assert//.//mod.ts\");\n * assertEquals(url.href, \"https://deno.land/std/assert/mod.ts\");\n *\n * url.pathname = normalize(\"std/assert/../async/retry.ts\");\n * assertEquals(url.href, \"https://deno.land/std/async/retry.ts\");\n * ```\n *\n * Note: If you are working with file URLs,\n * use the new version of `normalize` from `@std/path/posix/unstable-normalize`.\n *\n * @param path The path to normalize.\n * @returns The normalized path.\n */\nexport function normalize(path: string): string {\n  assertArg(path);\n\n  const isAbsolute = isPosixPathSeparator(path.charCodeAt(0));\n  const trailingSeparator = isPosixPathSeparator(\n    path.charCodeAt(path.length - 1),\n  );\n\n  // Normalize the path\n  path = normalizeString(path, !isAbsolute, \"/\", isPosixPathSeparator);\n\n  if (path.length === 0 && !isAbsolute) path = \".\";\n  if (path.length > 0 && trailingSeparator) path += \"/\";\n\n  if (isAbsolute) return `/${path}`;\n  return path;\n}\n", "// Copyright 2018-2024 the Deno authors. All rights reserved. MIT license.\n// This module is browser compatible.\n\nimport { assertPath } from \"../_common/assert_path.ts\";\nimport { normalize } from \"./normalize.ts\";\n\n/**\n * Join all given a sequence of `paths`,then normalizes the resulting path.\n *\n * @example Usage\n * ```ts\n * import { join } from \"@std/path/posix/join\";\n * import { assertEquals } from \"@std/assert\";\n *\n * const path = join(\"/foo\", \"bar\", \"baz/asdf\", \"quux\", \"..\");\n * assertEquals(path, \"/foo/bar/baz/asdf\");\n * ```\n *\n * @example Working with URLs\n * ```ts\n * import { join } from \"@std/path/posix/join\";\n * import { assertEquals } from \"@std/assert\";\n *\n * const url = new URL(\"https://deno.land\");\n * url.pathname = join(\"std\", \"path\", \"mod.ts\");\n * assertEquals(url.href, \"https://deno.land/std/path/mod.ts\");\n *\n * url.pathname = join(\"//std\", \"path/\", \"/mod.ts\");\n * assertEquals(url.href, \"https://deno.land/std/path/mod.ts\");\n * ```\n *\n * Note: If you are working with file URLs,\n * use the new version of `join` from `@std/path/posix/unstable-join`.\n *\n * @param paths The paths to join.\n * @returns The joined path.\n */\nexport function join(...paths: string[]): string {\n  if (paths.length === 0) return \".\";\n  paths.forEach((path) => assertPath(path));\n  const joined = paths.filter((path) => path.length > 0).join(\"/\");\n  return joined === \"\" ? \".\" : normalize(joined);\n}\n", "// Copyright 2018-2024 the Deno authors. All rights reserved. MIT license.\n// Copyright the Browserify authors. MIT License.\n// Ported from https://github.com/browserify/path-browserify/\n// This module is browser compatible.\n\nimport {\n  CHAR_BACKWARD_SLASH,\n  CHAR_FORWARD_SLASH,\n  CHAR_LOWERCASE_A,\n  CHAR_LOWERCASE_Z,\n  CHAR_UPPERCASE_A,\n  CHAR_UPPERCASE_Z,\n} from \"../_common/constants.ts\";\n\nexport function isPosixPathSeparator(code: number): boolean {\n  return code === CHAR_FORWARD_SLASH;\n}\n\nexport function isPathSeparator(code: number): boolean {\n  return code === CHAR_FORWARD_SLASH || code === CHAR_BACKWARD_SLASH;\n}\n\nexport function isWindowsDeviceRoot(code: number): boolean {\n  return (\n    (code >= CHAR_LOWERCASE_A && code <= CHAR_LOWERCASE_Z) ||\n    (code >= CHAR_UPPERCASE_A && code <= CHAR_UPPERCASE_Z)\n  );\n}\n", "// Copyright 2018-2024 the Deno authors. All rights reserved. MIT license.\n// This module is browser compatible.\n\nimport { assertArg } from \"../_common/normalize.ts\";\nimport { CHAR_COLON } from \"../_common/constants.ts\";\nimport { normalizeString } from \"../_common/normalize_string.ts\";\nimport { isPathSeparator, isWindowsDeviceRoot } from \"./_util.ts\";\n\n/**\n * Normalize the `path`, resolving `'..'` and `'.'` segments.\n * Note that resolving these segments does not necessarily mean that all will be eliminated.\n * A `'..'` at the top-level will be preserved, and an empty path is canonically `'.'`.\n *\n * @example Usage\n * ```ts\n * import { normalize } from \"@std/path/windows/normalize\";\n * import { assertEquals } from \"@std/assert\";\n *\n * const normalized = normalize(\"C:\\\\foo\\\\..\\\\bar\");\n * assertEquals(normalized, \"C:\\\\bar\");\n * ```\n *\n * Note: If you are working with file URLs,\n * use the new version of `normalize` from `@std/path/windows/unstable-normalize`.\n *\n * @param path The path to normalize\n * @returns The normalized path\n */\nexport function normalize(path: string): string {\n  assertArg(path);\n\n  const len = path.length;\n  let rootEnd = 0;\n  let device: string | undefined;\n  let isAbsolute = false;\n  const code = path.charCodeAt(0);\n\n  // Try to match a root\n  if (len > 1) {\n    if (isPathSeparator(code)) {\n      // Possible UNC root\n\n      // If we started with a separator, we know we at least have an absolute\n      // path of some kind (UNC or otherwise)\n      isAbsolute = true;\n\n      if (isPathSeparator(path.charCodeAt(1))) {\n        // Matched double path separator at beginning\n        let j = 2;\n        let last = j;\n        // Match 1 or more non-path separators\n        for (; j < len; ++j) {\n          if (isPathSeparator(path.charCodeAt(j))) break;\n        }\n        if (j < len && j !== last) {\n          const firstPart = path.slice(last, j);\n          // Matched!\n          last = j;\n          // Match 1 or more path separators\n          for (; j < len; ++j) {\n            if (!isPathSeparator(path.charCodeAt(j))) break;\n          }\n          if (j < len && j !== last) {\n            // Matched!\n            last = j;\n            // Match 1 or more non-path separators\n            for (; j < len; ++j) {\n              if (isPathSeparator(path.charCodeAt(j))) break;\n            }\n            if (j === len) {\n              // We matched a UNC root only\n              // Return the normalized version of the UNC root since there\n              // is nothing left to process\n\n              return `\\\\\\\\${firstPart}\\\\${path.slice(last)}\\\\`;\n            } else if (j !== last) {\n              // We matched a UNC root with leftovers\n\n              device = `\\\\\\\\${firstPart}\\\\${path.slice(last, j)}`;\n              rootEnd = j;\n            }\n          }\n        }\n      } else {\n        rootEnd = 1;\n      }\n    } else if (isWindowsDeviceRoot(code)) {\n      // Possible device root\n\n      if (path.charCodeAt(1) === CHAR_COLON) {\n        device = path.slice(0, 2);\n        rootEnd = 2;\n        if (len > 2) {\n          if (isPathSeparator(path.charCodeAt(2))) {\n            // Treat separator following drive name as an absolute path\n            // indicator\n            isAbsolute = true;\n            rootEnd = 3;\n          }\n        }\n      }\n    }\n  } else if (isPathSeparator(code)) {\n    // `path` contains just a path separator, exit early to avoid unnecessary\n    // work\n    return \"\\\\\";\n  }\n\n  let tail: string;\n  if (rootEnd < len) {\n    tail = normalizeString(\n      path.slice(rootEnd),\n      !isAbsolute,\n      \"\\\\\",\n      isPathSeparator,\n    );\n  } else {\n    tail = \"\";\n  }\n  if (tail.length === 0 && !isAbsolute) tail = \".\";\n  if (tail.length > 0 && isPathSeparator(path.charCodeAt(len - 1))) {\n    tail += \"\\\\\";\n  }\n  if (device === undefined) {\n    if (isAbsolute) {\n      if (tail.length > 0) return `\\\\${tail}`;\n      else return \"\\\\\";\n    }\n    return tail;\n  } else if (isAbsolute) {\n    if (tail.length > 0) return `${device}\\\\${tail}`;\n    else return `${device}\\\\`;\n  }\n  return device + tail;\n}\n", "// Copyright 2018-2024 the Deno authors. All rights reserved. MIT license.\n// This module is browser compatible.\n\nimport { assertPath } from \"../_common/assert_path.ts\";\nimport { isPathSeparator } from \"./_util.ts\";\nimport { normalize } from \"./normalize.ts\";\n\n/**\n * Join all given a sequence of `paths`,then normalizes the resulting path.\n *\n * @example Usage\n * ```ts\n * import { join } from \"@std/path/windows/join\";\n * import { assertEquals } from \"@std/assert\";\n *\n * const joined = join(\"C:\\\\foo\", \"bar\", \"baz\\\\..\");\n * assertEquals(joined, \"C:\\\\foo\\\\bar\");\n * ```\n *\n * Note: If you are working with file URLs,\n * use the new version of `join` from `@std/path/windows/unstable-join`.\n *\n * @param paths The paths to join.\n * @returns The joined path.\n */\nexport function join(...paths: string[]): string {\n  paths.forEach((path) => assertPath(path));\n  paths = paths.filter((path) => path.length > 0);\n  if (paths.length === 0) return \".\";\n\n  // Make sure that the joined path doesn't start with two slashes, because\n  // normalize() will mistake it for an UNC path then.\n  //\n  // This step is skipped when it is very clear that the user actually\n  // intended to point at an UNC path. This is assumed when the first\n  // non-empty string arguments starts with exactly two slashes followed by\n  // at least one more non-slash character.\n  //\n  // Note that for normalize() to treat a path as an UNC path it needs to\n  // have at least 2 components, so we don't filter for that here.\n  // This means that the user can use join to construct UNC paths from\n  // a server name and a share name; for example:\n  //   path.join('//server', 'share') -> '\\\\\\\\server\\\\share\\\\'\n  let needsReplace = true;\n  let slashCount = 0;\n  const firstPart = paths[0]!;\n  if (isPathSeparator(firstPart.charCodeAt(0))) {\n    ++slashCount;\n    const firstLen = firstPart.length;\n    if (firstLen > 1) {\n      if (isPathSeparator(firstPart.charCodeAt(1))) {\n        ++slashCount;\n        if (firstLen > 2) {\n          if (isPathSeparator(firstPart.charCodeAt(2))) ++slashCount;\n          else {\n            // We matched a UNC path in the first part\n            needsReplace = false;\n          }\n        }\n      }\n    }\n  }\n  let joined = paths.join(\"\\\\\");\n  if (needsReplace) {\n    // Find any more consecutive slashes we need to replace\n    for (; slashCount < joined.length; ++slashCount) {\n      if (!isPathSeparator(joined.charCodeAt(slashCount))) break;\n    }\n\n    // Replace the slashes if needed\n    if (slashCount >= 2) joined = `\\\\${joined.slice(slashCount)}`;\n  }\n\n  return normalize(joined);\n}\n", "// Copyright 2018-2024 the Deno authors. All rights reserved. MIT license.\n// This module is browser compatible.\n\nimport { isWindows } from \"./_os.ts\";\nimport { join as posixJoin } from \"./posix/join.ts\";\nimport { join as windowsJoin } from \"./windows/join.ts\";\n\n/**\n * Joins a sequence of paths, then normalizes the resulting path.\n *\n * @example Usage\n * ```ts\n * import { join } from \"@std/path/join\";\n * import { assertEquals } from \"@std/assert\";\n *\n * if (Deno.build.os === \"windows\") {\n *   assertEquals(join(\"C:\\\\foo\", \"bar\", \"baz\\\\quux\", \"garply\", \"..\"), \"C:\\\\foo\\\\bar\\\\baz\\\\quux\");\n * } else {\n *   assertEquals(join(\"/foo\", \"bar\", \"baz/quux\", \"garply\", \"..\"), \"/foo/bar/baz/quux\");\n * }\n * ```\n *\n * Note: If you are working with file URLs,\n * use the new version of `join` from `@std/path/unstable-join`.\n *\n * @param paths Paths to be joined and normalized.\n * @returns The joined and normalized path.\n */\nexport function join(...paths: string[]): string {\n  return isWindows ? windowsJoin(...paths) : posixJoin(...paths);\n}\n", "// Copyright 2018-2024 the Deno authors. All rights reserved. MIT license.\n// This module is browser compatible.\n\nexport function assertArg(url: URL | string) {\n  url = url instanceof URL ? url : new URL(url);\n  if (url.protocol !== \"file:\") {\n    throw new TypeError(\n      `URL must be a file URL: received \"${url.protocol}\"`,\n    );\n  }\n  return url;\n}\n", "// Copyright 2018-2024 the Deno authors. All rights reserved. MIT license.\n// This module is browser compatible.\n\nimport { assertArg } from \"../_common/from_file_url.ts\";\n\n/**\n * Converts a file URL to a path string.\n *\n * @example Usage\n * ```ts\n * import { fromFileUrl } from \"@std/path/posix/from-file-url\";\n * import { assertEquals } from \"@std/assert\";\n *\n * assertEquals(fromFileUrl(new URL(\"file:///home/foo\")), \"/home/foo\");\n * ```\n *\n * @param url The file URL to convert.\n * @returns The path string.\n */\nexport function fromFileUrl(url: URL | string): string {\n  url = assertArg(url);\n  return decodeURIComponent(\n    url.pathname.replace(/%(?![0-9A-Fa-f]{2})/g, \"%25\"),\n  );\n}\n", "// Copyright 2018-2024 the Deno authors. All rights reserved. MIT license.\n// This module is browser compatible.\n\nimport { assertArg } from \"../_common/from_file_url.ts\";\n\n/**\n * Converts a file URL to a path string.\n *\n * @example Usage\n * ```ts\n * import { fromFileUrl } from \"@std/path/windows/from-file-url\";\n * import { assertEquals } from \"@std/assert\";\n *\n * assertEquals(fromFileUrl(\"file:///home/foo\"), \"\\\\home\\\\foo\");\n * assertEquals(fromFileUrl(\"file:///C:/Users/foo\"), \"C:\\\\Users\\\\foo\");\n * assertEquals(fromFileUrl(\"file://localhost/home/foo\"), \"\\\\home\\\\foo\");\n * ```\n *\n * @param url The file URL to convert.\n * @returns The path string.\n */\nexport function fromFileUrl(url: URL | string): string {\n  url = assertArg(url);\n  let path = decodeURIComponent(\n    url.pathname.replace(/\\//g, \"\\\\\").replace(/%(?![0-9A-Fa-f]{2})/g, \"%25\"),\n  ).replace(/^\\\\*([A-Za-z]:)(\\\\|$)/, \"$1\\\\\");\n  if (url.hostname !== \"\") {\n    // Note: The `URL` implementation guarantees that the drive letter and\n    // hostname are mutually exclusive. Otherwise it would not have been valid\n    // to append the hostname and path like this.\n    path = `\\\\\\\\${url.hostname}${path}`;\n  }\n  return path;\n}\n", "// Copyright 2018-2024 the Deno authors. All rights reserved. MIT license.\n// This module is browser compatible.\n\nimport { isWindows } from \"./_os.ts\";\nimport { fromFileUrl as posixFromFileUrl } from \"./posix/from_file_url.ts\";\nimport { fromFileUrl as windowsFromFileUrl } from \"./windows/from_file_url.ts\";\n\n/**\n * Converts a file URL to a path string.\n *\n * @example Usage\n * ```ts\n * import { fromFileUrl } from \"@std/path/from-file-url\";\n * import { assertEquals } from \"@std/assert\";\n *\n * if (Deno.build.os === \"windows\") {\n *   assertEquals(fromFileUrl(\"file:///home/foo\"), \"\\\\home\\\\foo\");\n *   assertEquals(fromFileUrl(\"file:///C:/Users/foo\"), \"C:\\\\Users\\\\foo\");\n *   assertEquals(fromFileUrl(\"file://localhost/home/foo\"), \"\\\\home\\\\foo\");\n * } else {\n *   assertEquals(fromFileUrl(\"file:///home/foo\"), \"/home/foo\");\n * }\n * ```\n *\n * @param url The file URL to convert to a path.\n * @returns The path string.\n */\nexport function fromFileUrl(url: string | URL): string {\n  return isWindows ? windowsFromFileUrl(url) : posixFromFileUrl(url);\n}\n", "// Copyright 2018-2025 the Deno authors. MIT license.\n// Copyright the Browserify authors. MIT License.\n\nimport { fromFileUrl } from \"jsr:@std/path@^1.0.8/from-file-url\";\n\n/**\n * Convert a URL or string to a path.\n *\n * @param pathUrl A URL or string to be converted.\n *\n * @returns The path as a string.\n */\nexport function toPathString(\n  pathUrl: string | URL,\n): string {\n  return pathUrl instanceof URL ? fromFileUrl(pathUrl) : pathUrl;\n}\n", "// Copyright 2018-2025 the Deno authors. MIT license.\nimport { join } from \"jsr:@std/path@^1.0.8/join\";\nimport { toPathString } from \"./_to_path_string.ts\";\n\n/**\n * Asynchronously ensures that a directory is empty.\n *\n * If the directory does not exist, it is created. The directory itself is not\n * deleted.\n *\n * Requires `--allow-read` and `--allow-write` permissions.\n *\n * @see {@link https://docs.deno.com/runtime/manual/basics/permissions#file-system-access}\n * for more information on Deno's permissions system.\n *\n * @param dir The path of the directory to empty, as a string or URL.\n *\n * @returns A void promise that resolves once the directory is empty.\n *\n * @example Usage\n * ```ts ignore\n * import { emptyDir } from \"@std/fs/empty-dir\";\n *\n * await emptyDir(\"./foo\");\n * ```\n */\nexport async function emptyDir(dir: string | URL) {\n  try {\n    const items = await Array.fromAsync(Deno.readDir(dir));\n\n    await Promise.all(items.map((item) => {\n      if (item && item.name) {\n        const filepath = join(toPathString(dir), item.name);\n        return Deno.remove(filepath, { recursive: true });\n      }\n    }));\n  } catch (err) {\n    if (!(err instanceof Deno.errors.NotFound)) {\n      throw err;\n    }\n\n    // if not exist. then create it\n    await Deno.mkdir(dir, { recursive: true });\n  }\n}\n\n/**\n * Synchronously ensures that a directory is empty deletes the directory\n * contents it is not empty.\n *\n * If the directory does not exist, it is created. The directory itself is not\n * deleted.\n *\n * Requires `--allow-read` and `--allow-write` permissions.\n *\n * @see {@link https://docs.deno.com/runtime/manual/basics/permissions#file-system-access}\n * for more information on Deno's permissions system.\n *\n * @param dir The path of the directory to empty, as a string or URL.\n *\n * @returns A void value that returns once the directory is empty.\n *\n * @example Usage\n * ```ts ignore\n * import { emptyDirSync } from \"@std/fs/empty-dir\";\n *\n * emptyDirSync(\"./foo\");\n * ```\n */\nexport function emptyDirSync(dir: string | URL) {\n  try {\n    const items = [...Deno.readDirSync(dir)];\n\n    // If the directory exists, remove all entries inside it.\n    while (items.length) {\n      const item = items.shift();\n      if (item && item.name) {\n        const filepath = join(toPathString(dir), item.name);\n        Deno.removeSync(filepath, { recursive: true });\n      }\n    }\n  } catch (err) {\n    if (!(err instanceof Deno.errors.NotFound)) {\n      throw err;\n    }\n    // if not exist. then create it\n    Deno.mkdirSync(dir, { recursive: true });\n  }\n}\n", "// Copyright 2018-2025 the Deno authors. MIT license.\n// Copyright the Browserify authors. MIT License.\n\nexport type PathType = \"file\" | \"dir\" | \"symlink\";\n\n/**\n * Get a human readable file type string.\n *\n * @param file File information, as returned by {@linkcode Deno.stat} or\n * {@linkcode Deno.lstat}.\n *\n * @returns The file type as a string, or `undefined` if the file type is\n * unknown.\n */\nexport function getFileInfoType(fileInfo: Deno.FileInfo): PathType | undefined {\n  return fileInfo.isFile\n    ? \"file\"\n    : fileInfo.isDirectory\n    ? \"dir\"\n    : fileInfo.isSymlink\n    ? \"symlink\"\n    : undefined;\n}\n", "// Copyright 2018-2025 the Deno authors. MIT license.\nimport { getFileInfoType } from \"./_get_file_info_type.ts\";\n\n/**\n * Asynchronously ensures that the directory exists, like\n * {@linkcode https://www.ibm.com/docs/en/aix/7.3?topic=m-mkdir-command#mkdir__row-d3e133766 | mkdir -p}.\n *\n * If the directory already exists, this function does nothing. If the directory\n * does not exist, it is created.\n *\n * Requires `--allow-read` and `--allow-write` permissions.\n *\n * @see {@link https://docs.deno.com/runtime/manual/basics/permissions#file-system-access}\n * for more information on Deno's permissions system.\n *\n * @param dir The path of the directory to ensure, as a string or URL.\n *\n * @returns A promise that resolves once the directory exists.\n *\n * @example Usage\n * ```ts ignore\n * import { ensureDir } from \"@std/fs/ensure-dir\";\n *\n * await ensureDir(\"./bar\");\n * ```\n */\nexport async function ensureDir(dir: string | URL) {\n  try {\n    const fileInfo = await Deno.stat(dir);\n    throwIfNotDirectory(fileInfo);\n    return;\n  } catch (err) {\n    if (!(err instanceof Deno.errors.NotFound)) {\n      throw err;\n    }\n  }\n\n  // The dir doesn't exist. Create it.\n  // This can be racy. So we catch AlreadyExists and check stat again.\n  try {\n    await Deno.mkdir(dir, { recursive: true });\n  } catch (err) {\n    if (!(err instanceof Deno.errors.AlreadyExists)) {\n      throw err;\n    }\n\n    const fileInfo = await Deno.stat(dir);\n    throwIfNotDirectory(fileInfo);\n  }\n}\n\n/**\n * Synchronously ensures that the directory exists, like\n * {@linkcode https://www.ibm.com/docs/en/aix/7.3?topic=m-mkdir-command#mkdir__row-d3e133766 | mkdir -p}.\n *\n * If the directory already exists, this function does nothing. If the directory\n * does not exist, it is created.\n *\n * Requires `--allow-read` and `--allow-write` permissions.\n *\n * @see {@link https://docs.deno.com/runtime/manual/basics/permissions#file-system-access}\n * for more information on Deno's permissions system.\n *\n * @param dir The path of the directory to ensure, as a string or URL.\n *\n * @returns A void value that returns once the directory exists.\n *\n * @example Usage\n * ```ts ignore\n * import { ensureDirSync } from \"@std/fs/ensure-dir\";\n *\n * ensureDirSync(\"./bar\");\n * ```\n */\nexport function ensureDirSync(dir: string | URL) {\n  try {\n    const fileInfo = Deno.statSync(dir);\n    throwIfNotDirectory(fileInfo);\n    return;\n  } catch (err) {\n    if (!(err instanceof Deno.errors.NotFound)) {\n      throw err;\n    }\n  }\n\n  // The dir doesn't exist. Create it.\n  // This can be racy. So we catch AlreadyExists and check stat again.\n  try {\n    Deno.mkdirSync(dir, { recursive: true });\n  } catch (err) {\n    if (!(err instanceof Deno.errors.AlreadyExists)) {\n      throw err;\n    }\n\n    const fileInfo = Deno.statSync(dir);\n    throwIfNotDirectory(fileInfo);\n  }\n}\n\nfunction throwIfNotDirectory(fileInfo: Deno.FileInfo) {\n  if (!fileInfo.isDirectory) {\n    throw new Error(\n      `Failed to ensure directory exists: expected 'dir', got '${\n        getFileInfoType(fileInfo)\n      }'`,\n    );\n  }\n}\n", "// Copyright 2018-2024 the Deno authors. All rights reserved. MIT license.\n// This module is browser compatible.\n\nimport { assertPath } from \"./assert_path.ts\";\n\nexport function assertArg(path: string) {\n  assertPath(path);\n  if (path.length === 0) return \".\";\n}\n", "// Copyright 2018-2024 the Deno authors. All rights reserved. MIT license.\n// Copyright the Browserify authors. MIT License.\n// Ported from https://github.com/browserify/path-browserify/\n// This module is browser compatible.\n\nexport function stripTrailingSeparators(\n  segment: string,\n  isSep: (char: number) => boolean,\n): string {\n  if (segment.length <= 1) {\n    return segment;\n  }\n\n  let end = segment.length;\n\n  for (let i = segment.length - 1; i > 0; i--) {\n    if (isSep(segment.charCodeAt(i))) {\n      end = i;\n    } else {\n      break;\n    }\n  }\n\n  return segment.slice(0, end);\n}\n", "// Copyright 2018-2024 the Deno authors. All rights reserved. MIT license.\n// This module is browser compatible.\n\nimport { assertArg } from \"../_common/dirname.ts\";\nimport { stripTrailingSeparators } from \"../_common/strip_trailing_separators.ts\";\nimport { isPosixPathSeparator } from \"./_util.ts\";\n\n/**\n * Return the directory path of a `path`.\n *\n * @example Usage\n * ```ts\n * import { dirname } from \"@std/path/posix/dirname\";\n * import { assertEquals } from \"@std/assert\";\n *\n * assertEquals(dirname(\"/home/user/Documents/\"), \"/home/user\");\n * assertEquals(dirname(\"/home/user/Documents/image.png\"), \"/home/user/Documents\");\n * assertEquals(dirname(\"https://deno.land/std/path/mod.ts\"), \"https://deno.land/std/path\");\n * ```\n *\n * @example Working with URLs\n *\n * ```ts\n * import { dirname } from \"@std/path/posix/dirname\";\n * import { assertEquals } from \"@std/assert\";\n *\n * assertEquals(dirname(\"https://deno.land/std/path/mod.ts\"), \"https://deno.land/std/path\");\n * assertEquals(dirname(\"https://deno.land/std/path/mod.ts?a=b\"), \"https://deno.land/std/path\");\n * assertEquals(dirname(\"https://deno.land/std/path/mod.ts#header\"), \"https://deno.land/std/path\");\n * ```\n *\n * Note: If you are working with file URLs,\n * use the new version of `dirname` from `@std/path/posix/unstable-dirname`.\n *\n * @param path The path to get the directory from.\n * @returns The directory path.\n */\nexport function dirname(path: string): string {\n  assertArg(path);\n\n  let end = -1;\n  let matchedNonSeparator = false;\n\n  for (let i = path.length - 1; i >= 1; --i) {\n    if (isPosixPathSeparator(path.charCodeAt(i))) {\n      if (matchedNonSeparator) {\n        end = i;\n        break;\n      }\n    } else {\n      matchedNonSeparator = true;\n    }\n  }\n\n  // No matches. Fallback based on provided path:\n  //\n  // - leading slashes paths\n  //     \"/foo\" => \"/\"\n  //     \"///foo\" => \"/\"\n  // - no slash path\n  //     \"foo\" => \".\"\n  if (end === -1) {\n    return isPosixPathSeparator(path.charCodeAt(0)) ? \"/\" : \".\";\n  }\n\n  return stripTrailingSeparators(\n    path.slice(0, end),\n    isPosixPathSeparator,\n  );\n}\n", "// Copyright 2018-2024 the Deno authors. All rights reserved. MIT license.\n// This module is browser compatible.\n\nimport { assertArg } from \"../_common/dirname.ts\";\nimport { CHAR_COLON } from \"../_common/constants.ts\";\nimport { stripTrailingSeparators } from \"../_common/strip_trailing_separators.ts\";\nimport {\n  isPathSeparator,\n  isPosixPathSeparator,\n  isWindowsDeviceRoot,\n} from \"./_util.ts\";\n\n/**\n * Return the directory path of a `path`.\n *\n * @example Usage\n * ```ts\n * import { dirname } from \"@std/path/windows/dirname\";\n * import { assertEquals } from \"@std/assert\";\n *\n * const dir = dirname(\"C:\\\\foo\\\\bar\\\\baz.ext\");\n * assertEquals(dir, \"C:\\\\foo\\\\bar\");\n * ```\n *\n * Note: If you are working with file URLs,\n * use the new version of `dirname` from `@std/path/windows/unstable-dirname`.\n *\n * @param path The path to get the directory from.\n * @returns The directory path.\n */\nexport function dirname(path: string): string {\n  assertArg(path);\n\n  const len = path.length;\n  let rootEnd = -1;\n  let end = -1;\n  let matchedSlash = true;\n  let offset = 0;\n  const code = path.charCodeAt(0);\n\n  // Try to match a root\n  if (len > 1) {\n    if (isPathSeparator(code)) {\n      // Possible UNC root\n\n      rootEnd = offset = 1;\n\n      if (isPathSeparator(path.charCodeAt(1))) {\n        // Matched double path separator at beginning\n        let j = 2;\n        let last = j;\n        // Match 1 or more non-path separators\n        for (; j < len; ++j) {\n          if (isPathSeparator(path.charCodeAt(j))) break;\n        }\n        if (j < len && j !== last) {\n          // Matched!\n          last = j;\n          // Match 1 or more path separators\n          for (; j < len; ++j) {\n            if (!isPathSeparator(path.charCodeAt(j))) break;\n          }\n          if (j < len && j !== last) {\n            // Matched!\n            last = j;\n            // Match 1 or more non-path separators\n            for (; j < len; ++j) {\n              if (isPathSeparator(path.charCodeAt(j))) break;\n            }\n            if (j === len) {\n              // We matched a UNC root only\n              return path;\n            }\n            if (j !== last) {\n              // We matched a UNC root with leftovers\n\n              // Offset by 1 to include the separator after the UNC root to\n              // treat it as a \"normal root\" on top of a (UNC) root\n              rootEnd = offset = j + 1;\n            }\n          }\n        }\n      }\n    } else if (isWindowsDeviceRoot(code)) {\n      // Possible device root\n\n      if (path.charCodeAt(1) === CHAR_COLON) {\n        rootEnd = offset = 2;\n        if (len > 2) {\n          if (isPathSeparator(path.charCodeAt(2))) rootEnd = offset = 3;\n        }\n      }\n    }\n  } else if (isPathSeparator(code)) {\n    // `path` contains just a path separator, exit early to avoid\n    // unnecessary work\n    return path;\n  }\n\n  for (let i = len - 1; i >= offset; --i) {\n    if (isPathSeparator(path.charCodeAt(i))) {\n      if (!matchedSlash) {\n        end = i;\n        break;\n      }\n    } else {\n      // We saw the first non-path separator\n      matchedSlash = false;\n    }\n  }\n\n  if (end === -1) {\n    if (rootEnd === -1) return \".\";\n    else end = rootEnd;\n  }\n  return stripTrailingSeparators(path.slice(0, end), isPosixPathSeparator);\n}\n", "// Copyright 2018-2024 the Deno authors. All rights reserved. MIT license.\n// This module is browser compatible.\n\nimport { isWindows } from \"./_os.ts\";\nimport { dirname as posixDirname } from \"./posix/dirname.ts\";\nimport { dirname as windowsDirname } from \"./windows/dirname.ts\";\n\n/**\n * Return the directory path of a path.\n *\n * @example Usage\n * ```ts\n * import { dirname } from \"@std/path/dirname\";\n * import { assertEquals } from \"@std/assert\";\n *\n * if (Deno.build.os === \"windows\") {\n *   assertEquals(dirname(\"C:\\\\home\\\\user\\\\Documents\\\\image.png\"), \"C:\\\\home\\\\user\\\\Documents\");\n * } else {\n *   assertEquals(dirname(\"/home/user/Documents/image.png\"), \"/home/user/Documents\");\n * }\n * ```\n *\n * Note: If you are working with file URLs,\n * use the new version of `dirname` from `@std/path/unstable-dirname`.\n *\n * @param path Path to extract the directory from.\n * @returns The directory path.\n */\nexport function dirname(path: string): string {\n  return isWindows ? windowsDirname(path) : posixDirname(path);\n}\n", "// Copyright 2018-2025 the Deno authors. MIT license.\nimport { dirname } from \"jsr:@std/path@^1.0.8/dirname\";\nimport { ensureDir, ensureDirSync } from \"./ensure_dir.ts\";\nimport { getFileInfoType } from \"./_get_file_info_type.ts\";\nimport { toPathString } from \"./_to_path_string.ts\";\n\n/**\n * Asynchronously ensures that the file exists.\n *\n * If the file already exists, this function does nothing. If the parent\n * directories for the file do not exist, they are created.\n *\n * Requires `--allow-read` and `--allow-write` permissions.\n *\n * @see {@link https://docs.deno.com/runtime/manual/basics/permissions#file-system-access}\n * for more information on Deno's permissions system.\n *\n * @param filePath The path of the file to ensure, as a string or URL.\n *\n * @returns A void promise that resolves once the file exists.\n *\n * @example Usage\n * ```ts ignore\n * import { ensureFile } from \"@std/fs/ensure-file\";\n *\n * await ensureFile(\"./folder/targetFile.dat\");\n * ```\n */\nexport async function ensureFile(filePath: string | URL): Promise<void> {\n  try {\n    // if file exists\n    const stat = await Deno.lstat(filePath);\n    if (!stat.isFile) {\n      throw new Error(\n        `Failed to ensure file exists: expected 'file', got '${\n          getFileInfoType(stat)\n        }'`,\n      );\n    }\n  } catch (err) {\n    // if file not exists\n    if (err instanceof Deno.errors.NotFound) {\n      // ensure dir exists\n      await ensureDir(dirname(toPathString(filePath)));\n      // create file\n      await Deno.writeFile(filePath, new Uint8Array());\n      return;\n    }\n\n    throw err;\n  }\n}\n\n/**\n * Synchronously ensures that the file exists.\n *\n * If the file already exists, this function does nothing. If the parent\n * directories for the file do not exist, they are created.\n *\n * Requires `--allow-read` and `--allow-write` permissions.\n *\n * @see {@link https://docs.deno.com/runtime/manual/basics/permissions#file-system-access}\n * for more information on Deno's permissions system.\n *\n * @param filePath The path of the file to ensure, as a string or URL.\n *\n * @returns A void value that returns once the file exists.\n *\n * @example Usage\n * ```ts ignore\n * import { ensureFileSync } from \"@std/fs/ensure-file\";\n *\n * ensureFileSync(\"./folder/targetFile.dat\");\n * ```\n */\nexport function ensureFileSync(filePath: string | URL): void {\n  try {\n    // if file exists\n    const stat = Deno.lstatSync(filePath);\n    if (!stat.isFile) {\n      throw new Error(\n        `Failed to ensure file exists: expected 'file', got '${\n          getFileInfoType(stat)\n        }'`,\n      );\n    }\n  } catch (err) {\n    // if file not exists\n    if (err instanceof Deno.errors.NotFound) {\n      // ensure dir exists\n      ensureDirSync(dirname(toPathString(filePath)));\n      // create file\n      Deno.writeFileSync(filePath, new Uint8Array());\n      return;\n    }\n    throw err;\n  }\n}\n", "// Copyright 2018-2025 the Deno authors. MIT license.\nimport { dirname } from \"jsr:@std/path@^1.0.8/dirname\";\nimport { ensureDir, ensureDirSync } from \"./ensure_dir.ts\";\nimport { toPathString } from \"./_to_path_string.ts\";\n\n/**\n * Asynchronously ensures that the hard link exists.\n *\n * If the parent directories for the hard link do not exist, they are created.\n *\n * Requires `--allow-read` and `--allow-write` permissions.\n *\n * @see {@link https://docs.deno.com/runtime/manual/basics/permissions#file-system-access}\n * for more information on Deno's permissions system.\n *\n * @param src The source file path as a string or URL. Directory hard links are\n * not allowed.\n * @param dest The destination link path as a string or URL.\n *\n * @returns A void promise that resolves once the hard link exists.\n *\n * @example Usage\n * ```ts ignore\n * import { ensureLink } from \"@std/fs/ensure-link\";\n *\n * await ensureLink(\"./folder/targetFile.dat\", \"./folder/targetFile.link.dat\");\n * ```\n */\nexport async function ensureLink(src: string | URL, dest: string | URL) {\n  dest = toPathString(dest);\n  await ensureDir(dirname(dest));\n\n  await Deno.link(toPathString(src), dest);\n}\n\n/**\n * Synchronously ensures that the hard link exists.\n *\n * If the parent directories for the hard link do not exist, they are created.\n *\n * Requires `--allow-read` and `--allow-write` permissions.\n *\n * @see {@link https://docs.deno.com/runtime/manual/basics/permissions#file-system-access}\n * for more information on Deno's permissions system.\n *\n * @param src The source file path as a string or URL. Directory hard links are\n * not allowed.\n * @param dest The destination link path as a string or URL.\n *\n * @returns A void value that returns once the hard link exists.\n *\n * @example Usage\n * ```ts ignore\n * import { ensureLinkSync } from \"@std/fs/ensure-link\";\n *\n * ensureLinkSync(\"./folder/targetFile.dat\", \"./folder/targetFile.link.dat\");\n * ```\n */\nexport function ensureLinkSync(src: string | URL, dest: string | URL) {\n  dest = toPathString(dest);\n  ensureDirSync(dirname(dest));\n\n  Deno.linkSync(toPathString(src), dest);\n}\n", "// Copyright 2018-2024 the Deno authors. All rights reserved. MIT license.\n// This module is browser compatible.\n\nimport { normalizeString } from \"../_common/normalize_string.ts\";\nimport { assertPath } from \"../_common/assert_path.ts\";\nimport { isPosixPathSeparator } from \"./_util.ts\";\n\n/**\n * Resolves path segments into a `path`.\n *\n * @example Usage\n * ```ts\n * import { resolve } from \"@std/path/posix/resolve\";\n * import { assertEquals } from \"@std/assert\";\n *\n * const path = resolve(\"/foo\", \"bar\", \"baz/asdf\", \"quux\", \"..\");\n * assertEquals(path, \"/foo/bar/baz/asdf\");\n * ```\n *\n * @param pathSegments The path segments to resolve.\n * @returns The resolved path.\n */\nexport function resolve(...pathSegments: string[]): string {\n  let resolvedPath = \"\";\n  let resolvedAbsolute = false;\n\n  for (let i = pathSegments.length - 1; i >= -1 && !resolvedAbsolute; i--) {\n    let path: string;\n\n    if (i >= 0) path = pathSegments[i]!;\n    else {\n      // deno-lint-ignore no-explicit-any\n      const { Deno } = globalThis as any;\n      if (typeof Deno?.cwd !== \"function\") {\n        throw new TypeError(\n          \"Resolved a relative path without a current working directory (CWD)\",\n        );\n      }\n      path = Deno.cwd();\n    }\n\n    assertPath(path);\n\n    // Skip empty entries\n    if (path.length === 0) {\n      continue;\n    }\n\n    resolvedPath = `${path}/${resolvedPath}`;\n    resolvedAbsolute = isPosixPathSeparator(path.charCodeAt(0));\n  }\n\n  // At this point the path should be resolved to a full absolute path, but\n  // handle relative paths to be safe (might happen when Deno.cwd() fails)\n\n  // Normalize the path\n  resolvedPath = normalizeString(\n    resolvedPath,\n    !resolvedAbsolute,\n    \"/\",\n    isPosixPathSeparator,\n  );\n\n  if (resolvedAbsolute) {\n    if (resolvedPath.length > 0) return `/${resolvedPath}`;\n    else return \"/\";\n  } else if (resolvedPath.length > 0) return resolvedPath;\n  else return \".\";\n}\n", "// Copyright 2018-2024 the Deno authors. All rights reserved. MIT license.\n// This module is browser compatible.\n\nimport { CHAR_COLON } from \"../_common/constants.ts\";\nimport { normalizeString } from \"../_common/normalize_string.ts\";\nimport { assertPath } from \"../_common/assert_path.ts\";\nimport { isPathSeparator, isWindowsDeviceRoot } from \"./_util.ts\";\n\n/**\n * Resolves path segments into a `path`.\n *\n * @example Usage\n * ```ts\n * import { resolve } from \"@std/path/windows/resolve\";\n * import { assertEquals } from \"@std/assert\";\n *\n * const resolved = resolve(\"C:\\\\foo\\\\bar\", \"..\\\\baz\");\n * assertEquals(resolved, \"C:\\\\foo\\\\baz\");\n * ```\n *\n * @param pathSegments The path segments to process to path\n * @returns The resolved path\n */\nexport function resolve(...pathSegments: string[]): string {\n  let resolvedDevice = \"\";\n  let resolvedTail = \"\";\n  let resolvedAbsolute = false;\n\n  for (let i = pathSegments.length - 1; i >= -1; i--) {\n    let path: string;\n    // deno-lint-ignore no-explicit-any\n    const { Deno } = globalThis as any;\n    if (i >= 0) {\n      path = pathSegments[i]!;\n    } else if (!resolvedDevice) {\n      if (typeof Deno?.cwd !== \"function\") {\n        throw new TypeError(\n          \"Resolved a drive-letter-less path without a current working directory (CWD)\",\n        );\n      }\n      path = Deno.cwd();\n    } else {\n      if (\n        typeof Deno?.env?.get !== \"function\" || typeof Deno?.cwd !== \"function\"\n      ) {\n        throw new TypeError(\n          \"Resolved a relative path without a current working directory (CWD)\",\n        );\n      }\n      path = Deno.cwd();\n\n      // Verify that a cwd was found and that it actually points\n      // to our drive. If not, default to the drive's root.\n      if (\n        path === undefined ||\n        path.slice(0, 3).toLowerCase() !== `${resolvedDevice.toLowerCase()}\\\\`\n      ) {\n        path = `${resolvedDevice}\\\\`;\n      }\n    }\n\n    assertPath(path);\n\n    const len = path.length;\n\n    // Skip empty entries\n    if (len === 0) continue;\n\n    let rootEnd = 0;\n    let device = \"\";\n    let isAbsolute = false;\n    const code = path.charCodeAt(0);\n\n    // Try to match a root\n    if (len > 1) {\n      if (isPathSeparator(code)) {\n        // Possible UNC root\n\n        // If we started with a separator, we know we at least have an\n        // absolute path of some kind (UNC or otherwise)\n        isAbsolute = true;\n\n        if (isPathSeparator(path.charCodeAt(1))) {\n          // Matched double path separator at beginning\n          let j = 2;\n          let last = j;\n          // Match 1 or more non-path separators\n          for (; j < len; ++j) {\n            if (isPathSeparator(path.charCodeAt(j))) break;\n          }\n          if (j < len && j !== last) {\n            const firstPart = path.slice(last, j);\n            // Matched!\n            last = j;\n            // Match 1 or more path separators\n            for (; j < len; ++j) {\n              if (!isPathSeparator(path.charCodeAt(j))) break;\n            }\n            if (j < len && j !== last) {\n              // Matched!\n              last = j;\n              // Match 1 or more non-path separators\n              for (; j < len; ++j) {\n                if (isPathSeparator(path.charCodeAt(j))) break;\n              }\n              if (j === len) {\n                // We matched a UNC root only\n                device = `\\\\\\\\${firstPart}\\\\${path.slice(last)}`;\n                rootEnd = j;\n              } else if (j !== last) {\n                // We matched a UNC root with leftovers\n\n                device = `\\\\\\\\${firstPart}\\\\${path.slice(last, j)}`;\n                rootEnd = j;\n              }\n            }\n          }\n        } else {\n          rootEnd = 1;\n        }\n      } else if (isWindowsDeviceRoot(code)) {\n        // Possible device root\n\n        if (path.charCodeAt(1) === CHAR_COLON) {\n          device = path.slice(0, 2);\n          rootEnd = 2;\n          if (len > 2) {\n            if (isPathSeparator(path.charCodeAt(2))) {\n              // Treat separator following drive name as an absolute path\n              // indicator\n              isAbsolute = true;\n              rootEnd = 3;\n            }\n          }\n        }\n      }\n    } else if (isPathSeparator(code)) {\n      // `path` contains just a path separator\n      rootEnd = 1;\n      isAbsolute = true;\n    }\n\n    if (\n      device.length > 0 &&\n      resolvedDevice.length > 0 &&\n      device.toLowerCase() !== resolvedDevice.toLowerCase()\n    ) {\n      // This path points to another device so it is not applicable\n      continue;\n    }\n\n    if (resolvedDevice.length === 0 && device.length > 0) {\n      resolvedDevice = device;\n    }\n    if (!resolvedAbsolute) {\n      resolvedTail = `${path.slice(rootEnd)}\\\\${resolvedTail}`;\n      resolvedAbsolute = isAbsolute;\n    }\n\n    if (resolvedAbsolute && resolvedDevice.length > 0) break;\n  }\n\n  // At this point the path should be resolved to a full absolute path,\n  // but handle relative paths to be safe (might happen when Deno.cwd()\n  // fails)\n\n  // Normalize the tail path\n  resolvedTail = normalizeString(\n    resolvedTail,\n    !resolvedAbsolute,\n    \"\\\\\",\n    isPathSeparator,\n  );\n\n  return resolvedDevice + (resolvedAbsolute ? \"\\\\\" : \"\") + resolvedTail || \".\";\n}\n", "// Copyright 2018-2024 the Deno authors. All rights reserved. MIT license.\n// This module is browser compatible.\n\nimport { isWindows } from \"./_os.ts\";\nimport { resolve as posixResolve } from \"./posix/resolve.ts\";\nimport { resolve as windowsResolve } from \"./windows/resolve.ts\";\n\n/**\n * Resolves path segments into a path.\n *\n * @example Usage\n * ```ts\n * import { resolve } from \"@std/path/resolve\";\n * import { assertEquals } from \"@std/assert\";\n *\n * if (Deno.build.os === \"windows\") {\n *   assertEquals(resolve(\"C:\\\\foo\", \"bar\", \"baz\"), \"C:\\\\foo\\\\bar\\\\baz\");\n *   assertEquals(resolve(\"C:\\\\foo\", \"C:\\\\bar\", \"baz\"), \"C:\\\\bar\\\\baz\");\n * } else {\n *   assertEquals(resolve(\"/foo\", \"bar\", \"baz\"), \"/foo/bar/baz\");\n *   assertEquals(resolve(\"/foo\", \"/bar\", \"baz\"), \"/bar/baz\");\n * }\n * ```\n *\n * @param pathSegments Path segments to process to path.\n * @returns The resolved path.\n */\nexport function resolve(...pathSegments: string[]): string {\n  return isWindows\n    ? windowsResolve(...pathSegments)\n    : posixResolve(...pathSegments);\n}\n", "// Copyright 2018-2025 the Deno authors. MIT license.\nimport { dirname } from \"jsr:@std/path@^1.0.8/dirname\";\nimport { resolve } from \"jsr:@std/path@^1.0.8/resolve\";\nimport { ensureDir, ensureDirSync } from \"./ensure_dir.ts\";\nimport { getFileInfoType, type PathType } from \"./_get_file_info_type.ts\";\nimport { toPathString } from \"./_to_path_string.ts\";\n\n// deno-lint-ignore no-explicit-any\nconst isWindows = (globalThis as any).Deno?.build.os === \"windows\";\n\nfunction resolveSymlinkTarget(target: string | URL, linkName: string | URL) {\n  if (typeof target !== \"string\") return target; // URL is always absolute path\n  if (typeof linkName === \"string\") {\n    return resolve(dirname(linkName), target);\n  } else {\n    return new URL(target, linkName);\n  }\n}\n\nfunction getSymlinkOption(\n  type: PathType | undefined,\n): Deno.SymlinkOptions | undefined {\n  return isWindows ? { type: type === \"dir\" ? \"dir\" : \"file\" } : undefined;\n}\n\n/**\n * Asynchronously ensures that the link exists, and points to a valid file.\n *\n * If the parent directories for the link do not exist, they are created. If the\n * link already exists, and it is not modified, this function does nothing. If\n * the link already exists, and it does not point to the given target, an error\n * is thrown.\n *\n * Requires `--allow-read` and `--allow-write` permissions.\n *\n * @see {@link https://docs.deno.com/runtime/manual/basics/permissions#file-system-access}\n * for more information on Deno's permissions system.\n *\n * @param target The source file path as a string or URL. If it is a relative path string, it have to be relative to the link path.\n * @param linkName The destination link path as a string or URL.\n *\n * @returns A void promise that resolves once the link exists.\n *\n * @example Basic usage\n * ```ts ignore\n * import { ensureSymlink } from \"@std/fs/ensure-symlink\";\n *\n * // Ensures the link `./targetFile.link.dat` exists and points to `./targetFile.dat`\n * await ensureSymlink(\"./targetFile.dat\", \"./targetFile.link.dat\");\n * ```\n *\n * @example Ensuring a link in a folder\n * ```ts ignore\n * import { ensureSymlink } from \"@std/fs/ensure-symlink\";\n *\n * // Ensures the link `./folder/targetFile.link.dat` exists and points to `./folder/targetFile.dat`\n * await ensureSymlink(\"./targetFile.dat\", \"./folder/targetFile.link.dat\");\n * ```\n */\nexport async function ensureSymlink(\n  target: string | URL,\n  linkName: string | URL,\n) {\n  const targetRealPath = resolveSymlinkTarget(target, linkName);\n  let srcStatInfo;\n  try {\n    srcStatInfo = await Deno.lstat(targetRealPath);\n  } catch (error) {\n    if (error instanceof Deno.errors.NotFound) {\n      throw new Deno.errors.NotFound(\n        `Cannot ensure symlink as the target path does not exist: ${targetRealPath}`,\n      );\n    }\n    throw error;\n  }\n  const srcFilePathType = getFileInfoType(srcStatInfo);\n\n  await ensureDir(dirname(toPathString(linkName)));\n\n  const options = getSymlinkOption(srcFilePathType);\n\n  try {\n    await Deno.symlink(target, linkName, options);\n  } catch (error) {\n    if (!(error instanceof Deno.errors.AlreadyExists)) {\n      throw error;\n    }\n    const linkStatInfo = await Deno.lstat(linkName);\n    if (!linkStatInfo.isSymlink) {\n      const type = getFileInfoType(linkStatInfo);\n      throw new Deno.errors.AlreadyExists(\n        `A '${type}' already exists at the path: ${linkName}`,\n      );\n    }\n    const linkPath = await Deno.readLink(linkName);\n    const linkRealPath = resolve(linkPath);\n    if (linkRealPath !== targetRealPath) {\n      throw new Deno.errors.AlreadyExists(\n        `A symlink targeting to an undesired path already exists: ${linkName} -> ${linkRealPath}`,\n      );\n    }\n  }\n}\n\n/**\n * Synchronously ensures that the link exists, and points to a valid file.\n *\n * If the parent directories for the link do not exist, they are created. If the\n * link already exists, and it is not modified, this function does nothing. If\n * the link already exists, and it does not point to the given target, an error\n * is thrown.\n *\n * Requires `--allow-read` and `--allow-write` permissions.\n *\n * @see {@link https://docs.deno.com/runtime/manual/basics/permissions#file-system-access}\n * for more information on Deno's permissions system.\n *\n * @param target The source file path as a string or URL. If it is a relative path string, it have to be relative to the link path.\n * @param linkName The destination link path as a string or URL.\n * @returns A void value that returns once the link exists.\n *\n * @example Basic usage\n * ```ts ignore\n * import { ensureSymlinkSync } from \"@std/fs/ensure-symlink\";\n *\n * // Ensures the link `./targetFile.link.dat` exists and points to `./targetFile.dat`\n * ensureSymlinkSync(\"./targetFile.dat\", \"./targetFile.link.dat\");\n * ```\n *\n * @example Ensuring a link in a folder\n * ```ts ignore\n * import { ensureSymlinkSync } from \"@std/fs/ensure-symlink\";\n *\n * // Ensures the link `./folder/targetFile.link.dat` exists and points to `./folder/targetFile.dat`\n * ensureSymlinkSync(\"./targetFile.dat\", \"./folder/targetFile.link.dat\");\n * ```\n */\nexport function ensureSymlinkSync(\n  target: string | URL,\n  linkName: string | URL,\n) {\n  const targetRealPath = resolveSymlinkTarget(target, linkName);\n  let srcStatInfo;\n  try {\n    srcStatInfo = Deno.lstatSync(targetRealPath);\n  } catch (error) {\n    if (error instanceof Deno.errors.NotFound) {\n      throw new Deno.errors.NotFound(\n        `Cannot ensure symlink as the target path does not exist: ${targetRealPath}`,\n      );\n    }\n    throw error;\n  }\n  const srcFilePathType = getFileInfoType(srcStatInfo);\n\n  ensureDirSync(dirname(toPathString(linkName)));\n\n  const options = getSymlinkOption(srcFilePathType);\n\n  try {\n    Deno.symlinkSync(target, linkName, options);\n  } catch (error) {\n    if (!(error instanceof Deno.errors.AlreadyExists)) {\n      throw error;\n    }\n    const linkStatInfo = Deno.lstatSync(linkName);\n    if (!linkStatInfo.isSymlink) {\n      const type = getFileInfoType(linkStatInfo);\n      throw new Deno.errors.AlreadyExists(\n        `A '${type}' already exists at the path: ${linkName}`,\n      );\n    }\n    const linkPath = Deno.readLinkSync(linkName);\n    const linkRealPath = resolve(linkPath);\n    if (linkRealPath !== targetRealPath) {\n      throw new Deno.errors.AlreadyExists(\n        `A symlink targeting to an undesired path already exists: ${linkName} -> ${linkRealPath}`,\n      );\n    }\n  }\n}\n", "// Copyright 2018-2025 the Deno authors. MIT license.\n\n/** Options for {@linkcode exists} and {@linkcode existsSync.} */\nexport interface ExistsOptions {\n  /**\n   * When `true`, will check if the path is readable by the user as well.\n   *\n   * @default {false}\n   */\n  isReadable?: boolean;\n  /**\n   * When `true`, will check if the path is a directory as well. Directory\n   * symlinks are included.\n   *\n   * @default {false}\n   */\n  isDirectory?: boolean;\n  /**\n   * When `true`, will check if the path is a file as well. File symlinks are\n   * included.\n   *\n   * @default {false}\n   */\n  isFile?: boolean;\n}\n\n/**\n * Asynchronously test whether or not the given path exists by checking with\n * the file system.\n *\n * Note: Do not use this function if performing a check before another operation\n * on that file. Doing so creates a race condition. Instead, perform the actual\n * file operation directly. This function is not recommended for this use case.\n * See the recommended method below.\n *\n * @see {@link https://en.wikipedia.org/wiki/Time-of-check_to_time-of-use} for\n * more information on the time-of-check to time-of-use bug.\n *\n * Requires `--allow-read` permissions, and in some cases, `--allow-sys`\n * permissions if `options.isReadable` is `true`.\n *\n * @see {@link https://docs.deno.com/runtime/manual/basics/permissions#file-system-access}\n * for more information on Deno's permissions system.\n *\n * @param path The path to the file or directory, as a string or URL.\n * @param options Additional options for the check.\n *\n * @returns A promise that resolves with `true` if the path exists, `false`\n * otherwise.\n *\n * @example Recommended method\n * ```ts ignore\n * // Notice no use of exists\n * try {\n *   await Deno.remove(\"./foo\", { recursive: true });\n * } catch (error) {\n *   if (!(error instanceof Deno.errors.NotFound)) {\n *     throw error;\n *   }\n *   // Do nothing...\n * }\n * ```\n *\n * Notice that `exists()` is not used in the above example. Doing so avoids a\n * possible race condition. See the above note for details.\n *\n * @example Basic usage\n * ```ts ignore\n * import { exists } from \"@std/fs/exists\";\n *\n * await exists(\"./exists\"); // true\n * await exists(\"./does_not_exist\"); // false\n * ```\n *\n * @example Check if a path is readable\n *\n * Requires `--allow-sys` permissions in some cases.\n *\n * ```ts ignore\n * import { exists } from \"@std/fs/exists\";\n *\n * await exists(\"./readable\", { isReadable: true }); // true\n * await exists(\"./not_readable\", { isReadable: true }); // false\n * ```\n *\n * @example Check if a path is a directory\n * ```ts ignore\n * import { exists } from \"@std/fs/exists\";\n *\n * await exists(\"./directory\", { isDirectory: true }); // true\n * await exists(\"./file\", { isDirectory: true }); // false\n * ```\n *\n * @example Check if a path is a file\n * ```ts ignore\n * import { exists } from \"@std/fs/exists\";\n *\n * await exists(\"./file\", { isFile: true }); // true\n * await exists(\"./directory\", { isFile: true }); // false\n * ```\n *\n * @example Check if a path is a readable directory\n *\n * Requires `--allow-sys` permissions in some cases.\n *\n * ```ts ignore\n * import { exists } from \"@std/fs/exists\";\n *\n * await exists(\"./readable_directory\", { isReadable: true, isDirectory: true }); // true\n * await exists(\"./not_readable_directory\", { isReadable: true, isDirectory: true }); // false\n * ```\n *\n * @example Check if a path is a readable file\n *\n * Requires `--allow-sys` permissions in some cases.\n *\n * ```ts ignore\n * import { exists } from \"@std/fs/exists\";\n *\n * await exists(\"./readable_file\", { isReadable: true, isFile: true }); // true\n * await exists(\"./not_readable_file\", { isReadable: true, isFile: true }); // false\n * ```\n */\nexport async function exists(\n  path: string | URL,\n  options?: ExistsOptions,\n): Promise<boolean> {\n  try {\n    const stat = await Deno.stat(path);\n    if (\n      options &&\n      (options.isReadable || options.isDirectory || options.isFile)\n    ) {\n      if (options.isDirectory && options.isFile) {\n        throw new TypeError(\n          \"ExistsOptions.options.isDirectory and ExistsOptions.options.isFile must not be true together\",\n        );\n      }\n      if (\n        (options.isDirectory && !stat.isDirectory) ||\n        (options.isFile && !stat.isFile)\n      ) {\n        return false;\n      }\n      if (options.isReadable) {\n        return fileIsReadable(stat);\n      }\n    }\n    return true;\n  } catch (error) {\n    if (error instanceof Deno.errors.NotFound) {\n      return false;\n    }\n    if (error instanceof Deno.errors.PermissionDenied) {\n      if (\n        (await Deno.permissions.query({ name: \"read\", path })).state ===\n          \"granted\"\n      ) {\n        // --allow-read not missing\n        return !options?.isReadable; // PermissionDenied was raised by file system, so the item exists, but can't be read\n      }\n    }\n    throw error;\n  }\n}\n\n/**\n * Synchronously test whether or not the given path exists by checking with\n * the file system.\n *\n * Note: Do not use this function if performing a check before another operation\n * on that file. Doing so creates a race condition. Instead, perform the actual\n * file operation directly. This function is not recommended for this use case.\n * See the recommended method below.\n *\n * @see {@link https://en.wikipedia.org/wiki/Time-of-check_to_time-of-use} for\n * more information on the time-of-check to time-of-use bug.\n *\n * Requires `--allow-read` permissions, and in some cases, `--allow-sys`\n * permissions if `options.isReadable` is `true`.\n *\n * @see {@link https://docs.deno.com/runtime/manual/basics/permissions#file-system-access}\n * for more information on Deno's permissions system.\n *\n * @param path The path to the file or directory, as a string or URL.\n * @param options Additional options for the check.\n *\n * @returns `true` if the path exists, `false` otherwise.\n *\n * @example Recommended method\n * ```ts ignore\n * // Notice no use of exists\n * try {\n *   Deno.removeSync(\"./foo\", { recursive: true });\n * } catch (error) {\n *   if (!(error instanceof Deno.errors.NotFound)) {\n *     throw error;\n *   }\n *   // Do nothing...\n * }\n * ```\n *\n * Notice that `existsSync()` is not used in the above example. Doing so avoids\n * a possible race condition. See the above note for details.\n *\n * @example Basic usage\n * ```ts ignore\n * import { existsSync } from \"@std/fs/exists\";\n *\n * existsSync(\"./exists\"); // true\n * existsSync(\"./does_not_exist\"); // false\n * ```\n *\n * @example Check if a path is readable\n *\n * Requires `--allow-sys` permissions in some cases.\n *\n * ```ts ignore\n * import { existsSync } from \"@std/fs/exists\";\n *\n * existsSync(\"./readable\", { isReadable: true }); // true\n * existsSync(\"./not_readable\", { isReadable: true }); // false\n * ```\n *\n * @example Check if a path is a directory\n * ```ts ignore\n * import { existsSync } from \"@std/fs/exists\";\n *\n * existsSync(\"./directory\", { isDirectory: true }); // true\n * existsSync(\"./file\", { isDirectory: true }); // false\n * ```\n *\n * @example Check if a path is a file\n * ```ts ignore\n * import { existsSync } from \"@std/fs/exists\";\n *\n * existsSync(\"./file\", { isFile: true }); // true\n * existsSync(\"./directory\", { isFile: true }); // false\n * ```\n *\n * @example Check if a path is a readable directory\n *\n * Requires `--allow-sys` permissions in some cases.\n *\n * ```ts ignore\n * import { existsSync } from \"@std/fs/exists\";\n *\n * existsSync(\"./readable_directory\", { isReadable: true, isDirectory: true }); // true\n * existsSync(\"./not_readable_directory\", { isReadable: true, isDirectory: true }); // false\n * ```\n *\n * @example Check if a path is a readable file\n *\n * Requires `--allow-sys` permissions in some cases.\n *\n * ```ts ignore\n * import { existsSync } from \"@std/fs/exists\";\n *\n * existsSync(\"./readable_file\", { isReadable: true, isFile: true }); // true\n * existsSync(\"./not_readable_file\", { isReadable: true, isFile: true }); // false\n * ```\n */\nexport function existsSync(\n  path: string | URL,\n  options?: ExistsOptions,\n): boolean {\n  try {\n    const stat = Deno.statSync(path);\n    if (\n      options &&\n      (options.isReadable || options.isDirectory || options.isFile)\n    ) {\n      if (options.isDirectory && options.isFile) {\n        throw new TypeError(\n          \"ExistsOptions.options.isDirectory and ExistsOptions.options.isFile must not be true together\",\n        );\n      }\n      if (\n        (options.isDirectory && !stat.isDirectory) ||\n        (options.isFile && !stat.isFile)\n      ) {\n        return false;\n      }\n      if (options.isReadable) {\n        return fileIsReadable(stat);\n      }\n    }\n    return true;\n  } catch (error) {\n    if (error instanceof Deno.errors.NotFound) {\n      return false;\n    }\n    if (error instanceof Deno.errors.PermissionDenied) {\n      if (\n        Deno.permissions.querySync({ name: \"read\", path }).state === \"granted\"\n      ) {\n        // --allow-read not missing\n        return !options?.isReadable; // PermissionDenied was raised by file system, so the item exists, but can't be read\n      }\n    }\n    throw error;\n  }\n}\n\nfunction fileIsReadable(stat: Deno.FileInfo) {\n  if (stat.mode === null) {\n    return true; // Exclusive on Non-POSIX systems\n  } else if (Deno.uid() === stat.uid) {\n    return (stat.mode & 0o400) === 0o400; // User is owner and can read?\n  } else if (Deno.gid() === stat.gid) {\n    return (stat.mode & 0o040) === 0o040; // User group is owner and can read?\n  }\n  return (stat.mode & 0o004) === 0o004; // Others can read?\n}\n", "// Copyright 2018-2024 the Deno authors. All rights reserved. MIT license.\n// This module is browser compatible.\n\n/**\n * Options for {@linkcode globToRegExp}, {@linkcode joinGlobs},\n * {@linkcode normalizeGlob} and {@linkcode expandGlob}.\n */\nexport interface GlobOptions {\n  /** Extended glob syntax.\n   * See https://www.linuxjournal.com/content/bash-extended-globbing.\n   *\n   * @default {true}\n   */\n  extended?: boolean;\n  /** Globstar syntax.\n   * See https://www.linuxjournal.com/content/globstar-new-bash-globbing-option.\n   * If false, `**` is treated like `*`.\n   *\n   * @default {true}\n   */\n  globstar?: boolean;\n  /**\n   * Whether globstar should be case-insensitive.\n   *\n   * @default {false}\n   */\n  caseInsensitive?: boolean;\n}\n\nconst REG_EXP_ESCAPE_CHARS = [\n  \"!\",\n  \"$\",\n  \"(\",\n  \")\",\n  \"*\",\n  \"+\",\n  \".\",\n  \"=\",\n  \"?\",\n  \"[\",\n  \"\\\\\",\n  \"^\",\n  \"{\",\n  \"|\",\n] as const;\nconst RANGE_ESCAPE_CHARS = [\"-\", \"\\\\\", \"]\"] as const;\n\ntype RegExpEscapeChar = typeof REG_EXP_ESCAPE_CHARS[number];\ntype RangeEscapeChar = typeof RANGE_ESCAPE_CHARS[number];\ntype EscapeChar = RegExpEscapeChar | RangeEscapeChar;\n\nexport interface GlobConstants {\n  sep: string;\n  sepMaybe: string;\n  seps: string[];\n  globstar: string;\n  wildcard: string;\n  escapePrefix: string;\n}\n\nexport function _globToRegExp(\n  c: GlobConstants,\n  glob: string,\n  {\n    extended = true,\n    globstar: globstarOption = true,\n    // os = osType,\n    caseInsensitive = false,\n  }: GlobOptions = {},\n): RegExp {\n  if (glob === \"\") {\n    return /(?!)/;\n  }\n\n  // Remove trailing separators.\n  let newLength = glob.length;\n  for (; newLength > 1 && c.seps.includes(glob[newLength - 1]!); newLength--);\n  glob = glob.slice(0, newLength);\n\n  let regExpString = \"\";\n\n  // Terminates correctly. Trust that `j` is incremented every iteration.\n  for (let j = 0; j < glob.length;) {\n    let segment = \"\";\n    const groupStack: string[] = [];\n    let inRange = false;\n    let inEscape = false;\n    let endsWithSep = false;\n    let i = j;\n\n    // Terminates with `i` at the non-inclusive end of the current segment.\n    for (; i < glob.length && !c.seps.includes(glob[i]!); i++) {\n      if (inEscape) {\n        inEscape = false;\n        const escapeChars = (inRange\n          ? RANGE_ESCAPE_CHARS\n          : REG_EXP_ESCAPE_CHARS) as unknown as EscapeChar[];\n        segment += escapeChars.includes(glob[i]! as EscapeChar)\n          ? `\\\\${glob[i]}`\n          : glob[i];\n        continue;\n      }\n\n      if (glob[i] === c.escapePrefix) {\n        inEscape = true;\n        continue;\n      }\n\n      if (glob[i] === \"[\") {\n        if (!inRange) {\n          inRange = true;\n          segment += \"[\";\n          if (glob[i + 1] === \"!\") {\n            i++;\n            segment += \"^\";\n          } else if (glob[i + 1] === \"^\") {\n            i++;\n            segment += \"\\\\^\";\n          }\n          continue;\n        } else if (glob[i + 1] === \":\") {\n          let k = i + 1;\n          let value = \"\";\n          while (glob[k + 1] !== undefined && glob[k + 1] !== \":\") {\n            value += glob[k + 1];\n            k++;\n          }\n          if (glob[k + 1] === \":\" && glob[k + 2] === \"]\") {\n            i = k + 2;\n            if (value === \"alnum\") segment += \"\\\\dA-Za-z\";\n            else if (value === \"alpha\") segment += \"A-Za-z\";\n            else if (value === \"ascii\") segment += \"\\x00-\\x7F\";\n            else if (value === \"blank\") segment += \"\\t \";\n            else if (value === \"cntrl\") segment += \"\\x00-\\x1F\\x7F\";\n            else if (value === \"digit\") segment += \"\\\\d\";\n            else if (value === \"graph\") segment += \"\\x21-\\x7E\";\n            else if (value === \"lower\") segment += \"a-z\";\n            else if (value === \"print\") segment += \"\\x20-\\x7E\";\n            else if (value === \"punct\") {\n              segment += \"!\\\"#$%&'()*+,\\\\-./:;<=>?@[\\\\\\\\\\\\]^_\u2018{|}~\";\n            } else if (value === \"space\") segment += \"\\\\s\\v\";\n            else if (value === \"upper\") segment += \"A-Z\";\n            else if (value === \"word\") segment += \"\\\\w\";\n            else if (value === \"xdigit\") segment += \"\\\\dA-Fa-f\";\n            continue;\n          }\n        }\n      }\n\n      if (glob[i] === \"]\" && inRange) {\n        inRange = false;\n        segment += \"]\";\n        continue;\n      }\n\n      if (inRange) {\n        segment += glob[i];\n        continue;\n      }\n\n      if (\n        glob[i] === \")\" && groupStack.length > 0 &&\n        groupStack[groupStack.length - 1] !== \"BRACE\"\n      ) {\n        segment += \")\";\n        const type = groupStack.pop()!;\n        if (type === \"!\") {\n          segment += c.wildcard;\n        } else if (type !== \"@\") {\n          segment += type;\n        }\n        continue;\n      }\n\n      if (\n        glob[i] === \"|\" && groupStack.length > 0 &&\n        groupStack[groupStack.length - 1] !== \"BRACE\"\n      ) {\n        segment += \"|\";\n        continue;\n      }\n\n      if (glob[i] === \"+\" && extended && glob[i + 1] === \"(\") {\n        i++;\n        groupStack.push(\"+\");\n        segment += \"(?:\";\n        continue;\n      }\n\n      if (glob[i] === \"@\" && extended && glob[i + 1] === \"(\") {\n        i++;\n        groupStack.push(\"@\");\n        segment += \"(?:\";\n        continue;\n      }\n\n      if (glob[i] === \"?\") {\n        if (extended && glob[i + 1] === \"(\") {\n          i++;\n          groupStack.push(\"?\");\n          segment += \"(?:\";\n        } else {\n          segment += \".\";\n        }\n        continue;\n      }\n\n      if (glob[i] === \"!\" && extended && glob[i + 1] === \"(\") {\n        i++;\n        groupStack.push(\"!\");\n        segment += \"(?!\";\n        continue;\n      }\n\n      if (glob[i] === \"{\") {\n        groupStack.push(\"BRACE\");\n        segment += \"(?:\";\n        continue;\n      }\n\n      if (glob[i] === \"}\" && groupStack[groupStack.length - 1] === \"BRACE\") {\n        groupStack.pop();\n        segment += \")\";\n        continue;\n      }\n\n      if (glob[i] === \",\" && groupStack[groupStack.length - 1] === \"BRACE\") {\n        segment += \"|\";\n        continue;\n      }\n\n      if (glob[i] === \"*\") {\n        if (extended && glob[i + 1] === \"(\") {\n          i++;\n          groupStack.push(\"*\");\n          segment += \"(?:\";\n        } else {\n          const prevChar = glob[i - 1];\n          let numStars = 1;\n          while (glob[i + 1] === \"*\") {\n            i++;\n            numStars++;\n          }\n          const nextChar = glob[i + 1];\n          if (\n            globstarOption && numStars === 2 &&\n            [...c.seps, undefined].includes(prevChar) &&\n            [...c.seps, undefined].includes(nextChar)\n          ) {\n            segment += c.globstar;\n            endsWithSep = true;\n          } else {\n            segment += c.wildcard;\n          }\n        }\n        continue;\n      }\n\n      segment += REG_EXP_ESCAPE_CHARS.includes(glob[i]! as RegExpEscapeChar)\n        ? `\\\\${glob[i]}`\n        : glob[i];\n    }\n\n    // Check for unclosed groups or a dangling backslash.\n    if (groupStack.length > 0 || inRange || inEscape) {\n      // Parse failure. Take all characters from this segment literally.\n      segment = \"\";\n      for (const c of glob.slice(j, i)) {\n        segment += REG_EXP_ESCAPE_CHARS.includes(c as RegExpEscapeChar)\n          ? `\\\\${c}`\n          : c;\n        endsWithSep = false;\n      }\n    }\n\n    regExpString += segment;\n    if (!endsWithSep) {\n      regExpString += i < glob.length ? c.sep : c.sepMaybe;\n      endsWithSep = true;\n    }\n\n    // Terminates with `i` at the start of the next segment.\n    while (c.seps.includes(glob[i]!)) i++;\n\n    j = i;\n  }\n\n  regExpString = `^${regExpString}$`;\n  return new RegExp(regExpString, caseInsensitive ? \"i\" : \"\");\n}\n", "// Copyright 2018-2024 the Deno authors. All rights reserved. MIT license.\n// This module is browser compatible.\n\nimport {\n  _globToRegExp,\n  type GlobConstants,\n  type GlobOptions,\n} from \"../_common/glob_to_reg_exp.ts\";\n\nexport type { GlobOptions };\n\nconst constants: GlobConstants = {\n  sep: \"/+\",\n  sepMaybe: \"/*\",\n  seps: [\"/\"],\n  globstar: \"(?:[^/]*(?:/|$)+)*\",\n  wildcard: \"[^/]*\",\n  escapePrefix: \"\\\\\",\n};\n\n/** Convert a glob string to a regular expression.\n *\n * Tries to match bash glob expansion as closely as possible.\n *\n * Basic glob syntax:\n * - `*` - Matches everything without leaving the path segment.\n * - `?` - Matches any single character.\n * - `{foo,bar}` - Matches `foo` or `bar`.\n * - `[abcd]` - Matches `a`, `b`, `c` or `d`.\n * - `[a-d]` - Matches `a`, `b`, `c` or `d`.\n * - `[!abcd]` - Matches any single character besides `a`, `b`, `c` or `d`.\n * - `[[:<class>:]]` - Matches any character belonging to `<class>`.\n *     - `[[:alnum:]]` - Matches any digit or letter.\n *     - `[[:digit:]abc]` - Matches any digit, `a`, `b` or `c`.\n *     - See https://facelessuser.github.io/wcmatch/glob/#posix-character-classes\n *       for a complete list of supported character classes.\n * - `\\` - Escapes the next character for an `os` other than `\"windows\"`.\n * - \\` - Escapes the next character for `os` set to `\"windows\"`.\n * - `/` - Path separator.\n * - `\\` - Additional path separator only for `os` set to `\"windows\"`.\n *\n * Extended syntax:\n * - Requires `{ extended: true }`.\n * - `?(foo|bar)` - Matches 0 or 1 instance of `{foo,bar}`.\n * - `@(foo|bar)` - Matches 1 instance of `{foo,bar}`. They behave the same.\n * - `*(foo|bar)` - Matches _n_ instances of `{foo,bar}`.\n * - `+(foo|bar)` - Matches _n > 0_ instances of `{foo,bar}`.\n * - `!(foo|bar)` - Matches anything other than `{foo,bar}`.\n * - See https://www.linuxjournal.com/content/bash-extended-globbing.\n *\n * Globstar syntax:\n * - Requires `{ globstar: true }`.\n * - `**` - Matches any number of any path segments.\n *     - Must comprise its entire path segment in the provided glob.\n * - See https://www.linuxjournal.com/content/globstar-new-bash-globbing-option.\n *\n * Note the following properties:\n * - The generated `RegExp` is anchored at both start and end.\n * - Repeating and trailing separators are tolerated. Trailing separators in the\n *   provided glob have no meaning and are discarded.\n * - Absolute globs will only match absolute paths, etc.\n * - Empty globs will match nothing.\n * - Any special glob syntax must be contained to one path segment. For example,\n *   `?(foo|bar/baz)` is invalid. The separator will take precedence and the\n *   first segment ends with an unclosed group.\n * - If a path segment ends with unclosed groups or a dangling escape prefix, a\n *   parse error has occurred. Every character for that segment is taken\n *   literally in this event.\n *\n * Limitations:\n * - A negative group like `!(foo|bar)` will wrongly be converted to a negative\n *   look-ahead followed by a wildcard. This means that `!(foo).js` will wrongly\n *   fail to match `foobar.js`, even though `foobar` is not `foo`. Effectively,\n *   `!(foo|bar)` is treated like `!(@(foo|bar)*)`. This will work correctly if\n *   the group occurs not nested at the end of the segment.\n *\n * @example Usage\n * ```ts\n * import { globToRegExp } from \"@std/path/posix/glob-to-regexp\";\n * import { assertEquals } from \"@std/assert\";\n *\n * assertEquals(globToRegExp(\"*.js\"), /^[^/]*\\.js\\/*$/);\n * ```\n *\n * @param glob Glob string to convert.\n * @param options Conversion options.\n * @returns The regular expression equivalent to the glob.\n */\nexport function globToRegExp(\n  glob: string,\n  options: GlobOptions = {},\n): RegExp {\n  return _globToRegExp(constants, glob, options);\n}\n", "// Copyright 2018-2024 the Deno authors. All rights reserved. MIT license.\n// This module is browser compatible.\n\nimport {\n  _globToRegExp,\n  type GlobConstants,\n  type GlobOptions,\n} from \"../_common/glob_to_reg_exp.ts\";\n\nconst constants: GlobConstants = {\n  sep: \"(?:\\\\\\\\|/)+\",\n  sepMaybe: \"(?:\\\\\\\\|/)*\",\n  seps: [\"\\\\\", \"/\"],\n  globstar: \"(?:[^\\\\\\\\/]*(?:\\\\\\\\|/|$)+)*\",\n  wildcard: \"[^\\\\\\\\/]*\",\n  escapePrefix: \"`\",\n};\n\n/** Convert a glob string to a regular expression.\n *\n * Tries to match bash glob expansion as closely as possible.\n *\n * Basic glob syntax:\n * - `*` - Matches everything without leaving the path segment.\n * - `?` - Matches any single character.\n * - `{foo,bar}` - Matches `foo` or `bar`.\n * - `[abcd]` - Matches `a`, `b`, `c` or `d`.\n * - `[a-d]` - Matches `a`, `b`, `c` or `d`.\n * - `[!abcd]` - Matches any single character besides `a`, `b`, `c` or `d`.\n * - `[[:<class>:]]` - Matches any character belonging to `<class>`.\n *     - `[[:alnum:]]` - Matches any digit or letter.\n *     - `[[:digit:]abc]` - Matches any digit, `a`, `b` or `c`.\n *     - See https://facelessuser.github.io/wcmatch/glob/#posix-character-classes\n *       for a complete list of supported character classes.\n * - `\\` - Escapes the next character for an `os` other than `\"windows\"`.\n * - \\` - Escapes the next character for `os` set to `\"windows\"`.\n * - `/` - Path separator.\n * - `\\` - Additional path separator only for `os` set to `\"windows\"`.\n *\n * Extended syntax:\n * - Requires `{ extended: true }`.\n * - `?(foo|bar)` - Matches 0 or 1 instance of `{foo,bar}`.\n * - `@(foo|bar)` - Matches 1 instance of `{foo,bar}`. They behave the same.\n * - `*(foo|bar)` - Matches _n_ instances of `{foo,bar}`.\n * - `+(foo|bar)` - Matches _n > 0_ instances of `{foo,bar}`.\n * - `!(foo|bar)` - Matches anything other than `{foo,bar}`.\n * - See https://www.linuxjournal.com/content/bash-extended-globbing.\n *\n * Globstar syntax:\n * - Requires `{ globstar: true }`.\n * - `**` - Matches any number of any path segments.\n *     - Must comprise its entire path segment in the provided glob.\n * - See https://www.linuxjournal.com/content/globstar-new-bash-globbing-option.\n *\n * Note the following properties:\n * - The generated `RegExp` is anchored at both start and end.\n * - Repeating and trailing separators are tolerated. Trailing separators in the\n *   provided glob have no meaning and are discarded.\n * - Absolute globs will only match absolute paths, etc.\n * - Empty globs will match nothing.\n * - Any special glob syntax must be contained to one path segment. For example,\n *   `?(foo|bar/baz)` is invalid. The separator will take precedence and the\n *   first segment ends with an unclosed group.\n * - If a path segment ends with unclosed groups or a dangling escape prefix, a\n *   parse error has occurred. Every character for that segment is taken\n *   literally in this event.\n *\n * Limitations:\n * - A negative group like `!(foo|bar)` will wrongly be converted to a negative\n *   look-ahead followed by a wildcard. This means that `!(foo).js` will wrongly\n *   fail to match `foobar.js`, even though `foobar` is not `foo`. Effectively,\n *   `!(foo|bar)` is treated like `!(@(foo|bar)*)`. This will work correctly if\n *   the group occurs not nested at the end of the segment.\n *\n * @example Usage\n * ```ts\n * import { globToRegExp } from \"@std/path/windows/glob-to-regexp\";\n * import { assertEquals } from \"@std/assert\";\n *\n * assertEquals(globToRegExp(\"*.js\"), /^[^\\\\/]*\\.js(?:\\\\|\\/)*$/);\n * ```\n *\n * @param glob Glob string to convert.\n * @param options Conversion options.\n * @returns The regular expression equivalent to the glob.\n */\nexport function globToRegExp(\n  glob: string,\n  options: GlobOptions = {},\n): RegExp {\n  return _globToRegExp(constants, glob, options);\n}\n", "// Copyright 2018-2024 the Deno authors. All rights reserved. MIT license.\n// This module is browser compatible.\n\nimport type { GlobOptions } from \"./_common/glob_to_reg_exp.ts\";\nimport { isWindows } from \"./_os.ts\";\n\nimport { globToRegExp as posixGlobToRegExp } from \"./posix/glob_to_regexp.ts\";\nimport {\n  globToRegExp as windowsGlobToRegExp,\n} from \"./windows/glob_to_regexp.ts\";\n\nexport type { GlobOptions };\n\n/**\n * Converts a glob string to a regular expression.\n *\n * Tries to match bash glob expansion as closely as possible.\n *\n * Basic glob syntax:\n * - `*` - Matches everything without leaving the path segment.\n * - `?` - Matches any single character.\n * - `{foo,bar}` - Matches `foo` or `bar`.\n * - `[abcd]` - Matches `a`, `b`, `c` or `d`.\n * - `[a-d]` - Matches `a`, `b`, `c` or `d`.\n * - `[!abcd]` - Matches any single character besides `a`, `b`, `c` or `d`.\n * - `[[:<class>:]]` - Matches any character belonging to `<class>`.\n *     - `[[:alnum:]]` - Matches any digit or letter.\n *     - `[[:digit:]abc]` - Matches any digit, `a`, `b` or `c`.\n *     - See https://facelessuser.github.io/wcmatch/glob/#posix-character-classes\n *       for a complete list of supported character classes.\n * - `\\` - Escapes the next character for an `os` other than `\"windows\"`.\n * - \\` - Escapes the next character for `os` set to `\"windows\"`.\n * - `/` - Path separator.\n * - `\\` - Additional path separator only for `os` set to `\"windows\"`.\n *\n * Extended syntax:\n * - Requires `{ extended: true }`.\n * - `?(foo|bar)` - Matches 0 or 1 instance of `{foo,bar}`.\n * - `@(foo|bar)` - Matches 1 instance of `{foo,bar}`. They behave the same.\n * - `*(foo|bar)` - Matches _n_ instances of `{foo,bar}`.\n * - `+(foo|bar)` - Matches _n > 0_ instances of `{foo,bar}`.\n * - `!(foo|bar)` - Matches anything other than `{foo,bar}`.\n * - See https://www.linuxjournal.com/content/bash-extended-globbing.\n *\n * Globstar syntax:\n * - Requires `{ globstar: true }`.\n * - `**` - Matches any number of any path segments.\n *     - Must comprise its entire path segment in the provided glob.\n * - See https://www.linuxjournal.com/content/globstar-new-bash-globbing-option.\n *\n * Note the following properties:\n * - The generated `RegExp` is anchored at both start and end.\n * - Repeating and trailing separators are tolerated. Trailing separators in the\n *   provided glob have no meaning and are discarded.\n * - Absolute globs will only match absolute paths, etc.\n * - Empty globs will match nothing.\n * - Any special glob syntax must be contained to one path segment. For example,\n *   `?(foo|bar/baz)` is invalid. The separator will take precedence and the\n *   first segment ends with an unclosed group.\n * - If a path segment ends with unclosed groups or a dangling escape prefix, a\n *   parse error has occurred. Every character for that segment is taken\n *   literally in this event.\n *\n * Limitations:\n * - A negative group like `!(foo|bar)` will wrongly be converted to a negative\n *   look-ahead followed by a wildcard. This means that `!(foo).js` will wrongly\n *   fail to match `foobar.js`, even though `foobar` is not `foo`. Effectively,\n *   `!(foo|bar)` is treated like `!(@(foo|bar)*)`. This will work correctly if\n *   the group occurs not nested at the end of the segment.\n *\n * @example Usage\n * ```ts\n * import { globToRegExp } from \"@std/path/glob-to-regexp\";\n * import { assertEquals } from \"@std/assert\";\n *\n * if (Deno.build.os === \"windows\") {\n *   assertEquals(globToRegExp(\"*.js\"), /^[^\\\\/]*\\.js(?:\\\\|\\/)*$/);\n * } else {\n *   assertEquals(globToRegExp(\"*.js\"), /^[^/]*\\.js\\/*$/);\n * }\n * ```\n *\n * @param glob Glob string to convert.\n * @param options Conversion options.\n * @returns The regular expression equivalent to the glob.\n */\nexport function globToRegExp(\n  glob: string,\n  options: GlobOptions = {},\n): RegExp {\n  return isWindows\n    ? windowsGlobToRegExp(glob, options)\n    : posixGlobToRegExp(glob, options);\n}\n", "// Copyright 2018-2024 the Deno authors. All rights reserved. MIT license.\n// This module is browser compatible.\n\n/**\n * The character used to separate entries in the PATH environment variable.\n */\nexport const DELIMITER = \":\" as const;\n/**\n * The character used to separate components of a file path.\n */\nexport const SEPARATOR = \"/\" as const;\n/**\n * A regular expression that matches one or more path separators.\n */\nexport const SEPARATOR_PATTERN = /\\/+/;\n", "// Copyright 2018-2024 the Deno authors. All rights reserved. MIT license.\n// This module is browser compatible.\n\nimport type { GlobOptions } from \"../_common/glob_to_reg_exp.ts\";\nimport { normalize } from \"./normalize.ts\";\nimport { SEPARATOR_PATTERN } from \"./constants.ts\";\n\nexport type { GlobOptions };\n\n/**\n * Like normalize(), but doesn't collapse \"**\\/..\" when `globstar` is true.\n *\n * @example Usage\n * ```ts\n * import { normalizeGlob } from \"@std/path/posix/normalize-glob\";\n * import { assertEquals } from \"@std/assert\";\n *\n * const path = normalizeGlob(\"foo/bar/../*\", { globstar: true });\n * assertEquals(path, \"foo/*\");\n * ```\n *\n * @param glob The glob to normalize.\n * @param options The options to use.\n * @returns The normalized path.\n */\nexport function normalizeGlob(\n  glob: string,\n  options: Pick<GlobOptions, \"globstar\"> = {},\n): string {\n  const { globstar = false }: GlobOptions = options;\n  if (glob.match(/\\0/g)) {\n    throw new Error(`Glob contains invalid characters: \"${glob}\"`);\n  }\n  if (!globstar) {\n    return normalize(glob);\n  }\n  const s = SEPARATOR_PATTERN.source;\n  const badParentPattern = new RegExp(\n    `(?<=(${s}|^)\\\\*\\\\*${s})\\\\.\\\\.(?=${s}|$)`,\n    \"g\",\n  );\n  return normalize(glob.replace(badParentPattern, \"\\0\")).replace(/\\0/g, \"..\");\n}\n", "// Copyright 2018-2024 the Deno authors. All rights reserved. MIT license.\n// This module is browser compatible.\n\nimport type { GlobOptions } from \"../_common/glob_to_reg_exp.ts\";\nimport { join } from \"./join.ts\";\nimport { SEPARATOR } from \"./constants.ts\";\nimport { normalizeGlob } from \"./normalize_glob.ts\";\n\nexport type { GlobOptions };\n\n/**\n * Like join(), but doesn't collapse \"**\\/..\" when `globstar` is true.\n *\n * @example Usage\n * ```ts\n * import { joinGlobs } from \"@std/path/posix/join-globs\";\n * import { assertEquals } from \"@std/assert\";\n *\n * const path = joinGlobs([\"foo\", \"bar\", \"**\"], { globstar: true });\n * assertEquals(path, \"foo/bar/**\");\n * ```\n *\n * @param globs The globs to join.\n * @param options The options to use.\n * @returns The joined path.\n */\nexport function joinGlobs(\n  globs: string[],\n  options: Pick<GlobOptions, \"globstar\"> = {},\n): string {\n  const { globstar = false } = options;\n  if (!globstar || globs.length === 0) {\n    return join(...globs);\n  }\n  let joined: string | undefined;\n  for (const glob of globs) {\n    const path = glob;\n    if (path.length > 0) {\n      if (!joined) joined = path;\n      else joined += `${SEPARATOR}${path}`;\n    }\n  }\n  if (!joined) return \".\";\n  return normalizeGlob(joined, { globstar });\n}\n", "// Copyright 2018-2024 the Deno authors. All rights reserved. MIT license.\n// This module is browser compatible.\n\n/**\n * The character used to separate entries in the PATH environment variable.\n */\nexport const DELIMITER = \";\" as const;\n/**\n * The character used to separate components of a file path.\n */\nexport const SEPARATOR = \"\\\\\" as const;\n/**\n * A regular expression that matches one or more path separators.\n */\nexport const SEPARATOR_PATTERN = /[\\\\/]+/;\n", "// Copyright 2018-2024 the Deno authors. All rights reserved. MIT license.\n// This module is browser compatible.\n\nimport type { GlobOptions } from \"../_common/glob_to_reg_exp.ts\";\nimport { normalize } from \"./normalize.ts\";\nimport { SEPARATOR_PATTERN } from \"./constants.ts\";\n\nexport type { GlobOptions };\n\n/**\n * Like normalize(), but doesn't collapse \"**\\/..\" when `globstar` is true.\n *\n * @example Usage\n * ```ts\n * import { normalizeGlob } from \"@std/path/windows/normalize-glob\";\n * import { assertEquals } from \"@std/assert\";\n *\n * const normalized = normalizeGlob(\"**\\\\foo\\\\..\\\\bar\", { globstar: true });\n * assertEquals(normalized, \"**\\\\bar\");\n * ```\n *\n * @param glob The glob pattern to normalize.\n * @param options The options for glob pattern.\n * @returns The normalized glob pattern.\n */\nexport function normalizeGlob(\n  glob: string,\n  options: Pick<GlobOptions, \"globstar\"> = {},\n): string {\n  const { globstar = false }: GlobOptions = options;\n  if (glob.match(/\\0/g)) {\n    throw new Error(`Glob contains invalid characters: \"${glob}\"`);\n  }\n  if (!globstar) {\n    return normalize(glob);\n  }\n  const s = SEPARATOR_PATTERN.source;\n  const badParentPattern = new RegExp(\n    `(?<=(${s}|^)\\\\*\\\\*${s})\\\\.\\\\.(?=${s}|$)`,\n    \"g\",\n  );\n  return normalize(glob.replace(badParentPattern, \"\\0\")).replace(/\\0/g, \"..\");\n}\n", "// Copyright 2018-2024 the Deno authors. All rights reserved. MIT license.\n// This module is browser compatible.\n\nimport type { GlobOptions } from \"../_common/glob_to_reg_exp.ts\";\nimport { join } from \"./join.ts\";\nimport { SEPARATOR } from \"./constants.ts\";\nimport { normalizeGlob } from \"./normalize_glob.ts\";\n\nexport type { GlobOptions };\n\n/**\n * Like join(), but doesn't collapse \"**\\/..\" when `globstar` is true.\n *\n * @example Usage\n *\n * ```ts\n * import { joinGlobs } from \"@std/path/windows/join-globs\";\n * import { assertEquals } from \"@std/assert\";\n *\n * const joined = joinGlobs([\"foo\", \"**\", \"bar\"], { globstar: true });\n * assertEquals(joined, \"foo\\\\**\\\\bar\");\n * ```\n *\n * @param globs The globs to join.\n * @param options The options for glob pattern.\n * @returns The joined glob pattern.\n */\nexport function joinGlobs(\n  globs: string[],\n  options: Pick<GlobOptions, \"globstar\"> = {},\n): string {\n  const { globstar = false } = options;\n  if (!globstar || globs.length === 0) {\n    return join(...globs);\n  }\n  let joined: string | undefined;\n  for (const glob of globs) {\n    const path = glob;\n    if (path.length > 0) {\n      if (!joined) joined = path;\n      else joined += `${SEPARATOR}${path}`;\n    }\n  }\n  if (!joined) return \".\";\n  return normalizeGlob(joined, { globstar });\n}\n", "// Copyright 2018-2024 the Deno authors. All rights reserved. MIT license.\n// This module is browser compatible.\n\nimport type { GlobOptions } from \"./_common/glob_to_reg_exp.ts\";\nimport { isWindows } from \"./_os.ts\";\nimport { joinGlobs as posixJoinGlobs } from \"./posix/join_globs.ts\";\nimport { joinGlobs as windowsJoinGlobs } from \"./windows/join_globs.ts\";\n\nexport type { GlobOptions };\n\n/**\n * Joins a sequence of globs, then normalizes the resulting glob.\n *\n * Behaves like {@linkcode https://jsr.io/@std/path/doc/~/join | join()}, but\n * doesn't collapse `**\\/..` when `globstar` is true.\n *\n * @example Usage\n * ```ts\n * import { joinGlobs } from \"@std/path/join-globs\";\n * import { assertEquals } from \"@std/assert\";\n *\n * if (Deno.build.os === \"windows\") {\n *   assertEquals(joinGlobs([\"foo\", \"bar\", \"..\", \"baz\"]), \"foo\\\\baz\");\n *   assertEquals(joinGlobs([\"foo\", \"**\", \"bar\", \"..\", \"baz\"], { globstar: true }), \"foo\\\\**\\\\baz\");\n * } else {\n *   assertEquals(joinGlobs([\"foo\", \"bar\", \"..\", \"baz\"]), \"foo/baz\");\n *   assertEquals(joinGlobs([\"foo\", \"**\", \"bar\", \"..\", \"baz\"], { globstar: true }), \"foo/**\\/baz\");\n * }\n * ```\n *\n * @param globs Globs to be joined and normalized.\n * @param options Glob options.\n * @returns The joined and normalized glob string.\n */\nexport function joinGlobs(\n  globs: string[],\n  options: GlobOptions = {},\n): string {\n  return isWindows\n    ? windowsJoinGlobs(globs, options)\n    : posixJoinGlobs(globs, options);\n}\n", "// Copyright 2018-2024 the Deno authors. All rights reserved. MIT license.\n// This module is browser compatible.\n\n/**\n * Test whether the given string is a glob.\n *\n * @example Usage\n * ```ts\n * import { isGlob } from \"@std/path/is-glob\";\n * import { assert } from \"@std/assert\";\n *\n * assert(!isGlob(\"foo/bar/../baz\"));\n * assert(isGlob(\"foo/*ar/../baz\"));\n * ```\n *\n * @param str String to test.\n * @returns `true` if the given string is a glob, otherwise `false`\n */\nexport function isGlob(str: string): boolean {\n  const chars: Record<string, string> = { \"{\": \"}\", \"(\": \")\", \"[\": \"]\" };\n  const regex =\n    /\\\\(.)|(^!|\\*|\\?|[\\].+)]\\?|\\[[^\\\\\\]]+\\]|\\{[^\\\\}]+\\}|\\(\\?[:!=][^\\\\)]+\\)|\\([^|]+\\|[^\\\\)]+\\))/;\n\n  if (str === \"\") {\n    return false;\n  }\n\n  let match: RegExpExecArray | null;\n\n  while ((match = regex.exec(str))) {\n    if (match[2]) return true;\n    let idx = match.index + match[0].length;\n\n    // if an open bracket/brace/paren is escaped,\n    // set the index to the next closing character\n    const open = match[1];\n    const close = open ? chars[open] : null;\n    if (open && close) {\n      const n = str.indexOf(close, idx);\n      if (n !== -1) {\n        idx = n + 1;\n      }\n    }\n\n    str = str.slice(idx);\n  }\n\n  return false;\n}\n", "// Copyright 2018-2024 the Deno authors. All rights reserved. MIT license.\n// This module is browser compatible.\n\nimport { assertPath } from \"../_common/assert_path.ts\";\nimport { isPosixPathSeparator } from \"./_util.ts\";\n\n/**\n * Verifies whether provided path is absolute.\n *\n * @example Usage\n * ```ts\n * import { isAbsolute } from \"@std/path/posix/is-absolute\";\n * import { assert, assertFalse } from \"@std/assert\";\n *\n * assert(isAbsolute(\"/home/user/Documents/\"));\n * assertFalse(isAbsolute(\"home/user/Documents/\"));\n * ```\n *\n * @param path The path to verify.\n * @returns Whether the path is absolute.\n */\nexport function isAbsolute(path: string): boolean {\n  assertPath(path);\n  return path.length > 0 && isPosixPathSeparator(path.charCodeAt(0));\n}\n", "// Copyright 2018-2024 the Deno authors. All rights reserved. MIT license.\n// This module is browser compatible.\n\nimport { CHAR_COLON } from \"../_common/constants.ts\";\nimport { assertPath } from \"../_common/assert_path.ts\";\nimport { isPathSeparator, isWindowsDeviceRoot } from \"./_util.ts\";\n\n/**\n * Verifies whether provided path is absolute.\n *\n * @example Usage\n * ```ts\n * import { isAbsolute } from \"@std/path/windows/is-absolute\";\n * import { assert, assertFalse } from \"@std/assert\";\n *\n * assert(isAbsolute(\"C:\\\\foo\\\\bar\"));\n * assertFalse(isAbsolute(\"..\\\\baz\"));\n * ```\n *\n * @param path The path to verify.\n * @returns `true` if the path is absolute, `false` otherwise.\n */\nexport function isAbsolute(path: string): boolean {\n  assertPath(path);\n\n  const len = path.length;\n  if (len === 0) return false;\n\n  const code = path.charCodeAt(0);\n  if (isPathSeparator(code)) {\n    return true;\n  } else if (isWindowsDeviceRoot(code)) {\n    // Possible device root\n\n    if (len > 2 && path.charCodeAt(1) === CHAR_COLON) {\n      if (isPathSeparator(path.charCodeAt(2))) return true;\n    }\n  }\n  return false;\n}\n", "// Copyright 2018-2024 the Deno authors. All rights reserved. MIT license.\n// This module is browser compatible.\n\nimport { isWindows } from \"./_os.ts\";\nimport { isAbsolute as posixIsAbsolute } from \"./posix/is_absolute.ts\";\nimport { isAbsolute as windowsIsAbsolute } from \"./windows/is_absolute.ts\";\n\n/**\n * Verifies whether provided path is absolute.\n *\n * @example Usage\n * ```ts\n * import { isAbsolute } from \"@std/path/is-absolute\";\n * import { assert, assertFalse } from \"@std/assert\";\n *\n * if (Deno.build.os === \"windows\") {\n *   assert(isAbsolute(\"C:\\\\home\\\\foo\"));\n *   assertFalse(isAbsolute(\"home\\\\foo\"));\n * } else {\n *   assert(isAbsolute(\"/home/foo\"));\n *   assertFalse(isAbsolute(\"home/foo\"));\n * }\n * ```\n *\n * @param path Path to be verified as absolute.\n * @returns `true` if path is absolute, `false` otherwise\n */\nexport function isAbsolute(path: string): boolean {\n  return isWindows ? windowsIsAbsolute(path) : posixIsAbsolute(path);\n}\n", "// Copyright 2018-2024 the Deno authors. All rights reserved. MIT license.\n// This module is browser compatible.\nimport { isWindows } from \"./_os.ts\";\n\n/**\n * The character used to separate entries in the PATH environment variable.\n * On Windows, this is `;`. On all other platforms, this is `:`.\n */\nexport const DELIMITER = isWindows ? \";\" as const : \":\" as const;\n/**\n * The character used to separate components of a file path.\n * On Windows, this is `\\`. On all other platforms, this is `/`.\n */\nexport const SEPARATOR = isWindows ? \"\\\\\" as const : \"/\" as const;\n/**\n * A regular expression that matches one or more path separators.\n */\nexport const SEPARATOR_PATTERN = isWindows ? /[\\\\/]+/ : /\\/+/;\n", "// Copyright 2018-2024 the Deno authors. All rights reserved. MIT license.\n// This module is browser compatible.\n\nimport { assertPath } from \"./assert_path.ts\";\n\nexport function stripSuffix(name: string, suffix: string): string {\n  if (suffix.length >= name.length) {\n    return name;\n  }\n\n  const lenDiff = name.length - suffix.length;\n\n  for (let i = suffix.length - 1; i >= 0; --i) {\n    if (name.charCodeAt(lenDiff + i) !== suffix.charCodeAt(i)) {\n      return name;\n    }\n  }\n\n  return name.slice(0, -suffix.length);\n}\n\nexport function lastPathSegment(\n  path: string,\n  isSep: (char: number) => boolean,\n  start = 0,\n): string {\n  let matchedNonSeparator = false;\n  let end = path.length;\n\n  for (let i = path.length - 1; i >= start; --i) {\n    if (isSep(path.charCodeAt(i))) {\n      if (matchedNonSeparator) {\n        start = i + 1;\n        break;\n      }\n    } else if (!matchedNonSeparator) {\n      matchedNonSeparator = true;\n      end = i + 1;\n    }\n  }\n\n  return path.slice(start, end);\n}\n\nexport function assertArgs(path: string, suffix: string) {\n  assertPath(path);\n  if (path.length === 0) return path;\n  if (typeof suffix !== \"string\") {\n    throw new TypeError(\n      `Suffix must be a string, received \"${JSON.stringify(suffix)}\"`,\n    );\n  }\n}\n", "// Copyright 2018-2024 the Deno authors. All rights reserved. MIT license.\n// This module is browser compatible.\n\nimport {\n  assertArgs,\n  lastPathSegment,\n  stripSuffix,\n} from \"../_common/basename.ts\";\nimport { stripTrailingSeparators } from \"../_common/strip_trailing_separators.ts\";\nimport { isPosixPathSeparator } from \"./_util.ts\";\n\n/**\n * Return the last portion of a `path`.\n * Trailing directory separators are ignored, and optional suffix is removed.\n *\n * @example Usage\n * ```ts\n * import { basename } from \"@std/path/posix/basename\";\n * import { assertEquals } from \"@std/assert\";\n *\n * assertEquals(basename(\"/home/user/Documents/\"), \"Documents\");\n * assertEquals(basename(\"/home/user/Documents/image.png\"), \"image.png\");\n * assertEquals(basename(\"/home/user/Documents/image.png\", \".png\"), \"image\");\n * ```\n *\n * @example Working with URLs\n *\n * Note: This function doesn't automatically strip hash and query parts from\n * URLs. If your URL contains a hash or query, remove them before passing the\n * URL to the function. This can be done by passing the URL to `new URL(url)`,\n * and setting the `hash` and `search` properties to empty strings.\n *\n * ```ts\n * import { basename } from \"@std/path/posix/basename\";\n * import { assertEquals } from \"@std/assert\";\n *\n * assertEquals(basename(\"https://deno.land/std/path/mod.ts\"), \"mod.ts\");\n * assertEquals(basename(\"https://deno.land/std/path/mod.ts\", \".ts\"), \"mod\");\n * assertEquals(basename(\"https://deno.land/std/path/mod.ts?a=b\"), \"mod.ts?a=b\");\n * assertEquals(basename(\"https://deno.land/std/path/mod.ts#header\"), \"mod.ts#header\");\n * ```\n *\n * Note: If you are working with file URLs,\n * use the new version of `basename` from `@std/path/posix/unstable-basename`.\n *\n * @param path The path to extract the name from.\n * @param suffix The suffix to remove from extracted name.\n * @returns The extracted name.\n */\nexport function basename(path: string, suffix = \"\"): string {\n  assertArgs(path, suffix);\n\n  const lastSegment = lastPathSegment(path, isPosixPathSeparator);\n  const strippedSegment = stripTrailingSeparators(\n    lastSegment,\n    isPosixPathSeparator,\n  );\n  return suffix ? stripSuffix(strippedSegment, suffix) : strippedSegment;\n}\n", "// Copyright 2018-2024 the Deno authors. All rights reserved. MIT license.\n// This module is browser compatible.\n\nimport {\n  assertArgs,\n  lastPathSegment,\n  stripSuffix,\n} from \"../_common/basename.ts\";\nimport { CHAR_COLON } from \"../_common/constants.ts\";\nimport { stripTrailingSeparators } from \"../_common/strip_trailing_separators.ts\";\nimport { isPathSeparator, isWindowsDeviceRoot } from \"./_util.ts\";\n\n/**\n * Return the last portion of a `path`.\n * Trailing directory separators are ignored, and optional suffix is removed.\n *\n * @example Usage\n * ```ts\n * import { basename } from \"@std/path/windows/basename\";\n * import { assertEquals } from \"@std/assert\";\n *\n * assertEquals(basename(\"C:\\\\user\\\\Documents\\\\\"), \"Documents\");\n * assertEquals(basename(\"C:\\\\user\\\\Documents\\\\image.png\"), \"image.png\");\n * assertEquals(basename(\"C:\\\\user\\\\Documents\\\\image.png\", \".png\"), \"image\");\n * ```\n *\n * Note: If you are working with file URLs,\n * use the new version of `basename` from `@std/path/windows/unstable-basename`.\n *\n * @param path The path to extract the name from.\n * @param suffix The suffix to remove from extracted name.\n * @returns The extracted name.\n */\nexport function basename(path: string, suffix = \"\"): string {\n  assertArgs(path, suffix);\n\n  // Check for a drive letter prefix so as not to mistake the following\n  // path separator as an extra separator at the end of the path that can be\n  // disregarded\n  let start = 0;\n  if (path.length >= 2) {\n    const drive = path.charCodeAt(0);\n    if (isWindowsDeviceRoot(drive)) {\n      if (path.charCodeAt(1) === CHAR_COLON) start = 2;\n    }\n  }\n\n  const lastSegment = lastPathSegment(path, isPathSeparator, start);\n  const strippedSegment = stripTrailingSeparators(lastSegment, isPathSeparator);\n  return suffix ? stripSuffix(strippedSegment, suffix) : strippedSegment;\n}\n", "// Copyright 2018-2024 the Deno authors. All rights reserved. MIT license.\n// This module is browser compatible.\n\nimport { isWindows } from \"./_os.ts\";\nimport { basename as posixBasename } from \"./posix/basename.ts\";\nimport { basename as windowsBasename } from \"./windows/basename.ts\";\n\n/**\n * Return the last portion of a path.\n *\n * The trailing directory separators are ignored, and optional suffix is\n * removed.\n *\n * @example Usage\n * ```ts\n * import { basename } from \"@std/path/basename\";\n * import { assertEquals } from \"@std/assert\";\n *\n * if (Deno.build.os === \"windows\") {\n *   assertEquals(basename(\"C:\\\\user\\\\Documents\\\\image.png\"), \"image.png\");\n * } else {\n *   assertEquals(basename(\"/home/user/Documents/image.png\"), \"image.png\");\n * }\n * ```\n *\n * Note: If you are working with file URLs,\n * use the new version of `basename` from `@std/path/unstable-basename`.\n *\n * @param path Path to extract the name from.\n * @param suffix Suffix to remove from extracted name.\n *\n * @returns The basename of the path.\n */\nexport function basename(path: string, suffix = \"\"): string {\n  return isWindows\n    ? windowsBasename(path, suffix)\n    : posixBasename(path, suffix);\n}\n", "// Copyright 2018-2024 the Deno authors. All rights reserved. MIT license.\n// This module is browser compatible.\n\nimport { isWindows } from \"./_os.ts\";\nimport { normalize as posixNormalize } from \"./posix/normalize.ts\";\nimport { normalize as windowsNormalize } from \"./windows/normalize.ts\";\n/**\n * Normalize the path, resolving `'..'` and `'.'` segments.\n *\n * Note: Resolving these segments does not necessarily mean that all will be\n * eliminated. A `'..'` at the top-level will be preserved, and an empty path is\n * canonically `'.'`.\n *\n * @example Usage\n * ```ts\n * import { normalize } from \"@std/path/normalize\";\n * import { assertEquals } from \"@std/assert\";\n *\n * if (Deno.build.os === \"windows\") {\n *   assertEquals(normalize(\"C:\\\\foo\\\\bar\\\\..\\\\baz\\\\quux\"), \"C:\\\\foo\\\\baz\\\\quux\");\n * } else {\n *   assertEquals(normalize(\"/foo/bar/../baz/quux\"), \"/foo/baz/quux\");\n * }\n * ```\n *\n * Note: If you are working with file URLs,\n * use the new version of `normalize` from `@std/path/unstable-normalize`.\n *\n * @param path Path to be normalized\n * @returns The normalized path.\n */\nexport function normalize(path: string): string {\n  return isWindows ? windowsNormalize(path) : posixNormalize(path);\n}\n", "// Copyright 2018-2025 the Deno authors. MIT license.\n// Copyright the Browserify authors. MIT License.\n\nimport { basename } from \"jsr:@std/path@^1.0.8/basename\";\nimport { normalize } from \"jsr:@std/path@^1.0.8/normalize\";\nimport { toPathString } from \"./_to_path_string.ts\";\n\n/**\n * Walk entry for {@linkcode walk}, {@linkcode walkSync},\n * {@linkcode expandGlob} and {@linkcode expandGlobSync}.\n */\nexport interface WalkEntry extends Deno.DirEntry {\n  /** Full path of the entry. */\n  path: string;\n}\n\n/** Create {@linkcode WalkEntry} for the `path` synchronously. */\nexport function createWalkEntrySync(path: string | URL): WalkEntry {\n  path = toPathString(path);\n  path = normalize(path);\n  const name = basename(path);\n  const info = Deno.statSync(path);\n  return {\n    path,\n    name,\n    isFile: info.isFile,\n    isDirectory: info.isDirectory,\n    isSymlink: info.isSymlink,\n  };\n}\n\n/** Create {@linkcode WalkEntry} for the `path` asynchronously. */\nexport async function createWalkEntry(path: string | URL): Promise<WalkEntry> {\n  path = toPathString(path);\n  path = normalize(path);\n  const name = basename(path);\n  const info = await Deno.stat(path);\n  return {\n    path,\n    name,\n    isFile: info.isFile,\n    isDirectory: info.isDirectory,\n    isSymlink: info.isSymlink,\n  };\n}\n", "// Copyright 2018-2025 the Deno authors. MIT license.\n// Documentation and interface for walk were adapted from Go\n// https://golang.org/pkg/path/filepath/#Walk\n// Copyright 2009 The Go Authors. All rights reserved. BSD license.\nimport { join } from \"jsr:@std/path@^1.0.8/join\";\nimport { toPathString } from \"./_to_path_string.ts\";\nimport {\n  createWalkEntry,\n  createWalkEntrySync,\n  type WalkEntry,\n} from \"./_create_walk_entry.ts\";\n\nfunction include(\n  path: string,\n  exts?: string[],\n  match?: RegExp[],\n  skip?: RegExp[],\n): boolean {\n  if (exts && !exts.some((ext): boolean => path.endsWith(ext))) {\n    return false;\n  }\n  if (match && !match.some((pattern): boolean => !!path.match(pattern))) {\n    return false;\n  }\n  if (skip && skip.some((pattern): boolean => !!path.match(pattern))) {\n    return false;\n  }\n  return true;\n}\n\n/** Options for {@linkcode walk} and {@linkcode walkSync}. */\nexport interface WalkOptions {\n  /**\n   * The maximum depth of the file tree to be walked recursively.\n   *\n   * @default {Infinity}\n   */\n  maxDepth?: number;\n  /**\n   * Indicates whether file entries should be included or not.\n   *\n   * @default {true}\n   */\n  includeFiles?: boolean;\n  /**\n   * Indicates whether directory entries should be included or not.\n   *\n   * @default {true}\n   */\n  includeDirs?: boolean;\n  /**\n   * Indicates whether symlink entries should be included or not.\n   * This option is meaningful only if `followSymlinks` is set to `false`.\n   *\n   * @default {true}\n   */\n  includeSymlinks?: boolean;\n  /**\n   * Indicates whether symlinks should be resolved or not.\n   *\n   * @default {false}\n   */\n  followSymlinks?: boolean;\n  /**\n   * Indicates whether the followed symlink's path should be canonicalized.\n   * This option works only if `followSymlinks` is not `false`.\n   *\n   * @default {true}\n   */\n  canonicalize?: boolean;\n  /**\n   * List of file extensions used to filter entries.\n   * If specified, entries without the file extension specified by this option\n   * are excluded.\n   *\n   * File extensions with or without a leading period are accepted.\n   *\n   * @default {[]}\n   */\n  exts?: string[];\n  /**\n   * List of regular expression patterns used to filter entries.\n   * If specified, entries that do not match the patterns specified by this\n   * option are excluded.\n   */\n  match?: RegExp[];\n  /**\n   * List of regular expression patterns used to filter entries.\n   * If specified, entries matching the patterns specified by this option are\n   * excluded.\n   */\n  skip?: RegExp[];\n}\nexport type { WalkEntry };\n\n/**\n * Recursively walks through a directory and yields information about each file\n * and directory encountered.\n *\n * The root path determines whether the file paths are relative or absolute.\n * The root directory is included in the yielded entries.\n *\n * Requires `--allow-read` permission.\n *\n * @see {@link https://docs.deno.com/runtime/manual/basics/permissions#file-system-access}\n * for more information on Deno's permissions system.\n *\n * @param root The root directory to start the walk from, as a string or URL.\n * @param options The options for the walk.\n * @throws {Deno.errors.NotFound} If the root directory does not exist.\n *\n * @returns An async iterable iterator that yields the walk entry objects.\n *\n * @example Basic usage\n *\n * File structure:\n * ```\n * folder\n * \u251C\u2500\u2500 script.ts\n * \u2514\u2500\u2500 foo.ts\n * ```\n *\n * ```ts ignore\n * import { walk } from \"@std/fs/walk\";\n *\n * await Array.fromAsync(walk(\".\"));\n * // [\n * //   {\n * //     path: \".\",\n * //     name: \".\",\n * //     isFile: false,\n * //     isDirectory: true,\n * //     isSymlink: false\n * //   },\n * //   {\n * //     path: \"script.ts\",\n * //     name: \"script.ts\",\n * //     isFile: true,\n * //     isDirectory: false,\n * //     isSymlink: false\n * //   },\n * //   {\n * //     path: \"foo.ts\",\n * //     name: \"foo.ts\",\n * //     isFile: true,\n * //     isDirectory: false,\n * //     isSymlink: false\n * //   },\n * // ]\n * ```\n *\n * @example Maximum file depth\n *\n * Setting the `maxDepth` option to `1` will only include the root directory and\n * its immediate children.\n *\n * File structure:\n * ```\n * folder\n * \u251C\u2500\u2500 script.ts\n * \u2514\u2500\u2500 foo\n *     \u2514\u2500\u2500 bar.ts\n * ```\n *\n * ```ts ignore\n * import { walk } from \"@std/fs/walk\";\n *\n * await Array.fromAsync(walk(\".\", { maxDepth: 1 }));\n * // [\n * //   {\n * //     path: \".\",\n * //     name: \".\",\n * //     isFile: false,\n * //     isDirectory: true,\n * //     isSymlink: false\n * //   },\n * //   {\n * //     path: \"script.ts\",\n * //     name: \"script.ts\",\n * //     isFile: true,\n * //     isDirectory: false,\n * //     isSymlink: false\n * //   },\n * //   {\n * //     path: \"foo\",\n * //     name: \"foo\",\n * //     isFile: false,\n * //     isDirectory: true,\n * //     isSymlink: false\n * //   },\n * // ]\n * ```\n *\n * @example Exclude files\n *\n * Setting the `includeFiles` option to `false` will exclude files.\n *\n * File structure:\n * ```\n * folder\n * \u251C\u2500\u2500 script.ts\n * \u2514\u2500\u2500 foo\n * ```\n *\n * ```ts ignore\n * import { walk } from \"@std/fs/walk\";\n *\n * await Array.fromAsync(walk(\".\", { includeFiles: false }));\n * // [\n * //   {\n * //     path: \".\",\n * //     name: \".\",\n * //     isFile: false,\n * //     isDirectory: true,\n * //     isSymlink: false\n * //   },\n * //   {\n * //     path: \"foo\",\n * //     name: \"foo\",\n * //     isFile: false,\n * //     isDirectory: true,\n * //     isSymlink: false,\n * //   },\n * // ]\n * ```\n *\n * @example Exclude directories\n *\n * Setting the `includeDirs` option to `false` will exclude directories.\n *\n * File structure:\n * ```\n * folder\n * \u251C\u2500\u2500 script.ts\n * \u2514\u2500\u2500 foo\n * ```\n *\n * ```ts ignore\n * import { walk } from \"@std/fs/walk\";\n *\n * await Array.fromAsync(walk(\".\", { includeDirs: false }));\n * // [\n * //   {\n * //     path: \"script.ts\",\n * //     name: \"script.ts\",\n * //     isFile: true,\n * //     isDirectory: false,\n * //     isSymlink: false\n * //   },\n * // ]\n * ```\n *\n * @example Exclude symbolic links\n *\n * Setting the `includeSymlinks` option to `false` will exclude symbolic links.\n *\n * File structure:\n * ```\n * folder\n * \u251C\u2500\u2500 script.ts\n * \u251C\u2500\u2500 foo\n * \u2514\u2500\u2500 link -> script.ts (symbolic link)\n * ```\n *\n * ```ts ignore\n * import { walk } from \"@std/fs/walk\";\n *\n * await Array.fromAsync(walk(\".\", { includeSymlinks: false }));\n * // [\n * //   {\n * //     path: \".\",\n * //     name: \".\",\n * //     isFile: false,\n * //     isDirectory: true,\n * //     isSymlink: false\n * //   },\n * //   {\n * //     path: \"script.ts\",\n * //     name: \"script.ts\",\n * //     isFile: true,\n * //     isDirectory: false,\n * //     isSymlink: false\n * //   },\n * // ]\n * ```\n *\n * @example Follow symbolic links\n *\n * Setting the `followSymlinks` option to `true` will follow symbolic links,\n * affecting the `path` property of the walk entry.\n *\n * File structure:\n * ```\n * folder\n * \u251C\u2500\u2500 script.ts\n * \u2514\u2500\u2500 link -> script.ts (symbolic link)\n * ```\n *\n * ```ts ignore\n * import { walk } from \"@std/fs/walk\";\n *\n * await Array.fromAsync(walk(\".\", { followSymlinks: true }));\n * // [\n * //   {\n * //     path: \".\",\n * //     name: \".\",\n * //     isFile: false,\n * //     isDirectory: true,\n * //     isSymlink: false\n * //   },\n * //   {\n * //     path: \"script.ts\",\n * //     name: \"script.ts\",\n * //     isFile: true,\n * //     isDirectory: false,\n * //     isSymlink: false\n * //   },\n * //   {\n * //     path: \"script.ts\",\n * //     name: \"link\",\n * //     isFile: true,\n * //     isDirectory: false,\n * //     isSymlink: true\n * //   },\n * // ]\n * ```\n *\n * @example Canonicalize symbolic links\n *\n * Setting the `canonicalize` option to `false` will canonicalize the path of\n * the followed symbolic link. Meaning, the `path` property of the walk entry\n * will be the path of the symbolic link itself.\n *\n * File structure:\n * ```\n * folder\n * \u251C\u2500\u2500 script.ts\n * \u2514\u2500\u2500 link -> script.ts (symbolic link)\n * ```\n *\n * ```ts ignore\n * import { walk } from \"@std/fs/walk\";\n *\n * await Array.fromAsync(walk(\".\", { followSymlinks: true, canonicalize: true }));\n * // [\n * //   {\n * //     path: \".\",\n * //     name: \".\",\n * //     isFile: false,\n * //     isDirectory: true,\n * //     isSymlink: false\n * //   },\n * //   {\n * //     path: \"script.ts\",\n * //     name: \"script.ts\",\n * //     isFile: true,\n * //     isDirectory: false,\n * //     isSymlink: false\n * //   },\n * //   {\n * //     path: \"link\",\n * //     name: \"link\",\n * //     isFile: true,\n * //     isDirectory: false,\n * //     isSymlink: true\n * //   },\n * // ]\n * ```\n *\n * @example Filter by file extensions\n *\n * Setting the `exts` option to `[\".ts\"]` or `[\"ts\"]` will only include entries\n * with the `.ts` file extension.\n *\n * File structure:\n * ```\n * folder\n * \u251C\u2500\u2500 script.ts\n * \u2514\u2500\u2500 foo.js\n * ```\n *\n * ```ts ignore\n * import { walk } from \"@std/fs/walk\";\n *\n * await Array.fromAsync(walk(\".\", { exts: [\".ts\"] }));\n * // [\n * //   {\n * //     path: \"script.ts\",\n * //     name: \"script.ts\",\n * //     isFile: true,\n * //     isDirectory: false,\n * //     isSymlink: false\n * //   },\n * // ]\n * ```\n *\n * @example Filter by regular expressions\n *\n * Setting the `match` option to `[/.s/]` will only include entries with the\n * letter `s` in their name.\n *\n * File structure:\n * ```\n * folder\n * \u251C\u2500\u2500 script.ts\n * \u2514\u2500\u2500 README.md\n * ```\n *\n * ```ts ignore\n * import { walk } from \"@std/fs/walk\";\n *\n * await Array.fromAsync(walk(\".\", { match: [/s/] }));\n * // [\n * //   {\n * //     path: \"script.ts\",\n * //     name: \"script.ts\",\n * //     isFile: true,\n * //     isDirectory: false,\n * //     isSymlink: false\n * //   },\n * // ]\n * ```\n *\n * @example Exclude by regular expressions\n *\n * Setting the `skip` option to `[/.s/]` will exclude entries with the letter\n * `s` in their name.\n *\n * File structure:\n * ```\n * folder\n * \u251C\u2500\u2500 script.ts\n * \u2514\u2500\u2500 README.md\n * ```\n *\n * ```ts ignore\n * import { walk } from \"@std/fs/walk\";\n *\n * await Array.fromAsync(walk(\".\", { skip: [/s/] }));\n * // [\n * //   {\n * //     path: \"README.md\",\n * //     name: \"README.md\",\n * //     isFile: true,\n * //     isDirectory: false,\n * //     isSymlink: false\n * //   },\n * // ]\n * ```\n */\nexport async function* walk(\n  root: string | URL,\n  options?: WalkOptions,\n): AsyncIterableIterator<WalkEntry> {\n  let {\n    maxDepth = Infinity,\n    includeFiles = true,\n    includeDirs = true,\n    includeSymlinks = true,\n    followSymlinks = false,\n    canonicalize = true,\n    exts = undefined,\n    match = undefined,\n    skip = undefined,\n  } = options ?? {};\n\n  if (maxDepth < 0) {\n    return;\n  }\n  root = toPathString(root);\n  if (exts) {\n    exts = exts.map((ext) => ext.startsWith(\".\") ? ext : `.${ext}`);\n  }\n  if (includeDirs && include(root, exts, match, skip)) {\n    yield await createWalkEntry(root);\n  }\n  if (maxDepth < 1 || !include(root, undefined, undefined, skip)) {\n    return;\n  }\n  for await (const entry of Deno.readDir(root)) {\n    let path = join(root, entry.name);\n\n    let { isSymlink, isDirectory } = entry;\n\n    if (isSymlink) {\n      if (!followSymlinks) {\n        if (includeSymlinks && include(path, exts, match, skip)) {\n          yield { path, ...entry };\n        }\n        continue;\n      }\n      const realPath = await Deno.realPath(path);\n      if (canonicalize) {\n        path = realPath;\n      }\n      // Caveat emptor: don't assume |path| is not a symlink. realpath()\n      // resolves symlinks but another process can replace the file system\n      // entity with a different type of entity before we call lstat().\n      ({ isSymlink, isDirectory } = await Deno.lstat(realPath));\n    }\n\n    if (isSymlink || isDirectory) {\n      const opts: WalkOptions = {\n        maxDepth: maxDepth - 1,\n        includeFiles,\n        includeDirs,\n        includeSymlinks,\n        followSymlinks,\n      };\n      if (exts !== undefined) {\n        opts.exts = exts;\n      }\n      if (match !== undefined) {\n        opts.match = match;\n      }\n      if (skip !== undefined) {\n        opts.skip = skip;\n      }\n      yield* walk(path, opts);\n    } else if (includeFiles && include(path, exts, match, skip)) {\n      yield { path, ...entry };\n    }\n  }\n}\n\n/**\n * Recursively walks through a directory and yields information about each file\n * and directory encountered.\n *\n * The root path determines whether the file paths is relative or absolute.\n * The root directory is included in the yielded entries.\n *\n * Requires `--allow-read` permission.\n *\n * @see {@link https://docs.deno.com/runtime/manual/basics/permissions#file-system-access}\n * for more information on Deno's permissions system.\n *\n * @param root The root directory to start the walk from, as a string or URL.\n * @param options The options for the walk.\n *\n * @returns A synchronous iterable iterator that yields the walk entry objects.\n *\n * @example Basic usage\n *\n * File structure:\n * ```\n * folder\n * \u251C\u2500\u2500 script.ts\n * \u2514\u2500\u2500 foo.ts\n * ```\n *\n * ```ts ignore\n * import { walkSync } from \"@std/fs/walk\";\n *\n * Array.from(walkSync(\".\"));\n * // [\n * //   {\n * //     path: \".\",\n * //     name: \".\",\n * //     isFile: false,\n * //     isDirectory: true,\n * //     isSymlink: false\n * //   },\n * //   {\n * //     path: \"script.ts\",\n * //     name: \"script.ts\",\n * //     isFile: true,\n * //     isDirectory: false,\n * //     isSymlink: false\n * //   },\n * //   {\n * //     path: \"foo.ts\",\n * //     name: \"foo.ts\",\n * //     isFile: true,\n * //     isDirectory: false,\n * //     isSymlink: false\n * //   },\n * // ]\n * ```\n *\n * @example Maximum file depth\n *\n * Setting the `maxDepth` option to `1` will only include the root directory and\n * its immediate children.\n *\n * File structure:\n * ```\n * folder\n * \u251C\u2500\u2500 script.ts\n * \u2514\u2500\u2500 foo\n *     \u2514\u2500\u2500 bar.ts\n * ```\n *\n * ```ts ignore\n * import { walkSync } from \"@std/fs/walk\";\n *\n * Array.from(walkSync(\".\", { maxDepth: 1 }));\n * // [\n * //   {\n * //     path: \".\",\n * //     name: \".\",\n * //     isFile: false,\n * //     isDirectory: true,\n * //     isSymlink: false\n * //   },\n * //   {\n * //     path: \"script.ts\",\n * //     name: \"script.ts\",\n * //     isFile: true,\n * //     isDirectory: false,\n * //     isSymlink: false\n * //   },\n * //   {\n * //     path: \"foo\",\n * //     name: \"foo\",\n * //     isFile: false,\n * //     isDirectory: true,\n * //     isSymlink: false\n * //   },\n * // ]\n * ```\n *\n * @example Exclude files\n *\n * Setting the `includeFiles` option to `false` will exclude files.\n *\n * File structure:\n * ```\n * folder\n * \u251C\u2500\u2500 script.ts\n * \u2514\u2500\u2500 foo\n * ```\n *\n * ```ts ignore\n * import { walkSync } from \"@std/fs/walk\";\n *\n * Array.from(walkSync(\".\", { includeFiles: false }));\n * // [\n * //   {\n * //     path: \".\",\n * //     name: \".\",\n * //     isFile: false,\n * //     isDirectory: true,\n * //     isSymlink: false\n * //   },\n * //   {\n * //     path: \"foo\",\n * //     name: \"foo\",\n * //     isFile: false,\n * //     isDirectory: true,\n * //     isSymlink: false,\n * //   },\n * // ]\n * ```\n *\n * @example Exclude directories\n *\n * Setting the `includeDirs` option to `false` will exclude directories.\n *\n * File structure:\n * ```\n * folder\n * \u251C\u2500\u2500 script.ts\n * \u2514\u2500\u2500 foo\n * ```\n *\n * ```ts ignore\n * import { walkSync } from \"@std/fs/walk\";\n *\n * Array.from(walkSync(\".\", { includeDirs: false }));\n * // [\n * //   {\n * //     path: \"script.ts\",\n * //     name: \"script.ts\",\n * //     isFile: true,\n * //     isDirectory: false,\n * //     isSymlink: false\n * //   },\n * // ]\n * ```\n *\n * @example Exclude symbolic links\n *\n * Setting the `includeSymlinks` option to `false` will exclude symbolic links.\n *\n * File structure:\n * ```\n * folder\n * \u251C\u2500\u2500 script.ts\n * \u251C\u2500\u2500 foo\n * \u2514\u2500\u2500 link -> script.ts (symbolic link)\n * ```\n *\n * ```ts ignore\n * import { walkSync } from \"@std/fs/walk\";\n *\n * Array.from(walkSync(\".\", { includeSymlinks: false }));\n * // [\n * //   {\n * //     path: \".\",\n * //     name: \".\",\n * //     isFile: false,\n * //     isDirectory: true,\n * //     isSymlink: false\n * //   },\n * //   {\n * //     path: \"script.ts\",\n * //     name: \"script.ts\",\n * //     isFile: true,\n * //     isDirectory: false,\n * //     isSymlink: false\n * //   },\n * // ]\n * ```\n *\n * @example Follow symbolic links\n *\n * Setting the `followSymlinks` option to `true` will follow symbolic links,\n * affecting the `path` property of the walk entry.\n *\n * File structure:\n * ```\n * folder\n * \u251C\u2500\u2500 script.ts\n * \u2514\u2500\u2500 link -> script.ts (symbolic link)\n * ```\n *\n * ```ts ignore\n * import { walkSync } from \"@std/fs/walk\";\n *\n * Array.from(walkSync(\".\", { followSymlinks: true }));\n * // [\n * //   {\n * //     path: \".\",\n * //     name: \".\",\n * //     isFile: false,\n * //     isDirectory: true,\n * //     isSymlink: false\n * //   },\n * //   {\n * //     path: \"script.ts\",\n * //     name: \"script.ts\",\n * //     isFile: true,\n * //     isDirectory: false,\n * //     isSymlink: false\n * //   },\n * //   {\n * //     path: \"script.ts\",\n * //     name: \"link\",\n * //     isFile: true,\n * //     isDirectory: false,\n * //     isSymlink: true\n * //   },\n * // ]\n * ```\n *\n * @example Canonicalize symbolic links\n *\n * Setting the `canonicalize` option to `false` will canonicalize the path of\n * the followed symbolic link. Meaning, the `path` property of the walk entry\n * will be the path of the symbolic link itself.\n *\n * File structure:\n * ```\n * folder\n * \u251C\u2500\u2500 script.ts\n * \u2514\u2500\u2500 link -> script.ts (symbolic link)\n * ```\n *\n * ```ts ignore\n * import { walkSync } from \"@std/fs/walk\";\n *\n * Array.from(walkSync(\".\", { followSymlinks: true, canonicalize: true }));\n * // [\n * //   {\n * //     path: \".\",\n * //     name: \".\",\n * //     isFile: false,\n * //     isDirectory: true,\n * //     isSymlink: false\n * //   },\n * //   {\n * //     path: \"script.ts\",\n * //     name: \"script.ts\",\n * //     isFile: true,\n * //     isDirectory: false,\n * //     isSymlink: false\n * //   },\n * //   {\n * //     path: \"link\",\n * //     name: \"link\",\n * //     isFile: true,\n * //     isDirectory: false,\n * //     isSymlink: true\n * //   },\n * // ]\n * ```\n *\n * @example Filter by file extensions\n *\n * Setting the `exts` option to `[\".ts\"]` or `[\"ts\"]` will only include entries\n * with the `.ts` file extension.\n *\n * File structure:\n * ```\n * folder\n * \u251C\u2500\u2500 script.ts\n * \u2514\u2500\u2500 foo.js\n * ```\n *\n * ```ts ignore\n * import { walkSync } from \"@std/fs/walk\";\n *\n * Array.from(walkSync(\".\", { exts: [\".ts\"] }));\n * // [\n * //   {\n * //     path: \"script.ts\",\n * //     name: \"script.ts\",\n * //     isFile: true,\n * //     isDirectory: false,\n * //     isSymlink: false\n * //   },\n * // ]\n * ```\n *\n * @example Filter by regular expressions\n *\n * Setting the `match` option to `[/.s/]` will only include entries with the\n * letter `s` in their name.\n *\n * File structure:\n * ```\n * folder\n * \u251C\u2500\u2500 script.ts\n * \u2514\u2500\u2500 README.md\n * ```\n *\n * ```ts ignore\n * import { walkSync } from \"@std/fs/walk\";\n *\n * Array.from(walkSync(\".\", { match: [/s/] }));\n * // [\n * //   {\n * //     path: \"script.ts\",\n * //     name: \"script.ts\",\n * //     isFile: true,\n * //     isDirectory: false,\n * //     isSymlink: false\n * //   },\n * // ]\n * ```\n *\n * @example Exclude by regular expressions\n *\n * Setting the `skip` option to `[/.s/]` will exclude entries with the letter\n * `s` in their name.\n *\n * File structure:\n * ```\n * folder\n * \u251C\u2500\u2500 script.ts\n * \u2514\u2500\u2500 README.md\n * ```\n *\n * ```ts ignore\n * import { walkSync } from \"@std/fs/walk\";\n *\n * Array.from(walkSync(\".\", { skip: [/s/] }));\n * // [\n * //   {\n * //     path: \"README.md\",\n * //     name: \"README.md\",\n * //     isFile: true,\n * //     isDirectory: false,\n * //     isSymlink: false\n * //   },\n * // ]\n * ```\n */\nexport function* walkSync(\n  root: string | URL,\n  options?: WalkOptions,\n): IterableIterator<WalkEntry> {\n  let {\n    maxDepth = Infinity,\n    includeFiles = true,\n    includeDirs = true,\n    includeSymlinks = true,\n    followSymlinks = false,\n    canonicalize = true,\n    exts = undefined,\n    match = undefined,\n    skip = undefined,\n  } = options ?? {};\n\n  root = toPathString(root);\n  if (exts) {\n    exts = exts.map((ext) => ext.startsWith(\".\") ? ext : `.${ext}`);\n  }\n  if (maxDepth < 0) {\n    return;\n  }\n  if (includeDirs && include(root, exts, match, skip)) {\n    yield createWalkEntrySync(root);\n  }\n  if (maxDepth < 1 || !include(root, undefined, undefined, skip)) {\n    return;\n  }\n  const entries = Deno.readDirSync(root);\n  for (const entry of entries) {\n    let path = join(root, entry.name);\n\n    let { isSymlink, isDirectory } = entry;\n\n    if (isSymlink) {\n      if (!followSymlinks) {\n        if (includeSymlinks && include(path, exts, match, skip)) {\n          yield { path, ...entry };\n        }\n        continue;\n      }\n      const realPath = Deno.realPathSync(path);\n      if (canonicalize) {\n        path = realPath;\n      }\n      // Caveat emptor: don't assume |path| is not a symlink. realpath()\n      // resolves symlinks but another process can replace the file system\n      // entity with a different type of entity before we call lstat().\n      ({ isSymlink, isDirectory } = Deno.lstatSync(realPath));\n    }\n\n    if (isSymlink || isDirectory) {\n      const opts: WalkOptions = {\n        maxDepth: maxDepth - 1,\n        includeFiles,\n        includeDirs,\n        includeSymlinks,\n        followSymlinks,\n      };\n      if (exts !== undefined) {\n        opts.exts = exts;\n      }\n      if (match !== undefined) {\n        opts.match = match;\n      }\n      if (skip !== undefined) {\n        opts.skip = skip;\n      }\n      yield* walkSync(path, opts);\n    } else if (includeFiles && include(path, exts, match, skip)) {\n      yield { path, ...entry };\n    }\n  }\n}\n", "// Copyright 2018-2025 the Deno authors. MIT license.\nimport { type GlobOptions, globToRegExp } from \"jsr:@std/path@^1.0.8/glob-to-regexp\";\nimport { joinGlobs } from \"jsr:@std/path@^1.0.8/join-globs\";\nimport { isGlob } from \"jsr:@std/path@^1.0.8/is-glob\";\nimport { isAbsolute } from \"jsr:@std/path@^1.0.8/is-absolute\";\nimport { resolve } from \"jsr:@std/path@^1.0.8/resolve\";\nimport { SEPARATOR_PATTERN } from \"jsr:@std/path@^1.0.8/constants\";\nimport { walk, walkSync } from \"./walk.ts\";\nimport { toPathString } from \"./_to_path_string.ts\";\nimport {\n  createWalkEntry,\n  createWalkEntrySync,\n  type WalkEntry,\n} from \"./_create_walk_entry.ts\";\n\nexport type { GlobOptions, WalkEntry };\n\n// deno-lint-ignore no-explicit-any\nconst isWindows = (globalThis as any).Deno?.build.os === \"windows\";\n\n/** Options for {@linkcode expandGlob} and {@linkcode expandGlobSync}. */\nexport interface ExpandGlobOptions extends Omit<GlobOptions, \"os\"> {\n  /**\n   * File path where to expand from.\n   *\n   * @default {Deno.cwd()}\n   */\n  root?: string;\n  /**\n   * List of glob patterns to be excluded from the expansion.\n   *\n   * @default {[]}\n   */\n  exclude?: string[];\n  /**\n   * Whether to include directories in entries.\n   *\n   * @default {true}\n   */\n  includeDirs?: boolean;\n  /**\n   * Whether to follow symbolic links.\n   *\n   * @default {false}\n   */\n  followSymlinks?: boolean;\n  /**\n   * Indicates whether the followed symlink's path should be canonicalized.\n   * This option works only if `followSymlinks` is not `false`.\n   *\n   * @default {true}\n   */\n  canonicalize?: boolean;\n}\n\ninterface SplitPath {\n  segments: string[];\n  isAbsolute: boolean;\n  hasTrailingSep: boolean;\n  // Defined for any absolute Windows path.\n  winRoot?: string;\n}\n\nfunction split(path: string): SplitPath {\n  const s = SEPARATOR_PATTERN.source;\n  const segments = path\n    .replace(new RegExp(`^${s}|${s}$`, \"g\"), \"\")\n    .split(SEPARATOR_PATTERN);\n  const isAbsolute_ = isAbsolute(path);\n  const split: SplitPath = {\n    segments,\n    isAbsolute: isAbsolute_,\n    hasTrailingSep: path.match(new RegExp(`${s}$`)) !== null,\n  };\n  if (isWindows && isAbsolute_) {\n    split.winRoot = segments.shift()!;\n  }\n  return split;\n}\n\nfunction throwUnlessNotFound(error: unknown) {\n  if (!(error instanceof Deno.errors.NotFound)) {\n    throw error;\n  }\n}\n\nfunction comparePath(a: WalkEntry, b: WalkEntry): number {\n  if (a.path < b.path) return -1;\n  if (a.path > b.path) return 1;\n  return 0;\n}\n\n/**\n * Returns an async iterator that yields each file path matching the given glob\n * pattern.\n *\n * The file paths are absolute paths. If `root` is not provided, the current\n * working directory is used. The `root` directory is not included in the\n * yielded file paths.\n *\n * Requires `--allow-read` permission.\n *\n * @see {@link https://docs.deno.com/runtime/manual/basics/permissions#file-system-access}\n * for more information on Deno's permissions system.\n *\n * @param glob The glob pattern to expand.\n * @param options Additional options for the expansion.\n *\n * @returns An async iterator that yields each walk entry matching the glob\n * pattern.\n *\n * @example Basic usage\n *\n * File structure:\n * ```\n * folder\n * \u251C\u2500\u2500 script.ts\n * \u2514\u2500\u2500 foo.ts\n * ```\n *\n * ```ts ignore\n * // script.ts\n * import { expandGlob } from \"@std/fs/expand-glob\";\n *\n * await Array.fromAsync(expandGlob(\"*.ts\"));\n * // [\n * //   {\n * //     path: \"/Users/user/folder/script.ts\",\n * //     name: \"script.ts\",\n * //     isFile: true,\n * //     isDirectory: false,\n * //     isSymlink: false,\n * //   },\n * //   {\n * //     path: \"/Users/user/folder/foo.ts\",\n * //     name: \"foo.ts\",\n * //     isFile: true,\n * //     isDirectory: false,\n * //     isSymlink: false,\n * //   },\n * // ]\n * ```\n *\n * @example Define root directory\n *\n * Setting the `root` option to `/folder` will expand the glob pattern from the\n * `/folder` directory.\n *\n * File structure:\n * ```\n * folder\n * \u251C\u2500\u2500 subdir\n * \u2502   \u2514\u2500\u2500 bar.ts\n * \u251C\u2500\u2500 script.ts\n * \u2514\u2500\u2500 foo.ts\n * ```\n *\n * ```ts ignore\n * // script.ts\n * import { expandGlob } from \"@std/fs/expand-glob\";\n *\n * await Array.fromAsync(expandGlob(\"*.ts\", { root: \"./subdir\" }));\n * // [\n * //   {\n * //     path: \"/Users/user/folder/subdir/bar.ts\",\n * //     name: \"bar.ts\",\n * //     isFile: true,\n * //     isDirectory: false,\n * //     isSymlink: false,\n * //   },\n * // ]\n * ```\n *\n * @example Exclude files\n *\n * Setting the `exclude` option to `[\"foo.ts\"]` will exclude the `foo.ts` file\n * from the expansion.\n *\n * File structure:\n * ```\n * folder\n * \u251C\u2500\u2500 script.ts\n * \u2514\u2500\u2500 foo.ts\n * ```\n *\n * ```ts ignore\n * // script.ts\n * import { expandGlob } from \"@std/fs/expand-glob\";\n *\n * await Array.fromAsync(expandGlob(\"*.ts\", { exclude: [\"foo.ts\"] }));\n * // [\n * //   {\n * //     path: \"/Users/user/folder/script.ts\",\n * //     name: \"true.ts\",\n * //     isFile: false,\n * //     isDirectory: false,\n * //     isSymlink: false,\n * //   },\n * // ]\n * ```\n *\n * @example Exclude directories\n *\n * Setting the `includeDirs` option to `false` will exclude directories from the\n * expansion.\n *\n * File structure:\n * ```\n * folder\n * \u251C\u2500\u2500 subdir\n * \u2502   \u2514\u2500\u2500 bar.ts\n * \u251C\u2500\u2500 script.ts\n * \u2514\u2500\u2500 foo.ts\n * ```\n *\n * ```ts ignore\n * // script.ts\n * import { expandGlob } from \"@std/fs/expand-glob\";\n *\n * await Array.fromAsync(expandGlob(\"*\", { includeDirs: false }));\n * // [\n * //   {\n * //     path: \"/Users/user/folder/script.ts\",\n * //     name: \"script.ts\",\n * //     isFile: true,\n * //     isDirectory: false,\n * //     isSymlink: false,\n * //   },\n * //   {\n * //     path: \"/Users/user/folder/foo.ts\",\n * //     name: \"foo.ts\",\n * //     isFile: true,\n * //     isDirectory: false,\n * //     isSymlink: false,\n * //   },\n * // ]\n * ```\n *\n * @example Follow symbolic links\n *\n * Setting the `followSymlinks` option to `true` will follow symbolic links.\n *\n * File structure:\n * ```\n * folder\n * \u251C\u2500\u2500 script.ts\n * \u2514\u2500\u2500 link.ts -> script.ts (symbolic link)\n * ```\n *\n * ```ts ignore\n * // script.ts\n * import { expandGlob } from \"@std/fs/expand-glob\";\n *\n * await Array.fromAsync(expandGlob(\"*.ts\", { followSymlinks: true }));\n * // [\n * //   {\n * //     path: \"/Users/user/folder/script.ts\",\n * //     name: \"script.ts\",\n * //     isFile: true,\n * //     isDirectory: false,\n * //     isSymlink: false,\n * //   },\n * //   {\n * //     path: \"/Users/user/folder/symlink\",\n * //     name: \"symlink\",\n * //     isFile: true,\n * //     isDirectory: false,\n * //     isSymlink: true,\n * //   },\n * // ]\n * ```\n */\nexport async function* expandGlob(\n  glob: string | URL,\n  options?: ExpandGlobOptions,\n): AsyncIterableIterator<WalkEntry> {\n  let {\n    root,\n    exclude = [],\n    includeDirs = true,\n    extended = true,\n    globstar = true,\n    caseInsensitive = false,\n    followSymlinks = false,\n    canonicalize = true,\n  } = options ?? {};\n\n  const {\n    segments,\n    isAbsolute: isGlobAbsolute,\n    hasTrailingSep,\n    winRoot,\n  } = split(toPathString(glob));\n  root ??= isGlobAbsolute ? winRoot ?? \"/\" : Deno.cwd();\n\n  const globOptions: GlobOptions = { extended, globstar, caseInsensitive };\n  const absRoot = isGlobAbsolute ? root : resolve(root!); // root is always string here\n  const resolveFromRoot = (path: string): string => resolve(absRoot, path);\n  const excludePatterns = exclude\n    .map(resolveFromRoot)\n    .map((s: string): RegExp => globToRegExp(s, globOptions));\n  const shouldInclude = (path: string): boolean =>\n    !excludePatterns.some((p: RegExp): boolean => !!path.match(p));\n\n  let fixedRoot = isGlobAbsolute ? winRoot ?? \"/\" : absRoot;\n  while (segments.length > 0 && !isGlob(segments[0]!)) {\n    const seg = segments.shift()!;\n    fixedRoot = joinGlobs([fixedRoot, seg], globOptions);\n  }\n\n  let fixedRootInfo: WalkEntry;\n  try {\n    fixedRootInfo = await createWalkEntry(fixedRoot);\n  } catch (error) {\n    return throwUnlessNotFound(error);\n  }\n\n  async function* advanceMatch(\n    walkInfo: WalkEntry,\n    globSegment: string,\n  ): AsyncIterableIterator<WalkEntry> {\n    if (!walkInfo.isDirectory) {\n      return;\n    } else if (globSegment === \"..\") {\n      const parentPath = joinGlobs([walkInfo.path, \"..\"], globOptions);\n      if (shouldInclude(parentPath)) {\n        return yield await createWalkEntry(parentPath);\n      }\n      return;\n    } else if (globSegment === \"**\") {\n      return yield* walk(walkInfo.path, {\n        skip: excludePatterns,\n        maxDepth: globstar ? Infinity : 1,\n        followSymlinks,\n        canonicalize,\n      });\n    }\n    const globPattern = globToRegExp(globSegment, globOptions);\n    for await (\n      const walkEntry of walk(walkInfo.path, {\n        maxDepth: 1,\n        skip: excludePatterns,\n        followSymlinks,\n      })\n    ) {\n      if (\n        walkEntry.path !== walkInfo.path &&\n        walkEntry.name.match(globPattern)\n      ) {\n        yield walkEntry;\n      }\n    }\n  }\n\n  let currentMatches: WalkEntry[] = [fixedRootInfo];\n  for (const segment of segments) {\n    // Advancing the list of current matches may introduce duplicates, so we\n    // pass everything through this Map.\n    const nextMatchMap: Map<string, WalkEntry> = new Map();\n    await Promise.all(\n      currentMatches.map(async (currentMatch) => {\n        for await (const nextMatch of advanceMatch(currentMatch, segment)) {\n          nextMatchMap.set(nextMatch.path, nextMatch);\n        }\n      }),\n    );\n    currentMatches = [...nextMatchMap.values()].sort(comparePath);\n  }\n\n  if (hasTrailingSep) {\n    currentMatches = currentMatches.filter(\n      (entry: WalkEntry): boolean => entry.isDirectory,\n    );\n  }\n  if (!includeDirs) {\n    currentMatches = currentMatches.filter(\n      (entry: WalkEntry): boolean => !entry.isDirectory,\n    );\n  }\n  yield* currentMatches;\n}\n\n/**\n * Returns an iterator that yields each file path matching the given glob\n * pattern. The file paths are relative to the provided `root` directory.\n * If `root` is not provided, the current working directory is used.\n * The `root` directory is not included in the yielded file paths.\n *\n * Requires the `--allow-read` flag.\n *\n * @see {@link https://docs.deno.com/runtime/manual/basics/permissions#file-system-access}\n * for more information on Deno's permissions system.\n *\n * @param glob The glob pattern to expand.\n * @param options Additional options for the expansion.\n *\n * @returns An iterator that yields each walk entry matching the glob pattern.\n *\n * @example Usage\n *\n * File structure:\n * ```\n * folder\n * \u251C\u2500\u2500 script.ts\n * \u2514\u2500\u2500 foo.ts\n * ```\n *\n * ```ts ignore\n * // script.ts\n * import { expandGlobSync } from \"@std/fs/expand-glob\";\n *\n * const entries = [];\n * for (const entry of expandGlobSync(\"*.ts\")) {\n *   entries.push(entry);\n * }\n *\n * entries[0]!.path; // \"/Users/user/folder/script.ts\"\n * entries[0]!.name; // \"script.ts\"\n * entries[0]!.isFile; // false\n * entries[0]!.isDirectory; // true\n * entries[0]!.isSymlink; // false\n *\n * entries[1]!.path; // \"/Users/user/folder/foo.ts\"\n * entries[1]!.name; // \"foo.ts\"\n * entries[1]!.isFile; // true\n * entries[1]!.isDirectory; // false\n * entries[1]!.isSymlink; // false\n * ```\n */\nexport function* expandGlobSync(\n  glob: string | URL,\n  options?: ExpandGlobOptions,\n): IterableIterator<WalkEntry> {\n  let {\n    root,\n    exclude = [],\n    includeDirs = true,\n    extended = true,\n    globstar = true,\n    caseInsensitive = false,\n    followSymlinks = false,\n    canonicalize = true,\n  } = options ?? {};\n\n  const {\n    segments,\n    isAbsolute: isGlobAbsolute,\n    hasTrailingSep,\n    winRoot,\n  } = split(toPathString(glob));\n  root ??= isGlobAbsolute ? winRoot ?? \"/\" : Deno.cwd();\n\n  const globOptions: GlobOptions = { extended, globstar, caseInsensitive };\n  const absRoot = isGlobAbsolute ? root : resolve(root!); // root is always string here\n  const resolveFromRoot = (path: string): string => resolve(absRoot, path);\n  const excludePatterns = exclude\n    .map(resolveFromRoot)\n    .map((s: string): RegExp => globToRegExp(s, globOptions));\n  const shouldInclude = (path: string): boolean =>\n    !excludePatterns.some((p: RegExp): boolean => !!path.match(p));\n\n  let fixedRoot = isGlobAbsolute ? winRoot ?? \"/\" : absRoot;\n  while (segments.length > 0 && !isGlob(segments[0]!)) {\n    const seg = segments.shift()!;\n    fixedRoot = joinGlobs([fixedRoot, seg], globOptions);\n  }\n\n  let fixedRootInfo: WalkEntry;\n  try {\n    fixedRootInfo = createWalkEntrySync(fixedRoot);\n  } catch (error) {\n    return throwUnlessNotFound(error);\n  }\n\n  function* advanceMatch(\n    walkInfo: WalkEntry,\n    globSegment: string,\n  ): IterableIterator<WalkEntry> {\n    if (!walkInfo.isDirectory) {\n      return;\n    } else if (globSegment === \"..\") {\n      const parentPath = joinGlobs([walkInfo.path, \"..\"], globOptions);\n      if (shouldInclude(parentPath)) {\n        return yield createWalkEntrySync(parentPath);\n      }\n      return;\n    } else if (globSegment === \"**\") {\n      return yield* walkSync(walkInfo.path, {\n        skip: excludePatterns,\n        maxDepth: globstar ? Infinity : 1,\n        followSymlinks,\n        canonicalize,\n      });\n    }\n    const globPattern = globToRegExp(globSegment, globOptions);\n    for (\n      const walkEntry of walkSync(walkInfo.path, {\n        maxDepth: 1,\n        skip: excludePatterns,\n        followSymlinks,\n      })\n    ) {\n      if (\n        walkEntry.path !== walkInfo.path &&\n        walkEntry.name.match(globPattern)\n      ) {\n        yield walkEntry;\n      }\n    }\n  }\n\n  let currentMatches: WalkEntry[] = [fixedRootInfo];\n  for (const segment of segments) {\n    // Advancing the list of current matches may introduce duplicates, so we\n    // pass everything through this Map.\n    const nextMatchMap: Map<string, WalkEntry> = new Map();\n    for (const currentMatch of currentMatches) {\n      for (const nextMatch of advanceMatch(currentMatch, segment)) {\n        nextMatchMap.set(nextMatch.path, nextMatch);\n      }\n    }\n    currentMatches = [...nextMatchMap.values()].sort(comparePath);\n  }\n\n  if (hasTrailingSep) {\n    currentMatches = currentMatches.filter(\n      (entry: WalkEntry): boolean => entry.isDirectory,\n    );\n  }\n  if (!includeDirs) {\n    currentMatches = currentMatches.filter(\n      (entry: WalkEntry): boolean => !entry.isDirectory,\n    );\n  }\n  yield* currentMatches;\n}\n", "// Copyright 2018-2025 the Deno authors. MIT license.\n// Copyright the Browserify authors. MIT License.\n\nimport { resolve } from \"jsr:@std/path@^1.0.8/resolve\";\nimport { SEPARATOR } from \"jsr:@std/path@^1.0.8/constants\";\nimport { toPathString } from \"./_to_path_string.ts\";\n\n/**\n * Checks whether `src` is a sub-directory of `dest`.\n *\n * @param src Source file path as a string or URL.\n * @param dest Destination file path as a string or URL.\n * @param sep Path separator. Defaults to `\\\\` for Windows and `/` for other\n * platforms.\n *\n * @returns `true` if `src` is a sub-directory of `dest`, `false` otherwise.\n */\nexport function isSubdir(\n  src: string | URL,\n  dest: string | URL,\n  sep = SEPARATOR,\n): boolean {\n  src = toPathString(src);\n  dest = toPathString(dest);\n\n  if (resolve(src) === resolve(dest)) {\n    return false;\n  }\n\n  const srcArray = src.split(sep);\n  const destArray = dest.split(sep);\n\n  return srcArray.every((current, i) => destArray[i] === current);\n}\n", "// Copyright 2018-2025 the Deno authors. MIT license.\n// Copyright the Browserify authors. MIT License.\n\nimport { resolve } from \"jsr:@std/path@^1.0.8/resolve\";\nimport { toPathString } from \"./_to_path_string.ts\";\n\n/**\n * Checks if two paths are the same.\n *\n * @param src Source file path as a string or URL.\n * @param dest Destination file path as a string or URL.\n *\n * @returns `true` if the paths are the same, `false` otherwise.\n */\nexport function isSamePath(\n  src: string | URL,\n  dest: string | URL,\n): boolean {\n  src = toPathString(src);\n  dest = toPathString(dest);\n\n  return resolve(src) === resolve(dest);\n}\n", "// Copyright 2018-2025 the Deno authors. MIT license.\nimport { isSubdir } from \"./_is_subdir.ts\";\nimport { isSamePath } from \"./_is_same_path.ts\";\n\nconst EXISTS_ERROR = new Deno.errors.AlreadyExists(\"dest already exists.\");\n\n/** Options for {@linkcode move} and {@linkcode moveSync}. */\nexport interface MoveOptions {\n  /**\n   * Whether the destination file should be overwritten if it already exists.\n   *\n   * @default {false}\n   */\n  overwrite?: boolean;\n}\n\n/**\n * Asynchronously moves a file or directory (along with its contents).\n *\n * Requires `--allow-read` and `--allow-write` permissions.\n *\n * @see {@link https://docs.deno.com/runtime/manual/basics/permissions#file-system-access}\n * for more information on Deno's permissions system.\n *\n * @param src The source file or directory as a string or URL.\n * @param dest The destination file or directory as a string or URL.\n * @param options Options for the move operation.\n * @throws {Deno.errors.AlreadyExists} If `dest` already exists and\n * `options.overwrite` is `false`.\n * @throws {Deno.errors.NotSupported} If `src` is a sub-directory of `dest`.\n *\n * @returns A void promise that resolves once the operation completes.\n *\n * @example Basic usage\n * ```ts ignore\n * import { move } from \"@std/fs/move\";\n *\n * await move(\"./foo\", \"./bar\");\n * ```\n *\n * This will move the file or directory at `./foo` to `./bar` without\n * overwriting.\n *\n * @example Overwriting\n * ```ts ignore\n * import { move } from \"@std/fs/move\";\n *\n * await move(\"./foo\", \"./bar\", { overwrite: true });\n * ```\n *\n * This will move the file or directory at `./foo` to `./bar`, overwriting\n * `./bar` if it already exists.\n */\nexport async function move(\n  src: string | URL,\n  dest: string | URL,\n  options?: MoveOptions,\n): Promise<void> {\n  const { overwrite = false } = options ?? {};\n\n  const srcStat = await Deno.stat(src);\n\n  if (\n    srcStat.isDirectory &&\n    (isSubdir(src, dest) || isSamePath(src, dest))\n  ) {\n    throw new Deno.errors.NotSupported(\n      `Cannot move '${src}' to a subdirectory of itself, '${dest}'.`,\n    );\n  }\n\n  if (overwrite) {\n    if (isSamePath(src, dest)) return;\n    try {\n      await Deno.remove(dest, { recursive: true });\n    } catch (error) {\n      if (!(error instanceof Deno.errors.NotFound)) {\n        throw error;\n      }\n    }\n  } else {\n    try {\n      await Deno.lstat(dest);\n      return Promise.reject(EXISTS_ERROR);\n    } catch {\n      // Do nothing...\n    }\n  }\n\n  await Deno.rename(src, dest);\n}\n\n/**\n * Synchronously moves a file or directory (along with its contents).\n *\n * Requires `--allow-read` and `--allow-write` permissions.\n *\n * @see {@link https://docs.deno.com/runtime/manual/basics/permissions#file-system-access}\n * for more information on Deno's permissions system.\n *\n * @param src The source file or directory as a string or URL.\n * @param dest The destination file or directory as a string or URL.\n * @param options Options for the move operation.\n * @throws {Deno.errors.AlreadyExists} If `dest` already exists and\n * `options.overwrite` is `false`.\n * @throws {Deno.errors.NotSupported} If `src` is a sub-directory of `dest`.\n *\n * @returns A void value that returns once the operation completes.\n *\n * @example Basic usage\n * ```ts ignore\n * import { moveSync } from \"@std/fs/move\";\n *\n * moveSync(\"./foo\", \"./bar\");\n * ```\n *\n * This will move the file or directory at `./foo` to `./bar` without\n * overwriting.\n *\n * @example Overwriting\n * ```ts ignore\n * import { moveSync } from \"@std/fs/move\";\n *\n * moveSync(\"./foo\", \"./bar\", { overwrite: true });\n * ```\n *\n * This will move the file or directory at `./foo` to `./bar`, overwriting\n * `./bar` if it already exists.\n */\nexport function moveSync(\n  src: string | URL,\n  dest: string | URL,\n  options?: MoveOptions,\n): void {\n  const { overwrite = false } = options ?? {};\n\n  const srcStat = Deno.statSync(src);\n\n  if (\n    srcStat.isDirectory &&\n    (isSubdir(src, dest) || isSamePath(src, dest))\n  ) {\n    throw new Deno.errors.NotSupported(\n      `Cannot move '${src}' to a subdirectory of itself, '${dest}'.`,\n    );\n  }\n\n  if (overwrite) {\n    if (isSamePath(src, dest)) return;\n    try {\n      Deno.removeSync(dest, { recursive: true });\n    } catch (error) {\n      if (!(error instanceof Deno.errors.NotFound)) {\n        throw error;\n      }\n    }\n  } else {\n    try {\n      Deno.lstatSync(dest);\n      throw EXISTS_ERROR;\n    } catch (error) {\n      if (error === EXISTS_ERROR) {\n        throw error;\n      }\n    }\n  }\n\n  Deno.renameSync(src, dest);\n}\n", "// Copyright 2018-2025 the Deno authors. MIT license.\n\nimport { basename } from \"jsr:@std/path@^1.0.8/basename\";\nimport { join } from \"jsr:@std/path@^1.0.8/join\";\nimport { resolve } from \"jsr:@std/path@^1.0.8/resolve\";\nimport { ensureDir, ensureDirSync } from \"./ensure_dir.ts\";\nimport { getFileInfoType } from \"./_get_file_info_type.ts\";\nimport { toPathString } from \"./_to_path_string.ts\";\nimport { isSubdir } from \"./_is_subdir.ts\";\n\n// deno-lint-ignore no-explicit-any\nconst isWindows = (globalThis as any).Deno?.build.os === \"windows\";\n\n/** Options for {@linkcode copy} and {@linkcode copySync}. */\nexport interface CopyOptions {\n  /**\n   * Whether to overwrite existing file or directory.\n   *\n   * @default {false}\n   */\n  overwrite?: boolean;\n  /**\n   * When `true`, will set last modification and access times to the ones of\n   * the original source files. When `false`, timestamp behavior is\n   * OS-dependent.\n   *\n   * > [!NOTE]\n   * > This option is currently unsupported for symbolic links.\n   *\n   * @default {false}\n   */\n  preserveTimestamps?: boolean;\n}\n\ninterface InternalCopyOptions extends CopyOptions {\n  /** @default {false} */\n  isFolder?: boolean;\n}\n\nfunction assertIsDate(date: Date | null, name: string): asserts date is Date {\n  if (date === null) {\n    throw new Error(`${name} is unavailable`);\n  }\n}\n\nasync function ensureValidCopy(\n  src: string | URL,\n  dest: string | URL,\n  options: InternalCopyOptions,\n): Promise<Deno.FileInfo | undefined> {\n  let destStat: Deno.FileInfo;\n\n  try {\n    destStat = await Deno.lstat(dest);\n  } catch (err) {\n    if (err instanceof Deno.errors.NotFound) {\n      return;\n    }\n    throw err;\n  }\n\n  if (options.isFolder && !destStat.isDirectory) {\n    throw new Error(\n      `Cannot overwrite non-directory '${dest}' with directory '${src}'`,\n    );\n  }\n  if (!options.overwrite) {\n    throw new Deno.errors.AlreadyExists(`'${dest}' already exists.`);\n  }\n\n  return destStat;\n}\n\nfunction ensureValidCopySync(\n  src: string | URL,\n  dest: string | URL,\n  options: InternalCopyOptions,\n): Deno.FileInfo | undefined {\n  let destStat: Deno.FileInfo;\n  try {\n    destStat = Deno.lstatSync(dest);\n  } catch (err) {\n    if (err instanceof Deno.errors.NotFound) {\n      return;\n    }\n    throw err;\n  }\n\n  if (options.isFolder && !destStat.isDirectory) {\n    throw new Error(\n      `Cannot overwrite non-directory '${dest}' with directory '${src}'`,\n    );\n  }\n  if (!options.overwrite) {\n    throw new Deno.errors.AlreadyExists(`'${dest}' already exists`);\n  }\n\n  return destStat;\n}\n\n/* copy file to dest */\nasync function copyFile(\n  src: string | URL,\n  dest: string | URL,\n  options: InternalCopyOptions,\n) {\n  await ensureValidCopy(src, dest, options);\n  await Deno.copyFile(src, dest);\n  if (options.preserveTimestamps) {\n    const statInfo = await Deno.stat(src);\n    assertIsDate(statInfo.atime, \"statInfo.atime\");\n    assertIsDate(statInfo.mtime, \"statInfo.mtime\");\n    await Deno.utime(dest, statInfo.atime, statInfo.mtime);\n  }\n}\n/* copy file to dest synchronously */\nfunction copyFileSync(\n  src: string | URL,\n  dest: string | URL,\n  options: InternalCopyOptions,\n) {\n  ensureValidCopySync(src, dest, options);\n  Deno.copyFileSync(src, dest);\n  if (options.preserveTimestamps) {\n    const statInfo = Deno.statSync(src);\n    assertIsDate(statInfo.atime, \"statInfo.atime\");\n    assertIsDate(statInfo.mtime, \"statInfo.mtime\");\n    Deno.utimeSync(dest, statInfo.atime, statInfo.mtime);\n  }\n}\n\n/* copy symlink to dest */\nasync function copySymLink(\n  src: string | URL,\n  dest: string | URL,\n  options: InternalCopyOptions,\n) {\n  await ensureValidCopy(src, dest, options);\n  const originSrcFilePath = await Deno.readLink(src);\n  const type = getFileInfoType(await Deno.lstat(src));\n  if (isWindows) {\n    await Deno.symlink(originSrcFilePath, dest, {\n      type: type === \"dir\" ? \"dir\" : \"file\",\n    });\n  } else {\n    await Deno.symlink(originSrcFilePath, dest);\n  }\n  if (options.preserveTimestamps) {\n    const statInfo = await Deno.lstat(src);\n    assertIsDate(statInfo.atime, \"statInfo.atime\");\n    assertIsDate(statInfo.mtime, \"statInfo.mtime\");\n    await Deno.utime(dest, statInfo.atime, statInfo.mtime);\n  }\n}\n\n/* copy symlink to dest synchronously */\nfunction copySymlinkSync(\n  src: string | URL,\n  dest: string | URL,\n  options: InternalCopyOptions,\n) {\n  ensureValidCopySync(src, dest, options);\n  const originSrcFilePath = Deno.readLinkSync(src);\n  const type = getFileInfoType(Deno.lstatSync(src));\n  if (isWindows) {\n    Deno.symlinkSync(originSrcFilePath, dest, {\n      type: type === \"dir\" ? \"dir\" : \"file\",\n    });\n  } else {\n    Deno.symlinkSync(originSrcFilePath, dest);\n  }\n\n  if (options.preserveTimestamps) {\n    const statInfo = Deno.lstatSync(src);\n    assertIsDate(statInfo.atime, \"statInfo.atime\");\n    assertIsDate(statInfo.mtime, \"statInfo.mtime\");\n    Deno.utimeSync(dest, statInfo.atime, statInfo.mtime);\n  }\n}\n\n/* copy folder from src to dest. */\nasync function copyDir(\n  src: string | URL,\n  dest: string | URL,\n  options: CopyOptions,\n) {\n  const destStat = await ensureValidCopy(src, dest, {\n    ...options,\n    isFolder: true,\n  });\n\n  if (!destStat) {\n    await ensureDir(dest);\n  }\n\n  if (options.preserveTimestamps) {\n    const srcStatInfo = await Deno.stat(src);\n    assertIsDate(srcStatInfo.atime, \"statInfo.atime\");\n    assertIsDate(srcStatInfo.mtime, \"statInfo.mtime\");\n    await Deno.utime(dest, srcStatInfo.atime, srcStatInfo.mtime);\n  }\n\n  src = toPathString(src);\n  dest = toPathString(dest);\n\n  const promises = [];\n\n  for await (const entry of Deno.readDir(src)) {\n    const srcPath = join(src, entry.name);\n    const destPath = join(dest, basename(srcPath as string));\n    if (entry.isSymlink) {\n      promises.push(copySymLink(srcPath, destPath, options));\n    } else if (entry.isDirectory) {\n      promises.push(copyDir(srcPath, destPath, options));\n    } else if (entry.isFile) {\n      promises.push(copyFile(srcPath, destPath, options));\n    }\n  }\n\n  await Promise.all(promises);\n}\n\n/* copy folder from src to dest synchronously */\nfunction copyDirSync(\n  src: string | URL,\n  dest: string | URL,\n  options: CopyOptions,\n) {\n  const destStat = ensureValidCopySync(src, dest, {\n    ...options,\n    isFolder: true,\n  });\n\n  if (!destStat) {\n    ensureDirSync(dest);\n  }\n\n  if (options.preserveTimestamps) {\n    const srcStatInfo = Deno.statSync(src);\n    assertIsDate(srcStatInfo.atime, \"statInfo.atime\");\n    assertIsDate(srcStatInfo.mtime, \"statInfo.mtime\");\n    Deno.utimeSync(dest, srcStatInfo.atime, srcStatInfo.mtime);\n  }\n\n  src = toPathString(src);\n  dest = toPathString(dest);\n\n  for (const entry of Deno.readDirSync(src)) {\n    const srcPath = join(src, entry.name);\n    const destPath = join(dest, basename(srcPath as string));\n    if (entry.isSymlink) {\n      copySymlinkSync(srcPath, destPath, options);\n    } else if (entry.isDirectory) {\n      copyDirSync(srcPath, destPath, options);\n    } else if (entry.isFile) {\n      copyFileSync(srcPath, destPath, options);\n    }\n  }\n}\n\n/**\n * Asynchronously copy a file or directory (along with its contents), like\n * {@linkcode https://www.ibm.com/docs/en/aix/7.3?topic=c-cp-command#cp__cp_flagr | cp -r}.\n *\n * Both `src` and `dest` must both be a file or directory.\n *\n * Requires `--allow-read` and `--allow-write` permissions.\n *\n * @see {@link https://docs.deno.com/runtime/manual/basics/permissions#file-system-access}\n * for more information on Deno's permissions system.\n *\n * @param src The source file/directory path as a string or URL.\n * @param dest The destination file/directory path as a string or URL.\n * @param options Options for copying.\n *\n * @returns A promise that resolves once the copy operation completes.\n *\n * @example Basic usage\n * ```ts ignore\n * import { copy } from \"@std/fs/copy\";\n *\n * await copy(\"./foo\", \"./bar\");\n * ```\n *\n * This will copy the file or directory at `./foo` to `./bar` without\n * overwriting.\n *\n * @example Overwriting files/directories\n * ```ts ignore\n * import { copy } from \"@std/fs/copy\";\n *\n * await copy(\"./foo\", \"./bar\", { overwrite: true });\n * ```\n *\n * This will copy the file or directory at `./foo` to `./bar` and overwrite\n * any existing files or directories.\n *\n * @example Preserving timestamps\n * ```ts ignore\n * import { copy } from \"@std/fs/copy\";\n *\n * await copy(\"./foo\", \"./bar\", { preserveTimestamps: true });\n * ```\n *\n * This will copy the file or directory at `./foo` to `./bar` and set the\n * last modification and access times to the ones of the original source files.\n */\nexport async function copy(\n  src: string | URL,\n  dest: string | URL,\n  options: CopyOptions = {},\n) {\n  src = resolve(toPathString(src));\n  dest = resolve(toPathString(dest));\n\n  if (src === dest) {\n    throw new Error(\"Source and destination cannot be the same\");\n  }\n\n  const srcStat = await Deno.lstat(src);\n\n  if (srcStat.isDirectory && isSubdir(src, dest)) {\n    throw new Error(\n      `Cannot copy '${src}' to a subdirectory of itself: '${dest}'`,\n    );\n  }\n\n  if (srcStat.isSymlink) {\n    await copySymLink(src, dest, options);\n  } else if (srcStat.isDirectory) {\n    await copyDir(src, dest, options);\n  } else if (srcStat.isFile) {\n    await copyFile(src, dest, options);\n  }\n}\n\n/**\n * Synchronously copy a file or directory (along with its contents), like\n * {@linkcode https://www.ibm.com/docs/en/aix/7.3?topic=c-cp-command#cp__cp_flagr | cp -r}.\n *\n * Both `src` and `dest` must both be a file or directory.\n *\n * Requires `--allow-read` and `--allow-write` permissions.\n *\n * @see {@link https://docs.deno.com/runtime/manual/basics/permissions#file-system-access}\n * for more information on Deno's permissions system.\n *\n * @param src The source file/directory path as a string or URL.\n * @param dest The destination file/directory path as a string or URL.\n * @param options Options for copying.\n *\n * @returns A void value that returns once the copy operation completes.\n *\n * @example Basic usage\n * ```ts ignore\n * import { copySync } from \"@std/fs/copy\";\n *\n * copySync(\"./foo\", \"./bar\");\n * ```\n *\n * This will copy the file or directory at `./foo` to `./bar` without\n * overwriting.\n *\n * @example Overwriting files/directories\n * ```ts ignore\n * import { copySync } from \"@std/fs/copy\";\n *\n * copySync(\"./foo\", \"./bar\", { overwrite: true });\n * ```\n *\n * This will copy the file or directory at `./foo` to `./bar` and overwrite\n * any existing files or directories.\n *\n * @example Preserving timestamps\n * ```ts ignore\n * import { copySync } from \"@std/fs/copy\";\n *\n * copySync(\"./foo\", \"./bar\", { preserveTimestamps: true });\n * ```\n *\n * This will copy the file or directory at `./foo` to `./bar` and set the\n * last modification and access times to the ones of the original source files.\n */\nexport function copySync(\n  src: string | URL,\n  dest: string | URL,\n  options: CopyOptions = {},\n) {\n  src = resolve(toPathString(src));\n  dest = resolve(toPathString(dest));\n\n  if (src === dest) {\n    throw new Error(\"Source and destination cannot be the same\");\n  }\n\n  const srcStat = Deno.lstatSync(src);\n\n  if (srcStat.isDirectory && isSubdir(src, dest)) {\n    throw new Error(\n      `Cannot copy '${src}' to a subdirectory of itself: '${dest}'`,\n    );\n  }\n\n  if (srcStat.isSymlink) {\n    copySymlinkSync(src, dest, options);\n  } else if (srcStat.isDirectory) {\n    copyDirSync(src, dest, options);\n  } else if (srcStat.isFile) {\n    copyFileSync(src, dest, options);\n  }\n}\n", "// Copyright 2018-2025 the Deno authors. MIT license.\n// This module is browser compatible.\n\n/** End-of-line character for POSIX platforms such as macOS and Linux. */\nexport const LF = \"\\n\" as const;\n\n/** End-of-line character for Windows platforms. */\nexport const CRLF = \"\\r\\n\" as const;\n\n/**\n * End-of-line character evaluated for the current platform.\n *\n * @example Usage\n * ```ts ignore\n * import { EOL } from \"@std/fs/eol\";\n *\n * EOL; // \"\\n\" on POSIX platforms and \"\\r\\n\" on Windows\n * ```\n */\nexport const EOL: \"\\n\" | \"\\r\\n\" =\n  // deno-lint-ignore no-explicit-any\n  (globalThis as any).Deno?.build.os === \"windows\" ? CRLF : LF;\n\nconst regDetect = /(?:\\r?\\n)/g;\n\n/**\n * Returns the detected EOL character(s) detected in the input string. If no EOL\n * character is detected, `null` is returned.\n *\n * @param content The input string to detect EOL characters.\n *\n * @returns The detected EOL character(s) or `null` if no EOL character is detected.\n *\n * @example Usage\n * ```ts ignore\n * import { detect } from \"@std/fs/eol\";\n *\n * detect(\"deno\\r\\nis not\\r\\nnode\"); // \"\\r\\n\"\n * detect(\"deno\\nis not\\r\\nnode\"); // \"\\r\\n\"\n * detect(\"deno\\nis not\\nnode\"); // \"\\n\"\n * detect(\"deno is not node\"); // null\n * ```\n */\nexport function detect(content: string): typeof EOL | null {\n  const d = content.match(regDetect);\n  if (!d || d.length === 0) {\n    return null;\n  }\n  const hasCRLF = d.some((x: string): boolean => x === CRLF);\n\n  return hasCRLF ? CRLF : LF;\n}\n\n/**\n * Normalize the input string to the targeted EOL.\n *\n * @param content The input string to normalize.\n * @param eol The EOL character(s) to normalize the input string to.\n *\n * @returns The input string normalized to the targeted EOL.\n *\n * @example Usage\n * ```ts ignore\n * import { LF, format } from \"@std/fs/eol\";\n *\n * const CRLFinput = \"deno\\r\\nis not\\r\\nnode\";\n *\n * format(CRLFinput, LF); // \"deno\\nis not\\nnode\"\n * ```\n */\nexport function format(content: string, eol: typeof EOL): string {\n  return content.replace(regDetect, eol);\n}\n", "// Copyright 2018-2025 the Deno authors. MIT license.\n\n/**\n * Helpers for working with the filesystem.\n *\n * ```ts ignore\n * import { ensureFile, copy, ensureDir, move } from \"@std/fs\";\n *\n * await ensureFile(\"example.txt\");\n *\n * await copy(\"example.txt\", \"example_copy.txt\");\n *\n * await ensureDir(\"subdir\");\n *\n * await move(\"example_copy.txt\", \"subdir/example_copy.txt\");\n * ```\n *\n * @module\n */\n\nexport * from \"./empty_dir.ts\";\nexport * from \"./ensure_dir.ts\";\nexport * from \"./ensure_file.ts\";\nexport * from \"./ensure_link.ts\";\nexport * from \"./ensure_symlink.ts\";\nexport * from \"./exists.ts\";\nexport * from \"./expand_glob.ts\";\nexport * from \"./move.ts\";\nexport * from \"./copy.ts\";\nexport * from \"./walk.ts\";\nexport * from \"./eol.ts\";\n", "// Copyright 2018-2024 the Deno authors. All rights reserved. MIT license.\n// This module is browser compatible.\n\nimport { CHAR_DOT } from \"../_common/constants.ts\";\nimport { assertPath } from \"../_common/assert_path.ts\";\nimport { isPosixPathSeparator } from \"./_util.ts\";\n\n/**\n * Return the extension of the `path` with leading period.\n *\n * @example Usage\n * ```ts\n * import { extname } from \"@std/path/posix/extname\";\n * import { assertEquals } from \"@std/assert\";\n *\n * assertEquals(extname(\"/home/user/Documents/file.ts\"), \".ts\");\n * assertEquals(extname(\"/home/user/Documents/\"), \"\");\n * assertEquals(extname(\"/home/user/Documents/image.png\"), \".png\");\n * ```\n *\n * @example Working with URLs\n *\n * Note: This function doesn't automatically strip hash and query parts from\n * URLs. If your URL contains a hash or query, remove them before passing the\n * URL to the function. This can be done by passing the URL to `new URL(url)`,\n * and setting the `hash` and `search` properties to empty strings.\n *\n * ```ts\n * import { extname } from \"@std/path/posix/extname\";\n * import { assertEquals } from \"@std/assert\";\n *\n * assertEquals(extname(\"https://deno.land/std/path/mod.ts\"), \".ts\");\n * assertEquals(extname(\"https://deno.land/std/path/mod.ts?a=b\"), \".ts?a=b\");\n * assertEquals(extname(\"https://deno.land/std/path/mod.ts#header\"), \".ts#header\");\n * ```\n *\n * Note: If you are working with file URLs,\n * use the new version of `extname` from `@std/path/posix/unstable-extname`.\n *\n * @param path The path to get the extension from.\n * @returns The extension (ex. for `file.ts` returns `.ts`).\n */\nexport function extname(path: string): string {\n  assertPath(path);\n\n  let startDot = -1;\n  let startPart = 0;\n  let end = -1;\n  let matchedSlash = true;\n  // Track the state of characters (if any) we see before our first dot and\n  // after any path separator we find\n  let preDotState = 0;\n  for (let i = path.length - 1; i >= 0; --i) {\n    const code = path.charCodeAt(i);\n    if (isPosixPathSeparator(code)) {\n      // If we reached a path separator that was not part of a set of path\n      // separators at the end of the string, stop now\n      if (!matchedSlash) {\n        startPart = i + 1;\n        break;\n      }\n      continue;\n    }\n    if (end === -1) {\n      // We saw the first non-path separator, mark this as the end of our\n      // extension\n      matchedSlash = false;\n      end = i + 1;\n    }\n    if (code === CHAR_DOT) {\n      // If this is our first dot, mark it as the start of our extension\n      if (startDot === -1) startDot = i;\n      else if (preDotState !== 1) preDotState = 1;\n    } else if (startDot !== -1) {\n      // We saw a non-dot and non-path separator before our dot, so we should\n      // have a good chance at having a non-empty extension\n      preDotState = -1;\n    }\n  }\n\n  if (\n    startDot === -1 ||\n    end === -1 ||\n    // We saw a non-dot character immediately before the dot\n    preDotState === 0 ||\n    // The (right-most) trimmed path component is exactly '..'\n    (preDotState === 1 && startDot === end - 1 && startDot === startPart + 1)\n  ) {\n    return \"\";\n  }\n  return path.slice(startDot, end);\n}\n", "// Copyright 2018-2024 the Deno authors. All rights reserved. MIT license.\n// This module is browser compatible.\n\nimport { CHAR_COLON, CHAR_DOT } from \"../_common/constants.ts\";\nimport { assertPath } from \"../_common/assert_path.ts\";\nimport { isPathSeparator, isWindowsDeviceRoot } from \"./_util.ts\";\n\n/**\n * Return the extension of the `path` with leading period.\n *\n * @example Usage\n * ```ts\n * import { extname } from \"@std/path/windows/extname\";\n * import { assertEquals } from \"@std/assert\";\n *\n * const ext = extname(\"file.ts\");\n * assertEquals(ext, \".ts\");\n * ```\n *\n * Note: If you are working with file URLs,\n * use the new version of `extname` from `@std/path/windows/unstable-extname`.\n *\n * @param path The path to get the extension from.\n * @returns The extension of the `path`.\n */\nexport function extname(path: string): string {\n  assertPath(path);\n\n  let start = 0;\n  let startDot = -1;\n  let startPart = 0;\n  let end = -1;\n  let matchedSlash = true;\n  // Track the state of characters (if any) we see before our first dot and\n  // after any path separator we find\n  let preDotState = 0;\n\n  // Check for a drive letter prefix so as not to mistake the following\n  // path separator as an extra separator at the end of the path that can be\n  // disregarded\n\n  if (\n    path.length >= 2 &&\n    path.charCodeAt(1) === CHAR_COLON &&\n    isWindowsDeviceRoot(path.charCodeAt(0))\n  ) {\n    start = startPart = 2;\n  }\n\n  for (let i = path.length - 1; i >= start; --i) {\n    const code = path.charCodeAt(i);\n    if (isPathSeparator(code)) {\n      // If we reached a path separator that was not part of a set of path\n      // separators at the end of the string, stop now\n      if (!matchedSlash) {\n        startPart = i + 1;\n        break;\n      }\n      continue;\n    }\n    if (end === -1) {\n      // We saw the first non-path separator, mark this as the end of our\n      // extension\n      matchedSlash = false;\n      end = i + 1;\n    }\n    if (code === CHAR_DOT) {\n      // If this is our first dot, mark it as the start of our extension\n      if (startDot === -1) startDot = i;\n      else if (preDotState !== 1) preDotState = 1;\n    } else if (startDot !== -1) {\n      // We saw a non-dot and non-path separator before our dot, so we should\n      // have a good chance at having a non-empty extension\n      preDotState = -1;\n    }\n  }\n\n  if (\n    startDot === -1 ||\n    end === -1 ||\n    // We saw a non-dot character immediately before the dot\n    preDotState === 0 ||\n    // The (right-most) trimmed path component is exactly '..'\n    (preDotState === 1 && startDot === end - 1 && startDot === startPart + 1)\n  ) {\n    return \"\";\n  }\n  return path.slice(startDot, end);\n}\n", "// Copyright 2018-2024 the Deno authors. All rights reserved. MIT license.\n// This module is browser compatible.\n\nimport { isWindows } from \"./_os.ts\";\nimport { extname as posixExtname } from \"./posix/extname.ts\";\nimport { extname as windowsExtname } from \"./windows/extname.ts\";\n/**\n * Return the extension of the path with leading period (\".\").\n *\n * @example Usage\n * ```ts\n * import { extname } from \"@std/path/extname\";\n * import { assertEquals } from \"@std/assert\";\n *\n * if (Deno.build.os === \"windows\") {\n *   assertEquals(extname(\"C:\\\\home\\\\user\\\\Documents\\\\image.png\"), \".png\");\n * } else {\n *   assertEquals(extname(\"/home/user/Documents/image.png\"), \".png\");\n * }\n * ```\n *\n * Note: If you are working with file URLs,\n * use the new version of `extname` from `@std/path/unstable-extname`.\n *\n * @param path Path with extension.\n * @returns The file extension. E.g. returns `.ts` for `file.ts`.\n */\nexport function extname(path: string): string {\n  return isWindows ? windowsExtname(path) : posixExtname(path);\n}\n", "// Copyright 2018-2024 the Deno authors. All rights reserved. MIT license.\n// This module is browser compatible.\n\nimport type { ParsedPath } from \"../types.ts\";\n\nexport function _format(\n  sep: string,\n  pathObject: Partial<ParsedPath>,\n): string {\n  const dir: string | undefined = pathObject.dir || pathObject.root;\n  const base: string = pathObject.base ||\n    (pathObject.name ?? \"\") + (pathObject.ext ?? \"\");\n  if (!dir) return base;\n  if (base === sep) return dir;\n  if (dir === pathObject.root) return dir + base;\n  return dir + sep + base;\n}\n\nexport function assertArg(pathObject: Partial<ParsedPath>) {\n  if (pathObject === null || typeof pathObject !== \"object\") {\n    throw new TypeError(\n      `The \"pathObject\" argument must be of type Object, received type \"${typeof pathObject}\"`,\n    );\n  }\n}\n", "// Copyright 2018-2024 the Deno authors. All rights reserved. MIT license.\n// This module is browser compatible.\n\nimport { _format, assertArg } from \"../_common/format.ts\";\nimport type { ParsedPath } from \"../types.ts\";\n\n/**\n * Generate a path from `ParsedPath` object.\n *\n * @example Usage\n * ```ts\n * import { format } from \"@std/path/posix/format\";\n * import { assertEquals } from \"@std/assert\";\n *\n * const path = format({\n *   root: \"/\",\n *   dir: \"/path/dir\",\n *   base: \"file.txt\",\n *   ext: \".txt\",\n *   name: \"file\"\n * });\n * assertEquals(path, \"/path/dir/file.txt\");\n * ```\n *\n * @param pathObject The path object to format.\n * @returns The formatted path.\n */\nexport function format(pathObject: Partial<ParsedPath>): string {\n  assertArg(pathObject);\n  return _format(\"/\", pathObject);\n}\n", "// Copyright 2018-2024 the Deno authors. All rights reserved. MIT license.\n// This module is browser compatible.\n\nimport { _format, assertArg } from \"../_common/format.ts\";\nimport type { ParsedPath } from \"../types.ts\";\n\n/**\n * Generate a path from `ParsedPath` object.\n *\n * @example Usage\n * ```ts\n * import { format } from \"@std/path/windows/format\";\n * import { assertEquals } from \"@std/assert\";\n *\n * const path = format({\n *   root: \"C:\\\\\",\n *   dir: \"C:\\\\path\\\\dir\",\n *   base: \"file.txt\",\n *   ext: \".txt\",\n *   name: \"file\"\n * });\n * assertEquals(path, \"C:\\\\path\\\\dir\\\\file.txt\");\n * ```\n *\n * @param pathObject The path object to format.\n * @returns The formatted path.\n */\nexport function format(pathObject: Partial<ParsedPath>): string {\n  assertArg(pathObject);\n  return _format(\"\\\\\", pathObject);\n}\n", "// Copyright 2018-2024 the Deno authors. All rights reserved. MIT license.\n// This module is browser compatible.\n\nimport { isWindows } from \"./_os.ts\";\nimport { format as posixFormat } from \"./posix/format.ts\";\nimport { format as windowsFormat } from \"./windows/format.ts\";\nimport type { ParsedPath } from \"./types.ts\";\n\n/**\n * Generate a path from a {@linkcode ParsedPath} object. It does the\n * opposite of {@linkcode https://jsr.io/@std/path/doc/~/parse | parse()}.\n *\n * @example Usage\n * ```ts\n * import { format } from \"@std/path/format\";\n * import { assertEquals } from \"@std/assert\";\n *\n * if (Deno.build.os === \"windows\") {\n *   assertEquals(format({ dir: \"C:\\\\path\\\\to\", base: \"script.ts\" }), \"C:\\\\path\\\\to\\\\script.ts\");\n * } else {\n *   assertEquals(format({ dir: \"/path/to/dir\", base: \"script.ts\" }), \"/path/to/dir/script.ts\");\n * }\n * ```\n *\n * @param pathObject Object with path components.\n * @returns The formatted path.\n */\nexport function format(pathObject: Partial<ParsedPath>): string {\n  return isWindows ? windowsFormat(pathObject) : posixFormat(pathObject);\n}\n", "// Copyright 2018-2024 the Deno authors. All rights reserved. MIT license.\n// This module is browser compatible.\n\nimport { CHAR_DOT } from \"../_common/constants.ts\";\nimport type { ParsedPath } from \"../types.ts\";\nimport { stripTrailingSeparators } from \"../_common/strip_trailing_separators.ts\";\nimport { assertPath } from \"../_common/assert_path.ts\";\nimport { isPosixPathSeparator } from \"./_util.ts\";\n\nexport type { ParsedPath } from \"../types.ts\";\n\n/**\n * Return a `ParsedPath` object of the `path`.\n *\n * @example Usage\n * ```ts\n * import { parse } from \"@std/path/posix/parse\";\n * import { assertEquals } from \"@std/assert\";\n *\n * const path = parse(\"/home/user/file.txt\");\n * assertEquals(path, {\n *   root: \"/\",\n *   dir: \"/home/user\",\n *   base: \"file.txt\",\n *   ext: \".txt\",\n *   name: \"file\"\n * });\n * ```\n *\n * @param path The path to parse.\n * @returns The parsed path object.\n */\nexport function parse(path: string): ParsedPath {\n  assertPath(path);\n\n  const ret: ParsedPath = { root: \"\", dir: \"\", base: \"\", ext: \"\", name: \"\" };\n  if (path.length === 0) return ret;\n  const isAbsolute = isPosixPathSeparator(path.charCodeAt(0));\n  let start: number;\n  if (isAbsolute) {\n    ret.root = \"/\";\n    start = 1;\n  } else {\n    start = 0;\n  }\n  let startDot = -1;\n  let startPart = 0;\n  let end = -1;\n  let matchedSlash = true;\n  let i = path.length - 1;\n\n  // Track the state of characters (if any) we see before our first dot and\n  // after any path separator we find\n  let preDotState = 0;\n\n  // Get non-dir info\n  for (; i >= start; --i) {\n    const code = path.charCodeAt(i);\n    if (isPosixPathSeparator(code)) {\n      // If we reached a path separator that was not part of a set of path\n      // separators at the end of the string, stop now\n      if (!matchedSlash) {\n        startPart = i + 1;\n        break;\n      }\n      continue;\n    }\n    if (end === -1) {\n      // We saw the first non-path separator, mark this as the end of our\n      // extension\n      matchedSlash = false;\n      end = i + 1;\n    }\n    if (code === CHAR_DOT) {\n      // If this is our first dot, mark it as the start of our extension\n      if (startDot === -1) startDot = i;\n      else if (preDotState !== 1) preDotState = 1;\n    } else if (startDot !== -1) {\n      // We saw a non-dot and non-path separator before our dot, so we should\n      // have a good chance at having a non-empty extension\n      preDotState = -1;\n    }\n  }\n\n  if (\n    startDot === -1 ||\n    end === -1 ||\n    // We saw a non-dot character immediately before the dot\n    preDotState === 0 ||\n    // The (right-most) trimmed path component is exactly '..'\n    (preDotState === 1 && startDot === end - 1 && startDot === startPart + 1)\n  ) {\n    if (end !== -1) {\n      if (startPart === 0 && isAbsolute) {\n        ret.base = ret.name = path.slice(1, end);\n      } else {\n        ret.base = ret.name = path.slice(startPart, end);\n      }\n    }\n    // Fallback to '/' in case there is no basename\n    ret.base = ret.base || \"/\";\n  } else {\n    if (startPart === 0 && isAbsolute) {\n      ret.name = path.slice(1, startDot);\n      ret.base = path.slice(1, end);\n    } else {\n      ret.name = path.slice(startPart, startDot);\n      ret.base = path.slice(startPart, end);\n    }\n    ret.ext = path.slice(startDot, end);\n  }\n\n  if (startPart > 0) {\n    ret.dir = stripTrailingSeparators(\n      path.slice(0, startPart - 1),\n      isPosixPathSeparator,\n    );\n  } else if (isAbsolute) ret.dir = \"/\";\n\n  return ret;\n}\n", "// Copyright 2018-2024 the Deno authors. All rights reserved. MIT license.\n// This module is browser compatible.\n\nimport { CHAR_COLON, CHAR_DOT } from \"../_common/constants.ts\";\nimport type { ParsedPath } from \"../types.ts\";\nimport { assertPath } from \"../_common/assert_path.ts\";\nimport { isPathSeparator, isWindowsDeviceRoot } from \"./_util.ts\";\n\nexport type { ParsedPath } from \"../types.ts\";\n\n/**\n * Return a `ParsedPath` object of the `path`.\n *\n * @example Usage\n * ```ts\n * import { parse } from \"@std/path/windows/parse\";\n * import { assertEquals } from \"@std/assert\";\n *\n * const parsed = parse(\"C:\\\\foo\\\\bar\\\\baz.ext\");\n * assertEquals(parsed, {\n *   root: \"C:\\\\\",\n *   dir: \"C:\\\\foo\\\\bar\",\n *   base: \"baz.ext\",\n *   ext: \".ext\",\n *   name: \"baz\",\n * });\n * ```\n *\n * @param path The path to parse.\n * @returns The `ParsedPath` object.\n */\nexport function parse(path: string): ParsedPath {\n  assertPath(path);\n\n  const ret: ParsedPath = { root: \"\", dir: \"\", base: \"\", ext: \"\", name: \"\" };\n\n  const len = path.length;\n  if (len === 0) return ret;\n\n  let rootEnd = 0;\n  let code = path.charCodeAt(0);\n\n  // Try to match a root\n  if (len > 1) {\n    if (isPathSeparator(code)) {\n      // Possible UNC root\n\n      rootEnd = 1;\n      if (isPathSeparator(path.charCodeAt(1))) {\n        // Matched double path separator at beginning\n        let j = 2;\n        let last = j;\n        // Match 1 or more non-path separators\n        for (; j < len; ++j) {\n          if (isPathSeparator(path.charCodeAt(j))) break;\n        }\n        if (j < len && j !== last) {\n          // Matched!\n          last = j;\n          // Match 1 or more path separators\n          for (; j < len; ++j) {\n            if (!isPathSeparator(path.charCodeAt(j))) break;\n          }\n          if (j < len && j !== last) {\n            // Matched!\n            last = j;\n            // Match 1 or more non-path separators\n            for (; j < len; ++j) {\n              if (isPathSeparator(path.charCodeAt(j))) break;\n            }\n            if (j === len) {\n              // We matched a UNC root only\n\n              rootEnd = j;\n            } else if (j !== last) {\n              // We matched a UNC root with leftovers\n\n              rootEnd = j + 1;\n            }\n          }\n        }\n      }\n    } else if (isWindowsDeviceRoot(code)) {\n      // Possible device root\n\n      if (path.charCodeAt(1) === CHAR_COLON) {\n        rootEnd = 2;\n        if (len > 2) {\n          if (isPathSeparator(path.charCodeAt(2))) {\n            if (len === 3) {\n              // `path` contains just a drive root, exit early to avoid\n              // unnecessary work\n              ret.root = ret.dir = path;\n              ret.base = \"\\\\\";\n              return ret;\n            }\n            rootEnd = 3;\n          }\n        } else {\n          // `path` contains just a relative drive root, exit early to avoid\n          // unnecessary work\n          ret.root = ret.dir = path;\n          return ret;\n        }\n      }\n    }\n  } else if (isPathSeparator(code)) {\n    // `path` contains just a path separator, exit early to avoid\n    // unnecessary work\n    ret.root = ret.dir = path;\n    ret.base = \"\\\\\";\n    return ret;\n  }\n\n  if (rootEnd > 0) ret.root = path.slice(0, rootEnd);\n\n  let startDot = -1;\n  let startPart = rootEnd;\n  let end = -1;\n  let matchedSlash = true;\n  let i = path.length - 1;\n\n  // Track the state of characters (if any) we see before our first dot and\n  // after any path separator we find\n  let preDotState = 0;\n\n  // Get non-dir info\n  for (; i >= rootEnd; --i) {\n    code = path.charCodeAt(i);\n    if (isPathSeparator(code)) {\n      // If we reached a path separator that was not part of a set of path\n      // separators at the end of the string, stop now\n      if (!matchedSlash) {\n        startPart = i + 1;\n        break;\n      }\n      continue;\n    }\n    if (end === -1) {\n      // We saw the first non-path separator, mark this as the end of our\n      // extension\n      matchedSlash = false;\n      end = i + 1;\n    }\n    if (code === CHAR_DOT) {\n      // If this is our first dot, mark it as the start of our extension\n      if (startDot === -1) startDot = i;\n      else if (preDotState !== 1) preDotState = 1;\n    } else if (startDot !== -1) {\n      // We saw a non-dot and non-path separator before our dot, so we should\n      // have a good chance at having a non-empty extension\n      preDotState = -1;\n    }\n  }\n\n  if (\n    startDot === -1 ||\n    end === -1 ||\n    // We saw a non-dot character immediately before the dot\n    preDotState === 0 ||\n    // The (right-most) trimmed path component is exactly '..'\n    (preDotState === 1 && startDot === end - 1 && startDot === startPart + 1)\n  ) {\n    if (end !== -1) {\n      ret.base = ret.name = path.slice(startPart, end);\n    }\n  } else {\n    ret.name = path.slice(startPart, startDot);\n    ret.base = path.slice(startPart, end);\n    ret.ext = path.slice(startDot, end);\n  }\n\n  // Fallback to '\\' in case there is no basename\n  ret.base = ret.base || \"\\\\\";\n\n  // If the directory is the root, use the entire root as the `dir` including\n  // the trailing slash if any (`C:\\abc` -> `C:\\`). Otherwise, strip out the\n  // trailing slash (`C:\\abc\\def` -> `C:\\abc`).\n  if (startPart > 0 && startPart !== rootEnd) {\n    ret.dir = path.slice(0, startPart - 1);\n  } else ret.dir = ret.root;\n\n  return ret;\n}\n", "// Copyright 2018-2024 the Deno authors. All rights reserved. MIT license.\n// This module is browser compatible.\n\nimport { isWindows } from \"./_os.ts\";\nimport type { ParsedPath } from \"./types.ts\";\nimport { parse as posixParse } from \"./posix/parse.ts\";\nimport { parse as windowsParse } from \"./windows/parse.ts\";\n\nexport type { ParsedPath } from \"./types.ts\";\n\n/**\n * Return an object containing the parsed components of the path.\n *\n * Use {@linkcode https://jsr.io/@std/path/doc/~/format | format()} to reverse\n * the result.\n *\n * @example Usage\n * ```ts\n * import { parse } from \"@std/path/parse\";\n * import { assertEquals } from \"@std/assert\";\n *\n * if (Deno.build.os === \"windows\") {\n *   const parsedPathObj = parse(\"C:\\\\path\\\\to\\\\script.ts\");\n *   assertEquals(parsedPathObj.root, \"C:\\\\\");\n *   assertEquals(parsedPathObj.dir, \"C:\\\\path\\\\to\");\n *   assertEquals(parsedPathObj.base, \"script.ts\");\n *   assertEquals(parsedPathObj.ext, \".ts\");\n *   assertEquals(parsedPathObj.name, \"script\");\n * } else {\n *   const parsedPathObj = parse(\"/path/to/dir/script.ts\");\n *   parsedPathObj.root; // \"/\"\n *   parsedPathObj.dir; // \"/path/to/dir\"\n *   parsedPathObj.base; // \"script.ts\"\n *   parsedPathObj.ext; // \".ts\"\n *   parsedPathObj.name; // \"script\"\n * }\n * ```\n *\n * @param path Path to process\n * @returns An object with the parsed path components.\n */\nexport function parse(path: string): ParsedPath {\n  return isWindows ? windowsParse(path) : posixParse(path);\n}\n", "// Copyright 2018-2024 the Deno authors. All rights reserved. MIT license.\n// This module is browser compatible.\n\nimport { assertPath } from \"./assert_path.ts\";\n\nexport function assertArgs(from: string, to: string) {\n  assertPath(from);\n  assertPath(to);\n  if (from === to) return \"\";\n}\n", "// Copyright 2018-2024 the Deno authors. All rights reserved. MIT license.\n// This module is browser compatible.\n\nimport { isPosixPathSeparator } from \"./_util.ts\";\nimport { resolve } from \"./resolve.ts\";\nimport { assertArgs } from \"../_common/relative.ts\";\n\n/**\n * Return the relative path from `from` to `to` based on current working directory.\n *\n * If `from` and `to` are the same, return an empty string.\n *\n * @example Usage\n * ```ts\n * import { relative } from \"@std/path/posix/relative\";\n * import { assertEquals } from \"@std/assert\";\n *\n * const path = relative(\"/data/orandea/test/aaa\", \"/data/orandea/impl/bbb\");\n * assertEquals(path, \"../../impl/bbb\");\n * ```\n *\n * @param from The path to start from.\n * @param to The path to reach.\n * @returns The relative path.\n */\nexport function relative(from: string, to: string): string {\n  assertArgs(from, to);\n\n  from = resolve(from);\n  to = resolve(to);\n\n  if (from === to) return \"\";\n\n  // Trim any leading backslashes\n  let fromStart = 1;\n  const fromEnd = from.length;\n  for (; fromStart < fromEnd; ++fromStart) {\n    if (!isPosixPathSeparator(from.charCodeAt(fromStart))) break;\n  }\n  const fromLen = fromEnd - fromStart;\n\n  // Trim any leading backslashes\n  let toStart = 1;\n  const toEnd = to.length;\n  for (; toStart < toEnd; ++toStart) {\n    if (!isPosixPathSeparator(to.charCodeAt(toStart))) break;\n  }\n  const toLen = toEnd - toStart;\n\n  // Compare paths to find the longest common path from root\n  const length = fromLen < toLen ? fromLen : toLen;\n  let lastCommonSep = -1;\n  let i = 0;\n  for (; i <= length; ++i) {\n    if (i === length) {\n      if (toLen > length) {\n        if (isPosixPathSeparator(to.charCodeAt(toStart + i))) {\n          // We get here if `from` is the exact base path for `to`.\n          // For example: from='/foo/bar'; to='/foo/bar/baz'\n          return to.slice(toStart + i + 1);\n        } else if (i === 0) {\n          // We get here if `from` is the root\n          // For example: from='/'; to='/foo'\n          return to.slice(toStart + i);\n        }\n      } else if (fromLen > length) {\n        if (isPosixPathSeparator(from.charCodeAt(fromStart + i))) {\n          // We get here if `to` is the exact base path for `from`.\n          // For example: from='/foo/bar/baz'; to='/foo/bar'\n          lastCommonSep = i;\n        } else if (i === 0) {\n          // We get here if `to` is the root.\n          // For example: from='/foo'; to='/'\n          lastCommonSep = 0;\n        }\n      }\n      break;\n    }\n    const fromCode = from.charCodeAt(fromStart + i);\n    const toCode = to.charCodeAt(toStart + i);\n    if (fromCode !== toCode) break;\n    else if (isPosixPathSeparator(fromCode)) lastCommonSep = i;\n  }\n\n  let out = \"\";\n  // Generate the relative path based on the path difference between `to`\n  // and `from`\n  for (i = fromStart + lastCommonSep + 1; i <= fromEnd; ++i) {\n    if (i === fromEnd || isPosixPathSeparator(from.charCodeAt(i))) {\n      if (out.length === 0) out += \"..\";\n      else out += \"/..\";\n    }\n  }\n\n  // Lastly, append the rest of the destination (`to`) path that comes after\n  // the common path parts\n  if (out.length > 0) return out + to.slice(toStart + lastCommonSep);\n  else {\n    toStart += lastCommonSep;\n    if (isPosixPathSeparator(to.charCodeAt(toStart))) ++toStart;\n    return to.slice(toStart);\n  }\n}\n", "// Copyright 2018-2024 the Deno authors. All rights reserved. MIT license.\n// This module is browser compatible.\n\nimport { CHAR_BACKWARD_SLASH } from \"../_common/constants.ts\";\nimport { resolve } from \"./resolve.ts\";\nimport { assertArgs } from \"../_common/relative.ts\";\n\n/**\n * Return the relative path from `from` to `to` based on current working directory.\n *\n * An example in windws, for instance:\n *  from = 'C:\\\\orandea\\\\test\\\\aaa'\n *  to = 'C:\\\\orandea\\\\impl\\\\bbb'\n * The output of the function should be: '..\\\\..\\\\impl\\\\bbb'\n *\n * @example Usage\n * ```ts\n * import { relative } from \"@std/path/windows/relative\";\n * import { assertEquals } from \"@std/assert\";\n *\n * const relativePath = relative(\"C:\\\\foobar\\\\test\\\\aaa\", \"C:\\\\foobar\\\\impl\\\\bbb\");\n * assertEquals(relativePath, \"..\\\\..\\\\impl\\\\bbb\");\n * ```\n *\n * @param from The path from which to calculate the relative path\n * @param to The path to which to calculate the relative path\n * @returns The relative path from `from` to `to`\n */\nexport function relative(from: string, to: string): string {\n  assertArgs(from, to);\n\n  const fromOrig = resolve(from);\n  const toOrig = resolve(to);\n\n  if (fromOrig === toOrig) return \"\";\n\n  from = fromOrig.toLowerCase();\n  to = toOrig.toLowerCase();\n\n  if (from === to) return \"\";\n\n  // Trim any leading backslashes\n  let fromStart = 0;\n  let fromEnd = from.length;\n  for (; fromStart < fromEnd; ++fromStart) {\n    if (from.charCodeAt(fromStart) !== CHAR_BACKWARD_SLASH) break;\n  }\n  // Trim trailing backslashes (applicable to UNC paths only)\n  for (; fromEnd - 1 > fromStart; --fromEnd) {\n    if (from.charCodeAt(fromEnd - 1) !== CHAR_BACKWARD_SLASH) break;\n  }\n  const fromLen = fromEnd - fromStart;\n\n  // Trim any leading backslashes\n  let toStart = 0;\n  let toEnd = to.length;\n  for (; toStart < toEnd; ++toStart) {\n    if (to.charCodeAt(toStart) !== CHAR_BACKWARD_SLASH) break;\n  }\n  // Trim trailing backslashes (applicable to UNC paths only)\n  for (; toEnd - 1 > toStart; --toEnd) {\n    if (to.charCodeAt(toEnd - 1) !== CHAR_BACKWARD_SLASH) break;\n  }\n  const toLen = toEnd - toStart;\n\n  // Compare paths to find the longest common path from root\n  const length = fromLen < toLen ? fromLen : toLen;\n  let lastCommonSep = -1;\n  let i = 0;\n  for (; i <= length; ++i) {\n    if (i === length) {\n      if (toLen > length) {\n        if (to.charCodeAt(toStart + i) === CHAR_BACKWARD_SLASH) {\n          // We get here if `from` is the exact base path for `to`.\n          // For example: from='C:\\\\foo\\\\bar'; to='C:\\\\foo\\\\bar\\\\baz'\n          return toOrig.slice(toStart + i + 1);\n        } else if (i === 2) {\n          // We get here if `from` is the device root.\n          // For example: from='C:\\\\'; to='C:\\\\foo'\n          return toOrig.slice(toStart + i);\n        }\n      }\n      if (fromLen > length) {\n        if (from.charCodeAt(fromStart + i) === CHAR_BACKWARD_SLASH) {\n          // We get here if `to` is the exact base path for `from`.\n          // For example: from='C:\\\\foo\\\\bar'; to='C:\\\\foo'\n          lastCommonSep = i;\n        } else if (i === 2) {\n          // We get here if `to` is the device root.\n          // For example: from='C:\\\\foo\\\\bar'; to='C:\\\\'\n          lastCommonSep = 3;\n        }\n      }\n      break;\n    }\n    const fromCode = from.charCodeAt(fromStart + i);\n    const toCode = to.charCodeAt(toStart + i);\n    if (fromCode !== toCode) break;\n    else if (fromCode === CHAR_BACKWARD_SLASH) lastCommonSep = i;\n  }\n\n  // We found a mismatch before the first common path separator was seen, so\n  // return the original `to`.\n  if (i !== length && lastCommonSep === -1) {\n    return toOrig;\n  }\n\n  let out = \"\";\n  if (lastCommonSep === -1) lastCommonSep = 0;\n  // Generate the relative path based on the path difference between `to` and\n  // `from`\n  for (i = fromStart + lastCommonSep + 1; i <= fromEnd; ++i) {\n    if (i === fromEnd || from.charCodeAt(i) === CHAR_BACKWARD_SLASH) {\n      if (out.length === 0) out += \"..\";\n      else out += \"\\\\..\";\n    }\n  }\n\n  // Lastly, append the rest of the destination (`to`) path that comes after\n  // the common path parts\n  if (out.length > 0) {\n    return out + toOrig.slice(toStart + lastCommonSep, toEnd);\n  } else {\n    toStart += lastCommonSep;\n    if (toOrig.charCodeAt(toStart) === CHAR_BACKWARD_SLASH) ++toStart;\n    return toOrig.slice(toStart, toEnd);\n  }\n}\n", "// Copyright 2018-2024 the Deno authors. All rights reserved. MIT license.\n// This module is browser compatible.\n\nimport { isWindows } from \"./_os.ts\";\nimport { relative as posixRelative } from \"./posix/relative.ts\";\nimport { relative as windowsRelative } from \"./windows/relative.ts\";\n\n/**\n * Return the relative path from `from` to `to` based on current working\n * directory.\n *\n * @example Usage\n * ```ts\n * import { relative } from \"@std/path/relative\";\n * import { assertEquals } from \"@std/assert\";\n *\n * if (Deno.build.os === \"windows\") {\n *   const path = relative(\"C:\\\\foobar\\\\test\\\\aaa\", \"C:\\\\foobar\\\\impl\\\\bbb\");\n *   assertEquals(path, \"..\\\\..\\\\impl\\\\bbb\");\n * } else {\n *   const path = relative(\"/data/foobar/test/aaa\", \"/data/foobar/impl/bbb\");\n *   assertEquals(path, \"../../impl/bbb\");\n * }\n * ```\n *\n * @param from Path in current working directory.\n * @param to Path in current working directory.\n * @returns The relative path from `from` to `to`.\n */\nexport function relative(from: string, to: string): string {\n  return isWindows ? windowsRelative(from, to) : posixRelative(from, to);\n}\n", "// Copyright 2018-2024 the Deno authors. All rights reserved. MIT license.\n// This module is browser compatible.\n\nconst WHITESPACE_ENCODINGS: Record<string, string> = {\n  \"\\u0009\": \"%09\",\n  \"\\u000A\": \"%0A\",\n  \"\\u000B\": \"%0B\",\n  \"\\u000C\": \"%0C\",\n  \"\\u000D\": \"%0D\",\n  \"\\u0020\": \"%20\",\n};\n\nexport function encodeWhitespace(string: string): string {\n  return string.replaceAll(/[\\s]/g, (c) => {\n    return WHITESPACE_ENCODINGS[c] ?? c;\n  });\n}\n", "// Copyright 2018-2024 the Deno authors. All rights reserved. MIT license.\n// This module is browser compatible.\n\nimport { encodeWhitespace } from \"../_common/to_file_url.ts\";\nimport { isAbsolute } from \"./is_absolute.ts\";\n\n/**\n * Converts a path string to a file URL.\n *\n * @example Usage\n * ```ts\n * import { toFileUrl } from \"@std/path/posix/to-file-url\";\n * import { assertEquals } from \"@std/assert\";\n *\n * assertEquals(toFileUrl(\"/home/foo\"), new URL(\"file:///home/foo\"));\n * assertEquals(toFileUrl(\"/home/foo bar\"), new URL(\"file:///home/foo%20bar\"));\n * ```\n *\n * @param path The path to convert.\n * @returns The file URL.\n */\nexport function toFileUrl(path: string): URL {\n  if (!isAbsolute(path)) {\n    throw new TypeError(`Path must be absolute: received \"${path}\"`);\n  }\n\n  const url = new URL(\"file:///\");\n  url.pathname = encodeWhitespace(\n    path.replace(/%/g, \"%25\").replace(/\\\\/g, \"%5C\"),\n  );\n  return url;\n}\n", "// Copyright 2018-2024 the Deno authors. All rights reserved. MIT license.\n// This module is browser compatible.\n\nimport { encodeWhitespace } from \"../_common/to_file_url.ts\";\nimport { isAbsolute } from \"./is_absolute.ts\";\n\n/**\n * Converts a path string to a file URL.\n *\n * @example Usage\n * ```ts\n * import { toFileUrl } from \"@std/path/windows/to-file-url\";\n * import { assertEquals } from \"@std/assert\";\n *\n * assertEquals(toFileUrl(\"\\\\home\\\\foo\"), new URL(\"file:///home/foo\"));\n * assertEquals(toFileUrl(\"C:\\\\Users\\\\foo\"), new URL(\"file:///C:/Users/foo\"));\n * assertEquals(toFileUrl(\"\\\\\\\\127.0.0.1\\\\home\\\\foo\"), new URL(\"file://127.0.0.1/home/foo\"));\n * ```\n * @param path The path to convert.\n * @returns The file URL.\n */\nexport function toFileUrl(path: string): URL {\n  if (!isAbsolute(path)) {\n    throw new TypeError(`Path must be absolute: received \"${path}\"`);\n  }\n  const [, hostname, pathname] = path.match(\n    /^(?:[/\\\\]{2}([^/\\\\]+)(?=[/\\\\](?:[^/\\\\]|$)))?(.*)/,\n  )!;\n  const url = new URL(\"file:///\");\n  url.pathname = encodeWhitespace(pathname!.replace(/%/g, \"%25\"));\n  if (hostname !== undefined && hostname !== \"localhost\") {\n    url.hostname = hostname;\n    if (!url.hostname) {\n      throw new TypeError(`Invalid hostname: \"${url.hostname}\"`);\n    }\n  }\n  return url;\n}\n", "// Copyright 2018-2024 the Deno authors. All rights reserved. MIT license.\n// This module is browser compatible.\n\nimport { isWindows } from \"./_os.ts\";\nimport { toFileUrl as posixToFileUrl } from \"./posix/to_file_url.ts\";\nimport { toFileUrl as windowsToFileUrl } from \"./windows/to_file_url.ts\";\n\n/**\n * Converts a path string to a file URL.\n *\n * @example Usage\n * ```ts\n * import { toFileUrl } from \"@std/path/to-file-url\";\n * import { assertEquals } from \"@std/assert\";\n *\n * if (Deno.build.os === \"windows\") {\n *   assertEquals(toFileUrl(\"\\\\home\\\\foo\"), new URL(\"file:///home/foo\"));\n *   assertEquals(toFileUrl(\"C:\\\\Users\\\\foo\"), new URL(\"file:///C:/Users/foo\"));\n *   assertEquals(toFileUrl(\"\\\\\\\\127.0.0.1\\\\home\\\\foo\"), new URL(\"file://127.0.0.1/home/foo\"));\n * } else {\n *   assertEquals(toFileUrl(\"/home/foo\"), new URL(\"file:///home/foo\"));\n * }\n * ```\n *\n * @param path Path to convert to file URL.\n * @returns The file URL equivalent to the path.\n */\nexport function toFileUrl(path: string): URL {\n  return isWindows ? windowsToFileUrl(path) : posixToFileUrl(path);\n}\n", "// Copyright 2018-2024 the Deno authors. All rights reserved. MIT license.\n// This module is browser compatible.\n\n/**\n * Converts a path to a namespaced path. This function returns the path as is on posix.\n *\n * @example Usage\n * ```ts\n * import { toNamespacedPath } from \"@std/path/posix/to-namespaced-path\";\n * import { assertEquals } from \"@std/assert\";\n *\n * assertEquals(toNamespacedPath(\"/home/foo\"), \"/home/foo\");\n * ```\n *\n * @param path The path.\n * @returns The namespaced path.\n */\nexport function toNamespacedPath(path: string): string {\n  // Non-op on posix systems\n  return path;\n}\n", "// Copyright 2018-2024 the Deno authors. All rights reserved. MIT license.\n// This module is browser compatible.\n\nimport {\n  CHAR_BACKWARD_SLASH,\n  CHAR_COLON,\n  CHAR_DOT,\n  CHAR_QUESTION_MARK,\n} from \"../_common/constants.ts\";\nimport { isWindowsDeviceRoot } from \"./_util.ts\";\nimport { resolve } from \"./resolve.ts\";\n\n/**\n * Resolves path to a namespace path\n *\n * @example Usage\n * ```ts\n * import { toNamespacedPath } from \"@std/path/windows/to-namespaced-path\";\n * import { assertEquals } from \"@std/assert\";\n *\n * const namespaced = toNamespacedPath(\"C:\\\\foo\\\\bar\");\n * assertEquals(namespaced, \"\\\\\\\\?\\\\C:\\\\foo\\\\bar\");\n * ```\n *\n * @param path The path to resolve to namespaced path\n * @returns The resolved namespaced path\n */\nexport function toNamespacedPath(path: string): string {\n  // Note: this will *probably* throw somewhere.\n  if (typeof path !== \"string\") return path;\n  if (path.length === 0) return \"\";\n\n  const resolvedPath = resolve(path);\n\n  if (resolvedPath.length >= 3) {\n    if (resolvedPath.charCodeAt(0) === CHAR_BACKWARD_SLASH) {\n      // Possible UNC root\n\n      if (resolvedPath.charCodeAt(1) === CHAR_BACKWARD_SLASH) {\n        const code = resolvedPath.charCodeAt(2);\n        if (code !== CHAR_QUESTION_MARK && code !== CHAR_DOT) {\n          // Matched non-long UNC root, convert the path to a long UNC path\n          return `\\\\\\\\?\\\\UNC\\\\${resolvedPath.slice(2)}`;\n        }\n      }\n    } else if (isWindowsDeviceRoot(resolvedPath.charCodeAt(0))) {\n      // Possible device root\n\n      if (\n        resolvedPath.charCodeAt(1) === CHAR_COLON &&\n        resolvedPath.charCodeAt(2) === CHAR_BACKWARD_SLASH\n      ) {\n        // Matched device root, convert the path to a long UNC path\n        return `\\\\\\\\?\\\\${resolvedPath}`;\n      }\n    }\n  }\n\n  return path;\n}\n", "// Copyright 2018-2024 the Deno authors. All rights reserved. MIT license.\n// This module is browser compatible.\n\nimport { isWindows } from \"./_os.ts\";\nimport { toNamespacedPath as posixToNamespacedPath } from \"./posix/to_namespaced_path.ts\";\nimport { toNamespacedPath as windowsToNamespacedPath } from \"./windows/to_namespaced_path.ts\";\n\n/**\n * Resolves path to a namespace path.  This is a no-op on\n * non-windows systems.\n *\n * @example Usage\n * ```ts\n * import { toNamespacedPath } from \"@std/path/to-namespaced-path\";\n * import { assertEquals } from \"@std/assert\";\n *\n * if (Deno.build.os === \"windows\") {\n *   assertEquals(toNamespacedPath(\"C:\\\\foo\\\\bar\"), \"\\\\\\\\?\\\\C:\\\\foo\\\\bar\");\n * } else {\n *   assertEquals(toNamespacedPath(\"/foo/bar\"), \"/foo/bar\");\n * }\n * ```\n *\n * @param path Path to resolve to namespace.\n * @returns The resolved namespace path.\n */\nexport function toNamespacedPath(path: string): string {\n  return isWindows\n    ? windowsToNamespacedPath(path)\n    : posixToNamespacedPath(path);\n}\n", "// Copyright 2018-2024 the Deno authors. All rights reserved. MIT license.\n// This module is browser compatible.\n\nexport function common(paths: string[], sep: string): string {\n  const [first = \"\", ...remaining] = paths;\n  const parts = first.split(sep);\n\n  let endOfPrefix = parts.length;\n  let append = \"\";\n  for (const path of remaining) {\n    const compare = path.split(sep);\n    if (compare.length <= endOfPrefix) {\n      endOfPrefix = compare.length;\n      append = \"\";\n    }\n\n    for (let i = 0; i < endOfPrefix; i++) {\n      if (compare[i] !== parts[i]) {\n        endOfPrefix = i;\n        append = i === 0 ? \"\" : sep;\n        break;\n      }\n    }\n  }\n  return parts.slice(0, endOfPrefix).join(sep) + append;\n}\n", "// Copyright 2018-2024 the Deno authors. All rights reserved. MIT license.\n// This module is browser compatible.\n\nimport { common as _common } from \"./_common/common.ts\";\nimport { SEPARATOR } from \"./constants.ts\";\n\n/**\n * Determines the common path from a set of paths for the given OS.\n *\n * @param paths Paths to search for common path.\n * @returns The common path.\n *\n * @example Usage\n * ```ts\n * import { common } from \"@std/path/common\";\n * import { assertEquals } from \"@std/assert\";\n *\n * if (Deno.build.os === \"windows\") {\n *   const path = common([\n *     \"C:\\\\deno\\\\std\\\\path\\\\mod.ts\",\n *     \"C:\\\\deno\\\\std\\\\fs\\\\mod.ts\"\n *   ]);\n *   assertEquals(path, \"C:\\\\deno\\\\std\\\\\");\n * } else {\n *   const path = common([\n *     \"./deno/std/path/mod.ts\",\n *     \"./deno/std/fs/mod.ts\"\n *   ]);\n *   assertEquals(path, \"./deno/std/\");\n * }\n * ```\n */\nexport function common(paths: string[]): string {\n  return _common(paths, SEPARATOR);\n}\n", "// Copyright 2018-2024 the Deno authors. All rights reserved. MIT license.\n// This module is browser compatible.\n\n/**\n * A parsed path object generated by path.parse() or consumed by path.format().\n *\n * @example\n * ```ts\n * import { parse } from \"@std/path\";\n *\n * const parsedPathObj = parse(\"c:\\\\path\\\\dir\\\\index.html\");\n * parsedPathObj.root; // \"c:\\\\\"\n * parsedPathObj.dir; // \"c:\\\\path\\\\dir\"\n * parsedPathObj.base; // \"index.html\"\n * parsedPathObj.ext; // \".html\"\n * parsedPathObj.name; // \"index\"\n * ```\n */\nexport interface ParsedPath {\n  /**\n   * The root of the path such as '/' or 'c:\\'\n   */\n  root: string;\n  /**\n   * The full directory path of the parent such as '/home/user/dir' or 'c:\\path\\dir'\n   */\n  dir: string;\n  /**\n   * The file name including extension (if any) such as 'index.html'\n   */\n  base: string;\n  /**\n   * The file extension (if any) such as '.html'\n   */\n  ext: string;\n  /**\n   * The file name without extension (if any) such as 'index'\n   */\n  name: string;\n}\n", "// Copyright 2018-2024 the Deno authors. All rights reserved. MIT license.\n// This module is browser compatible.\n\nimport type { GlobOptions } from \"./_common/glob_to_reg_exp.ts\";\nimport { isWindows } from \"./_os.ts\";\nimport { normalizeGlob as posixNormalizeGlob } from \"./posix/normalize_glob.ts\";\nimport {\n  normalizeGlob as windowsNormalizeGlob,\n} from \"./windows/normalize_glob.ts\";\n\nexport type { GlobOptions };\n\n/**\n * Normalizes a glob string.\n *\n * Behaves like\n * {@linkcode https://jsr.io/@std/path/doc/~/normalize | normalize()}, but\n * doesn't collapse \"**\\/..\" when `globstar` is true.\n *\n * @example Usage\n * ```ts\n * import { normalizeGlob } from \"@std/path/normalize-glob\";\n * import { assertEquals } from \"@std/assert\";\n *\n * if (Deno.build.os === \"windows\") {\n *   assertEquals(normalizeGlob(\"foo\\\\bar\\\\..\\\\baz\"), \"foo\\\\baz\");\n *   assertEquals(normalizeGlob(\"foo\\\\**\\\\..\\\\bar\\\\..\\\\baz\", { globstar: true }), \"foo\\\\**\\\\..\\\\baz\");\n * } else {\n *   assertEquals(normalizeGlob(\"foo/bar/../baz\"), \"foo/baz\");\n *   assertEquals(normalizeGlob(\"foo/**\\/../bar/../baz\", { globstar: true }), \"foo/**\\/../baz\");\n * }\n * ```\n *\n * @param glob Glob string to normalize.\n * @param options Glob options.\n * @returns The normalized glob string.\n */\nexport function normalizeGlob(\n  glob: string,\n  options: GlobOptions = {},\n): string {\n  return isWindows\n    ? windowsNormalizeGlob(glob, options)\n    : posixNormalizeGlob(glob, options);\n}\n", "// Copyright 2018-2024 the Deno authors. All rights reserved. MIT license.\n// Copyright the Browserify authors. MIT License.\n// Ported mostly from https://github.com/browserify/path-browserify/\n// This module is browser compatible.\n\n/**\n * Utilities for working with OS-specific file paths.\n *\n * Functions from this module will automatically switch to support the path style\n * of the current OS, either `windows` for Microsoft Windows, or `posix` for\n * every other operating system, eg. Linux, MacOS, BSD etc.\n *\n * To use functions for a specific path style regardless of the current OS\n * import the modules from the platform sub directory instead.\n *\n * Example, for POSIX:\n *\n * ```ts\n * import { fromFileUrl } from \"@std/path/posix/from-file-url\";\n * import { assertEquals } from \"@std/assert\";\n *\n * assertEquals(fromFileUrl(\"file:///home/foo\"), \"/home/foo\");\n * ```\n *\n * Or, for Windows:\n *\n * ```ts\n * import { fromFileUrl } from \"@std/path/windows/from-file-url\";\n * import { assertEquals } from \"@std/assert\";\n *\n * assertEquals(fromFileUrl(\"file:///home/foo\"), \"\\\\home\\\\foo\");\n * ```\n *\n * Functions for working with URLs can be found in\n * {@link ./doc/posix/~ | @std/path/posix}.\n *\n * @module\n */\nexport * from \"./basename.ts\";\nexport * from \"./constants.ts\";\nexport * from \"./dirname.ts\";\nexport * from \"./extname.ts\";\nexport * from \"./format.ts\";\nexport * from \"./from_file_url.ts\";\nexport * from \"./is_absolute.ts\";\nexport * from \"./join.ts\";\nexport * from \"./normalize.ts\";\nexport * from \"./parse.ts\";\nexport * from \"./relative.ts\";\nexport * from \"./resolve.ts\";\nexport * from \"./to_file_url.ts\";\nexport * from \"./to_namespaced_path.ts\";\nexport * from \"./common.ts\";\nexport * from \"./types.ts\";\nexport * from \"./glob_to_regexp.ts\";\nexport * from \"./is_glob.ts\";\nexport * from \"./join_globs.ts\";\nexport * from \"./normalize_glob.ts\";\n", "import * as fs from '@std/fs';\r\nimport * as path from '@std/path';\r\n\r\nexport class FileSystem {\r\n    /**\r\n     * Copy directory with all files into destination.\r\n     * @param pSource - The path to the thing to copy.\r\n     * @param pDestination - The path to the new copy.\r\n     * @param pOverride - If existing files should be overriden.\r\n     */\r\n    public static copyDirectory(pSource: string, pDestination: string, pOverride?: boolean, pOptions?: FileSearchOptions): void {\r\n        const lSourcePath: string = FileSystem.pathToAbsolute(pSource);\r\n        const lDestinationPath: string = FileSystem.pathToAbsolute(pDestination);\r\n\r\n        // Read all files.\r\n        const lSourceFileList: Array<string> = this.findFiles(pSource, pOptions);\r\n\r\n        for (const lSourceFile of lSourceFileList) {\r\n            // Create relative item path. Trim leading slash.\r\n            let lRelativeItemPath: string = lSourceFile.replace(lSourcePath, '');\r\n            lRelativeItemPath = lRelativeItemPath.startsWith('\\\\') ? lRelativeItemPath.substring(1) : lRelativeItemPath;\r\n            lRelativeItemPath = lRelativeItemPath.startsWith('/') ? lRelativeItemPath.substring(1) : lRelativeItemPath;\r\n\r\n            // Remove source path from source file, to append destination path instead of it.\r\n            const lSourceItem: string = lSourceFile;\r\n            const lDestinationItem: string = FileSystem.pathToAbsolute(lDestinationPath, lRelativeItemPath);\r\n\r\n            // File destination status. Check if override.\r\n            const lDestinationExists = FileSystem.exists(lDestinationItem);\r\n            if (!lDestinationExists || pOverride) {\r\n                // Create directory.\r\n                this.createDirectory(path.dirname(lDestinationItem));\r\n\r\n                // Copy file.\r\n                Deno.copyFileSync(lSourceItem, lDestinationItem);\r\n            }\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Copy file to destination.\r\n     * \r\n     * @param pSource - Source file path.\r\n     * @param pDestination - Destination file path.\r\n     */\r\n    public static copyFile(pSource: string, pDestination: string): void {\r\n        Deno.copyFileSync(pSource, pDestination,);\r\n    }\r\n\r\n    /**\r\n     * Create directory.\r\n     * @param pPath - Path.\r\n     */\r\n    public static createDirectory(pPath: string): void {\r\n        Deno.mkdirSync(pPath, { recursive: true });\r\n    }\r\n\r\n    /**\r\n     * Deletes the file at the specified path.\r\n     * \r\n     * @param pPath - The path to the file to be deleted.\r\n     * @throws {Deno.errors.PermissionDenied} If the process lacks permissions to delete the file.\r\n     */\r\n    public static delete(pPath: string): void {\r\n        if (!FileSystem.exists(pPath)) {\r\n            return;\r\n        }\r\n\r\n        Deno.removeSync(pPath);\r\n    }\r\n\r\n    /**\r\n     * Remove directory.\r\n     * @param pPath - Directory path.\r\n     */\r\n    public static deleteDirectory(pPath: string): void {\r\n        Deno.removeSync(pPath, { recursive: true });\r\n    }\r\n\r\n    /**\r\n     * Get directory part of file path.\r\n     * \r\n     * @param pFilePath - File path.\r\n     * \r\n     * @returns - Directory of file.\r\n     */\r\n    public static directoryOfFile(pFilePath: string): string {\r\n        return path.dirname(pFilePath);\r\n    }\r\n\r\n    /**\r\n     * Delete every file and directory inside set directory.\r\n     * @param pPath - Directory path.\r\n     */\r\n    public static emptyDirectory(pPath: string): void {\r\n        // Exit on non esisting directory.\r\n        if (!FileSystem.exists(pPath)) {\r\n            return;\r\n        }\r\n\r\n        // Remove every file and directory inside set directory.\r\n        for (const lFile of Deno.readDirSync(pPath)) {\r\n            const lFilePath: string = FileSystem.pathToAbsolute(pPath, lFile.name);\r\n            Deno.removeSync(lFilePath, { recursive: true });\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Check path or file existance.\r\n     * @param pPath - Path.\r\n     */\r\n    public static exists(pPath: string): boolean {\r\n        try {\r\n            // Throws error if path does not exist.\r\n            Deno.statSync(pPath);\r\n\r\n            return true;\r\n        } catch {\r\n            return false;\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Get file part of file path.\r\n     * \r\n     * @param pPath - File path.\r\n     * \r\n     * @returns - File of path\r\n     */\r\n    public static fileOfPath(pPath: string): string {\r\n        return path.basename(pPath);\r\n    }\r\n\r\n    /**\r\n     * Search files.\r\n     * @param pStartDirectory - Starting directory.\r\n     * @param pOptions - [Optional] Search options\r\n     */\r\n    public static findFiles(pStartDirectory: string, pOptions?: FileSearchOptions): Array<string> {\r\n        // Read configuration.\r\n        const lSearchDepth: number = pOptions?.depth ?? 999;\r\n        const lIncludeFileNameList: Array<string> = pOptions?.include?.fileNames ?? new Array<string>();\r\n        const lIncludeDirectoryList: Array<string> = pOptions?.include?.directories ?? new Array<string>();\r\n        const lIncludeExtensionsList: Array<string> = pOptions?.include?.extensions ?? new Array<string>();\r\n        const lExcludeFileNameList: Array<string> = pOptions?.exclude?.fileNames ?? new Array<string>();\r\n        const lExcludeDirectoryList: Array<string> = pOptions?.exclude?.directories ?? new Array<string>();\r\n        const lExcludeExtensionsList: Array<string> = pOptions?.exclude?.extensions ?? new Array<string>();\r\n        const lSearchDirection: 'reverse' | 'forward' = pOptions?.direction ?? 'forward';\r\n\r\n        // Construct next search options.\r\n        const lNextSearchOptions: FileSearchOptions = {\r\n            depth: lSearchDepth - 1,\r\n            include: {\r\n                fileNames: lIncludeFileNameList,\r\n                directories: lIncludeDirectoryList,\r\n                extensions: lIncludeExtensionsList\r\n            },\r\n            exclude: {\r\n                fileNames: lExcludeFileNameList,\r\n                directories: lExcludeDirectoryList,\r\n                extensions: lExcludeExtensionsList\r\n            },\r\n            direction: lSearchDirection\r\n        };\r\n\r\n        const lAbsoluteStartDirectory = FileSystem.pathToAbsolute(pStartDirectory);\r\n\r\n        // Check if start directory is a directory.\r\n        const lDirectoryStatus = Deno.statSync(lAbsoluteStartDirectory);\r\n        if (!lDirectoryStatus.isDirectory) {\r\n            throw `\"${lAbsoluteStartDirectory}\" is not a directory.`;\r\n        }\r\n\r\n        const lResultList: Array<string> = new Array<string>();\r\n\r\n        // Iterate over all\r\n        for (const lChildItem of Deno.readDirSync(lAbsoluteStartDirectory)) {\r\n            const lItemPath = FileSystem.pathToAbsolute(lAbsoluteStartDirectory, lChildItem.name);\r\n\r\n            // Directory handling.\r\n            if (lChildItem.isDirectory) {\r\n                const lNextDirectoryName = path.parse(lItemPath).name;\r\n\r\n                // Only search in child directory on outside in search.\r\n                if (lSearchDirection !== 'forward') {\r\n                    continue;\r\n                }\r\n\r\n                // Check search depth.\r\n                if ((lSearchDepth - 1) < 0) {\r\n                    continue;\r\n                }\r\n\r\n                // Check directory inclusion.\r\n                if (lIncludeDirectoryList.length > 0 && !lIncludeDirectoryList.includes(lNextDirectoryName)) {\r\n                    continue;\r\n                }\r\n\r\n                // Check directory exclusion.\r\n                if (lExcludeDirectoryList.length > 0 && lExcludeDirectoryList.includes(lNextDirectoryName)) {\r\n                    continue;\r\n                }\r\n\r\n                lResultList.push(...this.findFiles(lItemPath, lNextSearchOptions));\r\n            } else {\r\n                const lFileExtension: string = lChildItem.name.split('.').pop() ?? '';\r\n\r\n                // Check file inclusion. \r\n                if (lIncludeFileNameList.length > 0 && !lIncludeFileNameList.includes(lChildItem.name)) {\r\n                    continue;\r\n                }\r\n\r\n                // Check file extension inclusion.        \r\n                if (lIncludeExtensionsList.length > 0 && !lIncludeExtensionsList.includes(lFileExtension)) {\r\n                    continue;\r\n                }\r\n\r\n                // Check file exclusion. \r\n                if (lExcludeFileNameList.length > 0 && lExcludeFileNameList.includes(lChildItem.name)) {\r\n                    continue;\r\n                }\r\n\r\n                // Check file extension exclusion.\r\n                if (lExcludeExtensionsList.length > 0 && lExcludeExtensionsList.includes(lFileExtension)) {\r\n                    continue;\r\n                }\r\n\r\n                // Add file to results.\r\n                lResultList.push(lItemPath);\r\n            }\r\n        }\r\n\r\n        // Go Backwards on inside out search.\r\n        if (lSearchDirection === 'reverse') {\r\n            const lBackwardsPath: string = FileSystem.directoryOfFile(lAbsoluteStartDirectory);\r\n            const lNextDirectoryName = path.parse(lBackwardsPath).name;\r\n\r\n            // Check search depth.\r\n            if ((lSearchDepth - 1) < 0) {\r\n                return lResultList;\r\n            }\r\n\r\n            // Check directory inclusion.\r\n            if (lIncludeDirectoryList.length > 0 && !lIncludeDirectoryList.includes(lNextDirectoryName)) {\r\n                return lResultList;\r\n            }\r\n\r\n            // Check directory exclusion.\r\n            if (lExcludeDirectoryList.length > 0 && lExcludeDirectoryList.includes(lNextDirectoryName)) {\r\n                return lResultList;\r\n            }\r\n\r\n            // Check if next directory is a root path.\r\n            if (path.parse(lBackwardsPath).root === lBackwardsPath) {\r\n                return lResultList;\r\n            }\r\n\r\n            // Search in parent directory files.\r\n            lResultList.push(...FileSystem.findFiles(lBackwardsPath, lNextSearchOptions));\r\n        }\r\n\r\n        return lResultList;\r\n    }\r\n\r\n    /**\r\n     * Find files by a glob pattern.\r\n     * \r\n     * @param pRootDirectory - Root directory.\r\n     * @param pPattern - Glob pattern.\r\n     */\r\n    public static glob(pRootDirectory: string, pPattern: string): Array<string> {\r\n        const lGlobFiles: Array<fs.WalkEntry> = [...fs.expandGlobSync(pPattern, {\r\n            root: pRootDirectory,\r\n            includeDirs: false,\r\n            globstar: true,\r\n            extended: true,\r\n            caseInsensitive: true,\r\n            followSymlinks: true,\r\n        })];\r\n\r\n        return lGlobFiles.map(pFile => pFile.path);\r\n    }\r\n\r\n    /**\r\n     * Check if directory is empty.\r\n     * @param pPath - Directory.\r\n     */\r\n    public static isEmpty(pPath: string): boolean {\r\n        return Array.from(Deno.readDirSync(pPath)).length === 0;\r\n    }\r\n\r\n    /**\r\n     * Get path information.\r\n     * \r\n     * @param pPath - Path to file.\r\n     * \r\n     * @returns - Information about path. \r\n     */\r\n    public static pathInformation(pPath: string): PathInformation {\r\n        const lParsedPath: path.ParsedPath = path.parse(pPath);\r\n\r\n        // Only check file stats if path exists.\r\n        const lPathStats: { isFile: boolean; isDirectory: boolean; } = { isFile: false, isDirectory: false };\r\n        if (FileSystem.exists(pPath)) {\r\n            const lStats: Deno.FileInfo = Deno.lstatSync(pPath);\r\n            lPathStats.isFile = lStats.isFile;\r\n            lPathStats.isDirectory = lStats.isDirectory;\r\n        }\r\n\r\n        return {\r\n            isDirectory: lPathStats.isDirectory,\r\n            isFile: lPathStats.isFile,\r\n            basename: lParsedPath.base,\r\n            directory: lParsedPath.dir,\r\n            extension: lParsedPath.ext,\r\n            filename: lParsedPath.name,\r\n        };\r\n    }\r\n\r\n    /**\r\n     * Joins and resolves path parts to an absolute path.\r\n     *\r\n     * @param pPathParts - Path parts to join.\r\n     *\r\n     * @returns - Joined absolute path.\r\n     */\r\n    public static pathToAbsolute(...pPathParts: Array<string>): string {\r\n        return path.resolve(...pPathParts);\r\n    }\r\n\r\n    /**\r\n     * Convert an absolute path to a relative path.\r\n     *\r\n     * @param pBasePath - Base path of the relative path.\r\n     * @param pPath - Path to convert to relative.\r\n     *\r\n     * @returns relative path.\r\n     */\r\n    public static pathToRelative(pBasePath: string, pPath: string): string {\r\n        const lRelativePath: string = path.relative(pBasePath, pPath);\r\n        if (lRelativePath.startsWith('.')) {\r\n            return lRelativePath;\r\n        }\r\n\r\n        return `./${path.relative(pBasePath, pPath)}`;\r\n    }\r\n\r\n    /**\r\n     * Read file content.\r\n     * @param pPath - Path to file.\r\n     */\r\n    public static read(pPath: string): string {\r\n        // Create text decoder to decode file data to text.\r\n        const lTextDecoder: TextDecoder = new TextDecoder('utf-8');\r\n\r\n        // Read file data and decode binary to text.\r\n        const lFileData: Uint8Array = Deno.readFileSync(pPath);\r\n        return lTextDecoder.decode(lFileData);\r\n    }\r\n\r\n    /**\r\n     * Read file content.\r\n     * @param pPath - Path to file.\r\n     */\r\n    public static async readAsync(pPath: string): Promise<string> {\r\n        // Create text decoder to decode file data to text.\r\n        const lTextDecoder: TextDecoder = new TextDecoder('utf-8');\r\n\r\n        // Read file data and decode binary to text.\r\n        const lFileData: Uint8Array = await Deno.readFile(pPath);\r\n        return lTextDecoder.decode(lFileData);\r\n    }\r\n\r\n    /**\r\n     * Writes file content.\r\n     * Overrides content.\r\n     *\r\n     * @param pPath - Path to file.\r\n     * @param pContent - File content.\r\n     */\r\n    public static write(pPath: string, pContent: string): void {\r\n        Deno.writeTextFile(pPath, pContent);\r\n    }\r\n\r\n    /**\r\n     * Write binary data to file.\r\n     * @param pPath - Path to file.\r\n     * @param pData - Binary data.\r\n     */\r\n    public static writeBinary(pPath: string, pData: Uint8Array): void {\r\n        Deno.writeFileSync(pPath, pData);\r\n    }\r\n}\r\n\r\nexport type FileSearchOptions = {\r\n    depth?: number;\r\n    include?: {\r\n        /**\r\n         * File names to include without extension.\r\n         */\r\n        fileNames?: Array<string>;\r\n        directories?: Array<string>;\r\n\r\n        /**\r\n         * Extensions without leading dot.\r\n         */\r\n        extensions?: Array<string>;\r\n    },\r\n    exclude?: {\r\n        /**\r\n         * File names to exclude without extension.\r\n         */\r\n        fileNames?: Array<string>;\r\n        directories?: Array<string>;\r\n\r\n        /**\r\n         * Extensions without leading dot.\r\n         */\r\n        extensions?: Array<string>;\r\n    };\r\n    /**\r\n     * Search direction from staring directory.\r\n     * Reverse searches in parent directories instead of child directories.\r\n     * Default: 'forward'\r\n     */\r\n    direction?: 'forward' | 'reverse';\r\n};\r\n\r\nexport type PathInformation = {\r\n    basename: string;\r\n    directory: string;\r\n    extension: string;\r\n    filename: string;\r\n    isDirectory: boolean;\r\n    isFile: boolean;\r\n};", "import type { ICliPackageCommand } from '../cli/i-cli-package-command.interface.ts';\r\nimport type { Project } from '../index.ts';\r\nimport { FileSystem } from '../system/file-system.ts';\r\n\r\nexport class Package {\r\n    /**\r\n     * Convert package name to project name.\r\n     * \r\n     * @param pPackageName - Package name.\r\n     */\r\n    public static nameToId(pPackageName: string): string {\r\n        // Empty packae name.\r\n        if (!pPackageName) {\r\n            return '';\r\n        }\r\n\r\n        // Split packagename by /, -, _ and .\r\n        let lSplitPackageNamePartList: Array<string> = pPackageName.split(/[\\/\\-_\\.]/g);\r\n\r\n        // Remove empty strings and remove any other symbols, anything to lowercase.\r\n        lSplitPackageNamePartList = lSplitPackageNamePartList.filter(pValue => pValue !== '');\r\n        lSplitPackageNamePartList = lSplitPackageNamePartList.map(pValue => pValue.replace(/[^\\w]/g, '').toLowerCase());\r\n\r\n        // Return nothing when nothing is left.\r\n        if (lSplitPackageNamePartList.length === 0) {\r\n            return '';\r\n        }\r\n\r\n        // Convert first letter to uppercase.\r\n        const lLeadingToUppercase = (pValue: string) => {\r\n            return pValue.charAt(0).toUpperCase() + pValue.slice(1);\r\n        };\r\n\r\n        // Pop the first entry and use it as project name.\r\n        let lPackageNameId: string = lLeadingToUppercase(lSplitPackageNamePartList.shift()!);\r\n\r\n        // On empty return result.\r\n        if (lSplitPackageNamePartList.length === 0) {\r\n            return lPackageNameId;\r\n        }\r\n\r\n        // Add next part as project namespace.\r\n        lPackageNameId += `.${lLeadingToUppercase(lSplitPackageNamePartList.shift()!)}`;\r\n\r\n        // On empty return result.\r\n        if (lSplitPackageNamePartList.length === 0) {\r\n            return lPackageNameId;\r\n        }\r\n\r\n        // Append the remaining parts as package name with hyphen.\r\n        lPackageNameId += `.${lSplitPackageNamePartList.map(pValue => lLeadingToUppercase(pValue)).join('_')}`;\r\n\r\n        return lPackageNameId;\r\n    }\r\n\r\n    private readonly mPackageConfiguration: PackageConfigurationFile;\r\n    private readonly mPackageRootPath: string;\r\n    private readonly mProject: Project;\r\n\r\n\r\n    /**\r\n     * Get the package configuration file.\r\n     */\r\n    public get configuration(): PackageConfigurationFile {\r\n        return this.mPackageConfiguration;\r\n    }\r\n\r\n    /**\r\n     * The root directory path of the package.\r\n     */\r\n    public get directory(): string {\r\n        return this.mPackageRootPath;\r\n    }\r\n\r\n    /**\r\n     * Get the package id name.\r\n     */\r\n    public get id(): string {\r\n        return this.mPackageConfiguration.kg.name;\r\n    }\r\n\r\n    /**\r\n     * Get the project this package belongs to.\r\n     */\r\n    public get project(): Project {\r\n        return this.mProject;\r\n    }\r\n\r\n    /**\r\n     * Get the source directory of the package.\r\n     */\r\n    public get sourceDirectory(): string {\r\n        return FileSystem.pathToAbsolute(this.mPackageRootPath, this.mPackageConfiguration.kg.source);\r\n    }\r\n\r\n    /**\r\n     * Get the package version.\r\n     */\r\n    public get version(): string {\r\n        return this.mPackageConfiguration.version;\r\n    }\r\n\r\n    /**\r\n     * Constructor.\r\n     * \r\n     * @param pProject - Project the package belongs to.\r\n     * @param pPackageRootPath - Root path of the package.\r\n     */\r\n    public constructor(pProject: Project, pPackageRootPath: string) {\r\n        this.mProject = pProject;\r\n        this.mPackageRootPath = pPackageRootPath;\r\n\r\n        // Read package json information.\r\n        const lPackageJsonPath: string = FileSystem.pathToAbsolute(pPackageRootPath, 'deno.json');\r\n        if (!FileSystem.exists(lPackageJsonPath)) {\r\n            throw new Error(`Package root path \"${pPackageRootPath}\" has no deno.json file.`);\r\n        }\r\n        const lPackageJsonString: string = FileSystem.read(lPackageJsonPath);\r\n        const lPackageJson: PackageConfigurationFile = (() => {\r\n            try {\r\n                return JSON.parse(lPackageJsonString);\r\n            } catch (pError) {\r\n                throw new Error(`Package \"${pPackageRootPath}\" has an invalid deno.json file. ${pError}`);\r\n            }\r\n        })();\r\n\r\n        // Ignore all packages where kg config is not set.\r\n        if (typeof lPackageJson.name !== 'string') {\r\n            throw new Error(`Package \"${pPackageRootPath}\" has no package name specified.`);\r\n        }\r\n\r\n        // Set package root configuration. Default any missing values.\r\n        this.mPackageConfiguration = lPackageJson;\r\n        // this.mPackageConfiguration.name is allways set. \r\n        this.mPackageConfiguration.version = lPackageJson.version ?? '0.0.0';\r\n        this.mPackageConfiguration.kg = lPackageJson.kg ?? {\r\n            name: Package.nameToId(lPackageJson.name),\r\n            source: './source',\r\n            config: {}\r\n        };\r\n\r\n        // Set unset kg defaults. Allways set updated package id.\r\n        this.mPackageConfiguration.kg.name = Package.nameToId(this.mPackageConfiguration.name);\r\n        this.mPackageConfiguration.kg.source ??= './source';\r\n        this.mPackageConfiguration.kg.config ??= {};\r\n    }\r\n\r\n    /**\r\n     * Write project kg information into deno.json.\r\n     * \r\n     * @param pCommand - Target command.\r\n     */\r\n    public cliConfigurationOf<T>(pCommand: ICliPackageCommand<T>): T {\r\n        // Create instance of package and skip if no configuration is setable.\r\n        if (!pCommand.information.configuration) {\r\n            throw new Error(`Cli package has no configuration.`);\r\n        }\r\n\r\n        // Read configuration key.\r\n        const lCliPackageConfigurationKey: string | undefined = pCommand.information.configuration.name;\r\n\r\n        // Read current available configuration of package.\r\n        const lCurrentConfiguration: Record<string, any> = (() => {\r\n            // Return empty object if no configuration is set.\r\n            if ((this.mPackageConfiguration.kg.config[lCliPackageConfigurationKey] ?? null) === null) {\r\n                return {};\r\n            }\r\n\r\n            // Wrap configuration in object.\r\n            return {\r\n                [lCliPackageConfigurationKey]: this.mPackageConfiguration.kg.config[lCliPackageConfigurationKey]\r\n            };\r\n        })();\r\n\r\n        // Fill in and return default values.\r\n        return this.mergeObjects(lCurrentConfiguration, {\r\n            [lCliPackageConfigurationKey]: pCommand.information.configuration.default\r\n        })[lCliPackageConfigurationKey] as T;\r\n    }\r\n\r\n    /**\r\n     * Write project configuration into deno.json\r\n     */\r\n    public save(): void {\r\n        // Create path to deno.json.\r\n        const lPackageJsonPath: string = FileSystem.pathToAbsolute(this.mPackageRootPath, 'deno.json');\r\n\r\n        // Save deno.json.\r\n        FileSystem.write(lPackageJsonPath, JSON.stringify(this.mPackageConfiguration, null, 4));\r\n    }\r\n\r\n    /**\r\n     * Add and merge new cli configuration data to the package configuration.\r\n     * \r\n     * @param pCommand - Target command.\r\n     * @param pData - New configuration data.\r\n     */\r\n    public setCliConfigurationOf<T>(pCommand: ICliPackageCommand<T>, pData: Partial<T>): void {\r\n        // Create instance of package and skip if no configuration is setable.\r\n        if (!pCommand.information.configuration) {\r\n            throw new Error(`Cli package has no configuration.`);\r\n        }\r\n\r\n        // Read configuration key.\r\n        const lCliPackageConfigurationKey: string | undefined = pCommand.information.configuration.name;\r\n\r\n        // Read current available configuration of package.\r\n        const lCurrentConfiguration: Record<string, any> = (() => {\r\n            // Return empty object if no configuration is set.\r\n            if ((this.mPackageConfiguration.kg.config[lCliPackageConfigurationKey] ?? null) === null) {\r\n                return {};\r\n            }\r\n\r\n            // Wrap configuration in object.\r\n            return {\r\n                [lCliPackageConfigurationKey]: this.mPackageConfiguration.kg.config[lCliPackageConfigurationKey]\r\n            };\r\n        })();\r\n\r\n        // Merge new configuration with the current configuration.\r\n        const lMergedData: T = this.mergeObjects(lCurrentConfiguration, {\r\n            [lCliPackageConfigurationKey]: pData\r\n        })[lCliPackageConfigurationKey] as T;\r\n\r\n        // Set new configuration in package configuration json.\r\n        this.mPackageConfiguration.kg.config[lCliPackageConfigurationKey] = lMergedData;\r\n    }\r\n\r\n    /**\r\n     * Merge two objects together.\r\n     * \r\n     * @param pData - Target object with data that should persist.\r\n     * @param pFillData - Default values that should be filled in.\r\n     * \r\n     * @returns a new object with all values filled in. \r\n     */\r\n    private mergeObjects(pData: Record<string, any>, pFillData: Record<string, any>): Record<string, any> {\r\n        // Value is object.\r\n        const lIsObject = (pValue: any): boolean => {\r\n            return typeof pValue === 'object' && pValue !== null;\r\n        };\r\n\r\n        for (const lKey of Object.keys(pFillData)) {\r\n            const lCurrentValue: any = pData?.[lKey];\r\n            const lDefaultValue: any = pFillData[lKey];\r\n\r\n            if (lIsObject(lDefaultValue) && lIsObject(lCurrentValue)) {\r\n                // Rekursion fill in inner objects.\r\n                this.mergeObjects(lCurrentValue, lDefaultValue);\r\n            } else if (typeof lCurrentValue === 'undefined') {\r\n                // Fill in value.\r\n                pData[lKey] = lDefaultValue;\r\n            } else if (lIsObject(lDefaultValue) !== lIsObject(lCurrentValue)) {\r\n                // Values differ. Update value.\r\n                pData[lKey] = lDefaultValue;\r\n            }\r\n        }\r\n\r\n        return pData;\r\n    };\r\n}\r\n\r\nexport type PackageConfigurationFile = {\r\n    [key: string]: any;\r\n\r\n    name: string;\r\n    version: string;\r\n    kg: PackageRootConfiguration;\r\n};\r\n\r\nexport interface PackageRootConfiguration {\r\n    name: string;\r\n    source: string;\r\n    config: Record<string, any>;\r\n}", "import { CliPackages } from '../cli/cli-packages.ts';\r\nimport { FileSystem } from '../system/file-system.ts';\r\nimport { Package } from './package.ts';\r\n\r\nexport class Project {\r\n    /**\r\n     * Find the project root path by searching for the root package file.\r\n     * \r\n     * @param pCurrentPath - Current path.\r\n     */\r\n    public static findRoot(pCurrentPath: string): string {\r\n        const lAllFiles: Array<string> = FileSystem.findFiles(pCurrentPath, {\r\n            direction: 'reverse',\r\n            include: {\r\n                fileNames: ['deno.json'],\r\n                extensions: ['json']\r\n            }\r\n        });\r\n\r\n        // Root directory names.\r\n        const lRootDirectories: Array<string> = new Array<string>();\r\n\r\n        // Load and filter all package files without root set to true.\r\n        for (const lFile of lAllFiles) {\r\n            const lFileContent: string = FileSystem.read(lFile);\r\n            const lPackageJson: ProjectConfigurationFile = JSON.parse(lFileContent);\r\n\r\n            if (lPackageJson.kg?.root === true) {\r\n                lRootDirectories.push(FileSystem.directoryOfFile(lFile));\r\n            }\r\n        }\r\n\r\n        // Order root directory names by length where the longest is first and the shortest is last.\r\n        lRootDirectories.sort((pFirst, pSecond) => pSecond.length - pFirst.length);\r\n\r\n        // Return current directory if no root was found.\r\n        if (lRootDirectories.length !== 0) {\r\n            return lRootDirectories[0];\r\n        } else {\r\n            return pCurrentPath;\r\n        }\r\n    }\r\n\r\n    private readonly mCliPackages: CliPackages;\r\n    private readonly mProjectConfiguration: ProjectConfigurationFile;\r\n    private readonly mRootPath: string;\r\n\r\n    /**\r\n     * Cli packages.\r\n     */\r\n    public get cliPackages(): CliPackages {\r\n        return this.mCliPackages;\r\n    }\r\n\r\n    /**\r\n     * Get the package configuration file.\r\n     */\r\n    public get configuration(): ProjectConfigurationFile {\r\n        return this.mProjectConfiguration;\r\n    }\r\n\r\n\r\n    /**\r\n     * Project root path.\r\n     */\r\n    public get directory(): string {\r\n        return this.mRootPath;\r\n    }\r\n\r\n    /**\r\n     * Projects package directory.\r\n     */\r\n    public get packagesDirectory(): string {\r\n        return FileSystem.pathToAbsolute(this.directory, this.mProjectConfiguration.kg.packages);\r\n    }\r\n\r\n    /**\r\n     * Get the project version.\r\n     */\r\n    public get version(): string {\r\n        return this.mProjectConfiguration.version;\r\n    }\r\n\r\n    /**\r\n     * Constructor.\r\n     * \r\n     * @param pCurrentPath - Project root path.\r\n     * @param pDefaultConfiguration - Default configuration for project.\r\n     */\r\n    public constructor(pCurrentPath: string) {\r\n        // Find project root path.\r\n        const lProjectRootPath: string = Project.findRoot(pCurrentPath);\r\n\r\n        // Set project root path and cli packages.\r\n        this.mRootPath = lProjectRootPath;\r\n        this.mCliPackages = new CliPackages(this);\r\n\r\n        // Read project json information.\r\n        const lPackageJsonPath: string = FileSystem.pathToAbsolute(lProjectRootPath, 'deno.json');\r\n        if (!FileSystem.exists(lPackageJsonPath)) {\r\n            throw new Error(`Project root path \"${lProjectRootPath}\" has no deno.json file.`);\r\n        }\r\n        const lPackageJsonString: string = FileSystem.read(lPackageJsonPath);\r\n        const lPackageJson: ProjectConfigurationFile = (() => {\r\n            try {\r\n                return JSON.parse(lPackageJsonString);\r\n            } catch (pError) {\r\n                throw new Error(`Project \"${lProjectRootPath}\" has an invalid deno.json file. ${pError}`);\r\n            }\r\n        })();\r\n\r\n        // Ignore all projects where kg config is not set.\r\n        if (lPackageJson.kg?.root !== true) {\r\n            throw new Error(`Project \"${lProjectRootPath}\" has no kg.root: true specified.`);\r\n        }\r\n\r\n        // Set project root configuration. Default any missing values.\r\n        this.mProjectConfiguration = lPackageJson;\r\n        this.mProjectConfiguration.version ??= '0.0.0';\r\n        this.mProjectConfiguration.workspace = lPackageJson.workspace ?? [];\r\n        this.mProjectConfiguration.kg = lPackageJson.kg ?? {\r\n            root: true,\r\n            packages: './packages',\r\n            cli: []\r\n        };\r\n\r\n        // Set unset kg defaults.\r\n        this.mProjectConfiguration.kg.root ??= true;\r\n        this.mProjectConfiguration.kg.packages ??= './packages';\r\n        this.mProjectConfiguration.kg.cli ??= [];\r\n    }\r\n\r\n    /**\r\n     * Add packages as deno workspace to root project.\r\n     * \r\n     * @param pWorkspaceFolder - Folder name of workspace.\r\n     */\r\n    public addWorkspace(pPackageDirectory: string): void {\r\n        // Convert to a relative path from the workspace root replace double backslashes with single backslashes and leading with a dot slash.\r\n        let lRelativePackageDirectory: string = FileSystem.pathToRelative(this.directory, pPackageDirectory);\r\n        lRelativePackageDirectory = `./${lRelativePackageDirectory.replace(/\\\\/g, '/')}`;\r\n\r\n        // Add new workspace folder.\r\n        this.mProjectConfiguration.workspace.push(lRelativePackageDirectory);\r\n    }\r\n\r\n    /**\r\n     * Read project configuration.\r\n     * @param pName - Project name.\r\n     */\r\n    public getPackage(pName: string): Package {\r\n        // Construct paths.\r\n        const lPackageInformation: Package | null = this.findPackageByName(pName);\r\n        if (lPackageInformation === null) {\r\n            throw `Package \"${pName}\" not found.`;\r\n        }\r\n\r\n        return lPackageInformation;\r\n    }\r\n\r\n    /**\r\n     * Check if package exists.\r\n     * @param pName - Package or project name name.\r\n     */\r\n    public hasPackage(pName: string): boolean {\r\n        const lPackageDirectory: Package | null = this.findPackageByName(pName);\r\n        return lPackageDirectory !== null;\r\n    }\r\n\r\n    /**\r\n     * Read all projects of package.\r\n     */\r\n    public readAllPackages(): Array<Package> {\r\n        // When directory does not exists, no package could exist eighter.\r\n        if (!FileSystem.exists(this.packagesDirectory)) {\r\n            return new Array<Package>();\r\n        }\r\n\r\n        // Search all deno.json files of root workspaces. Exclude node_modules.\r\n        const lAllFiles: Array<string> = FileSystem.findFiles(FileSystem.pathToAbsolute(this.packagesDirectory), {\r\n            depth: 1, // ./packages/{package_name}/deno.json\r\n            include: {\r\n                fileNames: ['deno.json'],\r\n                extensions: ['json']\r\n            },\r\n        });\r\n\r\n        // Create package list.\r\n        const lPackageList: Array<Package> = new Array<Package>();\r\n\r\n        // Search all files.\r\n        for (const lFile of lAllFiles) {\r\n            // Use only the directory of each deno.json file.\r\n            const lPackageDirectory: string = FileSystem.directoryOfFile(lFile);\r\n\r\n            // Create and push package settings.\r\n            lPackageList.push(new Package(this, lPackageDirectory));\r\n        }\r\n\r\n        return lPackageList;\r\n    }\r\n\r\n    /**\r\n     * Save project configuration.\r\n     */\r\n    public save(): void {\r\n        // Create path to deno.json.\r\n        const lPackageJsonPath: string = FileSystem.pathToAbsolute(this.mRootPath, 'deno.json');\r\n\r\n        // Save deno.json.\r\n        FileSystem.write(lPackageJsonPath, JSON.stringify(this.mProjectConfiguration, null, 4));\r\n    }\r\n\r\n    /**\r\n     * Find package information of name. \r\n     * \r\n     * @param pName - Package id name. Can be the package name too.\r\n     * \r\n     * @returns Package information or null if not found.\r\n     */\r\n    private findPackageByName(pName: string): Package | null {\r\n        // Converts package name to id name. When it is already the id name, the convert does nothing.\r\n        const lPackageIdName: string = Package.nameToId(pName);\r\n\r\n        // Read all available packages and find the package with the provided id name.\r\n        const lPackageInformation = this.readAllPackages().find(pPackage => pPackage.id === lPackageIdName);\r\n\r\n        return lPackageInformation ?? null;\r\n    }\r\n}\r\n\r\nexport interface ProjectRootConfiguration {\r\n    root: true;\r\n    packages: string;\r\n    cli: Array<string>;\r\n}\r\n\r\nexport type ProjectConfigurationFile = {\r\n    [key: string]: any;\r\n\r\n    version: string;\r\n    workspace: Array<string>;\r\n    kg: ProjectRootConfiguration;\r\n};", "import { CliCommand } from '../index.ts';\r\nimport { Import } from '../project/import.ts';\r\nimport { Project } from '../project/project.ts';\r\nimport { FileSystem } from '../system/file-system.ts';\r\nimport type { ICliPackageCommand } from './i-cli-package-command.interface.ts';\r\n\r\n/**\r\n * Cli packages. Resolves all available cli packages.\r\n */\r\nexport class CliPackages {\r\n    private readonly mProject: Project;\r\n\r\n    /**\r\n     * Constructor.\r\n     * \r\n     * @param pProject - Project handler.\r\n     */\r\n    public constructor(pProject: Project) {\r\n        this.mProject = pProject;\r\n    }\r\n\r\n    /**\r\n     * Create a new instance of a package command.\r\n     * \r\n     * @param pName - Cli package information.\r\n     * \r\n     * @returns - Cli package command instance. \r\n     */\r\n    public async createCommand(pName: string): Promise<CliCommand> {\r\n        // Read package command.\r\n        const lPackageInformation: CliPackageInformation<CliCommandPackageConfiguration> | null = await this.read<CliCommandPackageConfiguration>(pName, 'command');\r\n        if (lPackageInformation === null) {\r\n            throw new Error(`Cli command package \"${pName}\" could not be found.`);\r\n        }\r\n\r\n        if (!lPackageInformation.configuration.commandEntryClass) {\r\n            throw new Error(`Can't initialize command ${lPackageInformation.configuration.name}. No entry class defined.`);\r\n        }\r\n\r\n        // Catch any create errors for malfunctioning packages.\r\n        const lPackageCommand: ICliPackageCommand = await (async () => {\r\n            try {\r\n                // Import package and get command constructor.\r\n                const lPackageImport: any = await Import.import(lPackageInformation.packageName);\r\n                const lPackageCliCommandConstructor: CliCommandConstructor = lPackageImport[lPackageInformation.configuration.commandEntryClass] as CliCommandConstructor;\r\n\r\n                // Create command instance\r\n                return new lPackageCliCommandConstructor();\r\n            } catch (e) {\r\n                throw new Error(`Can't initialize command ${lPackageInformation.configuration.name}. ${e}`);\r\n            }\r\n        })();\r\n\r\n        // Create new command instance.\r\n        return new CliCommand(this.mProject, lPackageCommand);\r\n    }\r\n\r\n    /**\r\n     * Read information of a cli package.\r\n     * \r\n     * @param pName - Cli command package name.\r\n     * @param pType - Cli command package type.\r\n     * \r\n     * @returns cli package information or null if not found.\r\n     */\r\n    public async read<TTypeValues extends Record<string, any> = object>(pName: string, pType: string): Promise<CliPackageInformation<TTypeValues> | null> {\r\n        // Read all packages with by a name filter.\r\n        const lFoundPackages: Map<string, CliPackageInformation> = await this.readAvailableProjectCommandPackages(pName, pType);\r\n\r\n        // Return found package.\r\n        return lFoundPackages.get(pName) as CliPackageInformation<TTypeValues> ?? null;\r\n    }\r\n\r\n    /**\r\n     * Read information of a cli package.\r\n     * \r\n     * @param pType - Cli command package type.\r\n     * \r\n     * @returns all available cli package informations of the provided type.s  \r\n     */\r\n    public async readAll<TTypeValues extends Record<string, any> = object>(pType?: string): Promise<Array<CliPackageInformation<TTypeValues>>> {\r\n        // Read all packages with by a name filter.\r\n        const lFoundPackages: Map<string, CliPackageInformation> = await this.readAvailableProjectCommandPackages('', pType);\r\n\r\n        // Return found package.\r\n        return [...lFoundPackages.values()] as Array<CliPackageInformation<TTypeValues>>;\r\n    }\r\n\r\n    /**\r\n     * Get all KG_Cli command packages sorted by cli package type.\r\n     * Skip early when the provided package name is found.\r\n     * \r\n     * @param pNameFilter - Filter for package name.\r\n     * \r\n     * @returns Map of available cli packages.\r\n     */\r\n    private async readAvailableProjectCommandPackages(pNameFilter: string, pType?: string): Promise<Map<string, CliPackageInformation>> {\r\n        // Find root of project and read the json.\r\n        const lProjectRoot: string = Project.findRoot(this.mProject.directory);\r\n        const lProjectRootPackageJsonString: string = FileSystem.read(`${lProjectRoot}/deno.json`);\r\n        const lProjectRootPackageJson: any = JSON.parse(lProjectRootPackageJsonString);\r\n\r\n        // Read all available package imports.\r\n        const lPackageImports: Array<string> | undefined = lProjectRootPackageJson['kg']?.['cli'];\r\n\r\n        // Skip when no cli packages are defined.\r\n        if (!lPackageImports) {\r\n            return new Map<string, CliPackageInformation>();\r\n        }\r\n\r\n        // Promise list stored all read processes of each package information.\r\n        const lReadPackageInformationList: Array<Promise<CliPackageInformation>> = new Array<Promise<CliPackageInformation>>();\r\n\r\n        // Read all cli packages in seperate promises.\r\n        for (const lPackageImport of lPackageImports) {\r\n            // Import \"kg-cli.config.json\" from package.\r\n            const lCliConfigFileImportPath: string = `${lPackageImport}/kg-cli.config.json`;\r\n\r\n            // Read cli configuration file as json.\r\n            const lCliPackageInformationPromise: Promise<CliPackageInformation> = Import.importJson(lCliConfigFileImportPath)\r\n                .then(async (pCliConfigFileModule) => {\r\n                    const lCliConfigFile: any = pCliConfigFileModule.default;\r\n\r\n                    // Skip when package type does not match.\r\n                    if (pType && lCliConfigFile.type !== pType) {\r\n                        throw new Error('Package skipped, type does not match.');\r\n                    }\r\n\r\n                    // Skip when package name does not match.\r\n                    if (pNameFilter.trim() !== '' && pNameFilter !== lCliConfigFile.name) {\r\n                        throw new Error('Package skipped, name does not match.');\r\n                    }\r\n\r\n                    return {\r\n                        packageName: lPackageImport,\r\n                        configuration: lCliConfigFile\r\n                    };\r\n                });\r\n\r\n            lReadPackageInformationList.push(lCliPackageInformationPromise);\r\n        }\r\n\r\n        // Early resolve the quickest found package when name is filtered.\r\n        if (pNameFilter.trim() !== '') {\r\n            const lFoundPackage: CliPackageInformation = await Promise.any(lReadPackageInformationList);\r\n            return new Map<string, CliPackageInformation>([[lFoundPackage.configuration.name, lFoundPackage]]);\r\n        }\r\n\r\n        // Wait for all packages to be read.\r\n        const lFailablePackagePromiseList: Array<Promise<CliPackageInformation | null>> = lReadPackageInformationList.map(async (pPromise) => {\r\n            return pPromise.catch(() => null);\r\n        });\r\n        const lFoundPackageList: Array<CliPackageInformation | null> = await Promise.all(lFailablePackagePromiseList);\r\n\r\n        // All found cli packages.\r\n        const lCliPackages: Map<string, CliPackageInformation> = new Map<string, CliPackageInformation>();\r\n        for (const lCliPackageInformation of lFoundPackageList) {\r\n            // Filter out all packages that could not be read.\r\n            if (lCliPackageInformation === null) {\r\n                continue;\r\n            }\r\n\r\n            lCliPackages.set(lCliPackageInformation.configuration.name, lCliPackageInformation);\r\n        }\r\n\r\n        return lCliPackages;\r\n    }\r\n}\r\n\r\nexport type CliPackageConfiguration<TTypeValues extends Record<string, any> = object> = TTypeValues & {\r\n    type: string;\r\n    name: string;\r\n};\r\n\r\nexport type CliPackageInformation<TTypeValues extends Record<string, any> = object> = {\r\n    packageName: string;\r\n    configuration: CliPackageConfiguration<TTypeValues>;\r\n};\r\n\r\nexport type CliCommandPackageConfiguration = {\r\n    commandEntryClass: string;\r\n};\r\n\r\ntype CliCommandConstructor = {\r\n    new(): ICliPackageCommand;\r\n};", "export class ProcessContext {\r\n    /**\r\n     * Command parameter of current execution.\r\n     */\r\n    public static get parameters(): Array<string> {\r\n        return Deno.args;\r\n    }\r\n\r\n    /**\r\n     * Current working directory.\r\n     */\r\n    public static get workingDirectory(): string {\r\n        return Deno.cwd();\r\n    }\r\n}", "/**\r\n * Process parameter for starting a new process.\r\n */\r\nexport class ProcessParameter {\r\n    private readonly mCommandList: Array<string>;\r\n    private readonly mWorkingDirectory: string;\r\n    \r\n    /**\r\n     * Get command list.\r\n     */\r\n    public get commandList(): Array<string> {\r\n        return this.mCommandList;\r\n    }\r\n\r\n    /**\r\n     * Get working directory.\r\n     */\r\n    public get workingDirectory(): string {\r\n        return this.mWorkingDirectory;\r\n    }\r\n\r\n    /**\r\n     * Constructor.\r\n     * \r\n     * @param pWorkingDirectory - Working directory.\r\n     * @param pCommands - Command list.\r\n     */\r\n    public constructor(pWorkingDirectory: string, pCommands: Array<string>) {\r\n        this.mWorkingDirectory = pWorkingDirectory;\r\n        this.mCommandList = pCommands;\r\n    }\r\n}", "import type { ProcessParameter } from './process-parameter.ts';\r\n\r\n/**\r\n * Process execution.\r\n * Function to execute commands in a new process and return result.\r\n */\r\nexport class Process {\r\n    /**\r\n     * Constructor.\r\n     */\r\n    public constructor() { }\r\n\r\n    /**\r\n     * Call command and return result.\r\n     * \r\n     * @param pCommand - Command.\r\n     * @param pIgnoreError - Ignore error.\r\n     */\r\n    public async execute(pCommand: ProcessParameter, pIgnoreError: boolean = false): Promise<string> {\r\n        // Construct command.\r\n        const lCommand: Deno.Command = new Deno.Command(pCommand.commandList[0], {\r\n            cwd: pCommand.workingDirectory,\r\n            stderr: 'piped',\r\n            stdout: 'piped',\r\n            stdin: 'piped',\r\n            args: pCommand.commandList.slice(1)\r\n        });\r\n\r\n        // Start process.\r\n        const lChildProcess: Deno.ChildProcess = lCommand.spawn();\r\n\r\n        // Wait for process to finish.\r\n        const lProcessOutput: Deno.CommandOutput = await lChildProcess.output();\r\n        const lProcessStatus: Deno.CommandStatus = await lChildProcess.status;\r\n\r\n        // Decode for text output.\r\n        const lTextDecoder = new TextDecoder();\r\n\r\n        // Throw when childprocess has an error.\r\n        if (!lProcessStatus.success && !pIgnoreError) {\r\n            throw new Error(lTextDecoder.decode(lProcessOutput.stderr));\r\n        }\r\n\r\n        // Return output.\r\n        return lTextDecoder.decode(lProcessOutput.stdout);\r\n    }\r\n\r\n    /**\r\n     * Execute command and output result and errors into console.\r\n     * \r\n     * @param pCommand - Command.\r\n     */\r\n    public async executeInConsole(pCommand: ProcessParameter): Promise<void> {\r\n        // Construct command.\r\n        const lCommand: Deno.Command = new Deno.Command(pCommand.commandList[0], {\r\n            cwd: pCommand.workingDirectory,\r\n            stderr: 'inherit',\r\n            stdout: 'inherit',\r\n            stdin: 'inherit',\r\n            args: pCommand.commandList.slice(1)\r\n        });\r\n\r\n        // Start process.\r\n        const lChildProcess: Deno.ChildProcess = lCommand.spawn();\r\n\r\n        // Wait for process to finish.\r\n        const lProcessStatus: Deno.CommandStatus = await lChildProcess.status;\r\n\r\n        // Throw when childprocess has an error.\r\n        if (!lProcessStatus.success) {\r\n            throw new Error();\r\n        }\r\n    }\r\n}", "export class Console {\r\n    /**\r\n     * Constructor.\r\n     */\r\n    public constructor() { }\r\n\r\n    /**\r\n     * Output banner.\r\n     * @param pName - Banner name\r\n     */\r\n    public banner(pName: string): void {\r\n        const lNameLength: number = pName.length;\r\n        const lFilling: string = new Array(lNameLength).fill('-').join('');\r\n\r\n        // Output banner.\r\n        this.writeLine(`// ${lFilling} //`);\r\n        this.writeLine(`// ${pName} //`);\r\n        this.writeLine(`// ${lFilling} //`);\r\n        this.writeLine('');\r\n    }\r\n\r\n    /**\r\n     * Open promt and validate answer.\r\n     * @param pQuestion - Input question. \r\n     * @param pValidationRegex - Validation for input.\r\n     */\r\n    public async promt(pQuestion: string, pValidationRegex: RegExp): Promise<string> {\r\n        // Ask user..\r\n        const lAnswer: string = prompt(pQuestion) ?? '';\r\n\r\n        // Validate answer.\r\n        if (pValidationRegex && !pValidationRegex.test(lAnswer)) {\r\n            // Output error message and retry promt.\r\n            this.writeLine(`Answer musst match ${pValidationRegex.toString()}`);\r\n\r\n            // Reopen promt.\r\n            return this.promt(pQuestion, pValidationRegex);\r\n        } else {\r\n            return lAnswer;\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Output text end with newline.\r\n     * @param pText - Output text. \r\n     */\r\n    public writeLine(pText: string, pColor?: string): void {\r\n        if (pColor) {\r\n            // eslint-disable-next-line no-console\r\n            console.log(`%c${pText}`, `color: ${pColor}`);\r\n        } else {\r\n            // eslint-disable-next-line no-console\r\n            console.log(pText);\r\n        }\r\n    }\r\n}", "export { CliCommand } from './cli/cli-command.ts';\r\nexport { CliPackages, type CliPackageConfiguration, type CliPackageInformation } from './cli/cli-packages.ts';\r\nexport { CliParameter } from './cli/cli-parameter.ts';\r\nexport type { CliCommandDescription, CliCommandDescriptionOptionalParameter, ICliPackageCommand } from './cli/i-cli-package-command.interface.ts';\r\nexport { ProcessContext } from './process/process-context.ts';\r\nexport { ProcessParameter } from './process/process-parameter.ts';\r\nexport { Process } from './process/process.ts';\r\nexport { Import } from './project/import.ts';\r\nexport { Package } from './project/package.ts';\r\nexport { Project } from './project/project.ts';\r\nexport { Console } from './system/console.ts';\r\nexport { FileSystem, type FileSearchOptions, type PathInformation } from './system/file-system.ts';\r\n\r\n", "import { Console } from \"@kartoffelgames/environment-core\";\r\nimport WorkerCode from '../../library/Kartoffelgames.Environment.Test_Package.jsworker';\r\n\r\nnew Console().banner('Hello World!!!');\r\n\r\nconst myWorker = new Worker(WorkerCode);\r\n", "(() => {\n    const socket = new WebSocket('ws://127.0.0.1:8088');\n    socket.addEventListener('open', () => {\n        console.log('Refresh connection established');\n    });\n    socket.addEventListener('message', (event) => {\n        console.log('Bundle finished. Start refresh');\n        if (event.data === 'REFRESH') {\n            window.location.reload();\n        }\n    });\n})();\n(async ()=>{ import('./index.ts'); })();\n"],
  "mappings": "mCAAA,IAOaA,EAPbC,EAAAC,EAAA,KAOaF,EAAN,MAAMG,CAAa,CACtB,OAAwB,mBAAiE,IAAM,CAC3F,IAAMC,EAAgE,IAAI,IAG1E,OAAAA,EAAkB,IAAI,QAAS,CAAE,SAAU,MAAO,UAAW,IAAK,QAAS,IAAK,CAAC,EACjFA,EAAkB,IAAI,KAAM,CAAE,SAAU,MAAO,UAAW,IAAK,QAAS,IAAK,CAAC,EAG9EA,EAAkB,IAAI,YAAa,CAAE,SAAU,UAAW,UAAW,IAAK,QAAS,IAAK,CAAC,EACzFA,EAAkB,IAAI,KAAM,CAAE,SAAU,UAAW,UAAW,IAAK,QAAS,IAAK,CAAC,EAE3EA,CACX,GAAG,EAmBH,OAAc,WAAWC,EAAiCC,EAAyC,CAE/F,GAAIA,EAAW,SAAW,EACtB,MAAM,IAAI,MAAM,4BAA4B,EAIhD,IAAMC,EAAsC,CAAC,GAAGD,CAAU,EAG1D,GAAID,EAAY,YAAY,QAAQ,WAAW,OAASE,EAAqB,MAAM,EAC/E,MAAM,IAAI,MAAM,qDAAqDF,EAAY,YAAY,QAAQ,WAAW,IAAI,IAAI,EAI5H,IAAMG,EAA8B,IAAIL,EAAaE,EAAY,YAAY,QAAQ,WAAW,IAAI,EAGpG,QAAWI,KAAsBJ,EAAY,YAAY,QAAQ,WAAW,UAAY,CAAC,EAAG,CAExF,IAAIK,EAAiCH,EAAqB,MAAM,EAChE,GAAI,CAACG,EACD,KAAM,uBAAuBD,CAAkB,eAInD,GAAIC,EAAW,WAAW,GAAG,EACzB,KAAM,yBAAyBA,CAAU,kDAIzCA,EAAW,WAAW,GAAG,IACzBA,EAAaA,EAAW,UAAU,EAAGA,EAAW,OAAS,CAAC,GAI9DF,EAAc,IAAIC,EAAoBC,CAAU,CACpD,CAGA,IAAMC,EAAkE,IAAI,IAC5E,OAAW,CAACC,EAAwBC,CAAkB,IAAK,OAAO,QAAQR,EAAY,YAAY,QAAQ,WAAW,UAAY,CAAC,CAAC,EAAG,CAClI,IAAMS,EAAgD,CAClD,SAAUF,EACV,UAAWC,EAAmB,WAAa,KAC3C,QAASA,EAAmB,SAAW,IAC3C,EAGAF,EAAoB,IAAI,KAAKC,CAAsB,GAAIE,CAAc,EAGjED,EAAmB,WACnBF,EAAoB,IAAI,IAAIE,EAAmB,SAAS,GAAIC,CAAc,CAElF,CAGA,OAAU,CAACC,EAAsBC,CAAgB,IAAKb,EAAa,kBAAkB,QAAQ,EACzFQ,EAAoB,IAAII,EAAsBC,CAAgB,EAKlE,KAAOT,EAAqB,OAAS,GAAG,CAEpC,IAAMG,EAAqBH,EAAqB,MAAM,EAGtD,GAAI,CAACG,EAAW,WAAW,GAAG,EAC1B,MAAM,IAAI,MAAM,yBAAyBA,CAAU,wDAAwD,EAI/G,GAAM,CAACO,EAAgBC,CAAe,EAAIR,EAAW,MAAM,GAAG,EAGxDG,EAAgEF,EAAoB,IAAIM,CAAc,EAC5G,GAAI,CAACJ,EACD,MAAM,IAAI,MAAM,yBAAyBH,CAAU,8BAA8B,EAGrF,IAAIS,EAAiCD,EAGjCC,GAA0BA,EAAuB,WAAW,GAAG,IAC/DA,EAAyBT,EAAW,UAAU,EAAGA,EAAW,OAAS,CAAC,GAG1EF,EAAc,IAAIK,EAAmB,SAAUM,CAAsB,CACzE,CAGA,OAAW,CAACP,EAAwBC,CAAkB,IAAK,OAAO,QAAQR,EAAY,YAAY,QAAQ,WAAW,UAAY,CAAC,CAAC,EAC1HQ,EAAmB,UAKnBL,EAAc,IAAII,CAAsB,GACzCJ,EAAc,IAAII,EAAwBC,EAAmB,OAAO,GAI5E,OAAOL,CACX,CAWA,OAAc,QAAQF,EAAyC,CAE3D,GAAIA,EAAW,SAAW,EACtB,MAAM,IAAI,MAAM,4BAA4B,EAIhD,IAAMC,EAAsC,CAAC,GAAGD,CAAU,EAGpDc,EAAuBb,EAAqB,MAAM,EAGlDC,EAA8B,IAAIL,EAAaiB,CAAY,EAIjE,KAAOb,EAAqB,OAAS,GAAG,CAEpC,IAAMG,EAAqBH,EAAqB,MAAM,EAGtD,GAAI,CAACG,EAAW,WAAW,GAAG,EAC1B,SAIJ,GAAM,CAACO,EAAgBC,CAAe,EAAIR,EAAW,MAAM,GAAG,EAGxDG,EAAgEV,EAAa,kBAAkB,IAAIc,CAAc,EACvH,GAAI,CAACJ,EACD,SAGJ,IAAIM,EAAiCD,EAGjCC,GAA0BA,EAAuB,WAAW,GAAG,IAC/DA,EAAyBT,EAAW,UAAU,EAAGA,EAAW,OAAS,CAAC,GAG1EF,EAAc,IAAIK,EAAmB,SAAUM,CAAsB,CACzE,CAEA,OAAOX,CACX,CAEiB,YACA,eAKjB,IAAW,eAAwB,CAC/B,OAAO,KAAK,cAChB,CAOO,YAAYa,EAAwB,CACvC,KAAK,eAAiBA,EACtB,KAAK,YAAc,IAAI,GAC3B,CAOO,OAAOC,EAA8B,CACxC,KAAK,YAAY,OAAOA,CAAc,CAC1C,CAeO,IAAIA,EAAgC,CAEvC,GAAI,CAAC,KAAK,IAAIA,CAAc,EACxB,MAAM,IAAI,MAAM,cAAcA,CAAc,kBAAkB,EAIlE,IAAMC,EAAwB,KAAK,YAAY,IAAID,CAAc,EACjE,GAAI,CAACC,EACD,MAAM,IAAI,MAAM,cAAcD,CAAc,iBAAiB,EAGjE,OAAOC,CACX,CAUO,IAAID,EAAiC,CACxC,OAAO,KAAK,YAAY,IAAIA,CAAc,CAC9C,CASO,IAAIA,EAAwBE,EAA6B,CAC5D,KAAK,YAAY,IAAIF,EAAgBE,CAAM,CAC/C,CACJ,IC1RA,IAAAC,GAAAC,EAAA,KAEAC,MCFA,IAAAC,EAAAC,EAAA,QCAA,IAKaC,EALbC,EAAAC,EAAA,KAKaF,EACV,WAAmB,MAAM,MAAM,KAAO,WACtC,WAAmB,WAAW,UAAU,WAAW,KAAK,GACxD,WAAmB,SAAS,UAAU,WAAW,KAAK,GACvD,KCTF,IAAAG,EAAAC,EAAA,QCAA,IAAAC,EAAAC,EAAA,KAGAC,MCHA,IAAAC,EAAAC,EAAA,QCAA,IAAAC,EAAAC,EAAA,KAKAC,MCLA,IAAAC,EAAAC,EAAA,KAKAC,MCLA,IAAAC,EAAAC,EAAA,KAGAD,IACAE,IACAC,MCLA,IAAAC,EAAAC,EAAA,KAGAC,IACAC,MCJA,IAAAC,EAAAC,EAAA,KAKAC,MCLA,IAAAC,EAAAC,EAAA,KAGAD,IACAE,IACAC,IACAC,MCNA,IAAAC,EAAAC,EAAA,KAGAC,IACAC,IACAC,MCLA,IAAAC,EAAAC,EAAA,KAGAC,IACAF,IACAA,MCLA,IAAAG,EAAAC,EAAA,QCAA,IAAAC,GAAAC,EAAA,KAGAD,MCHA,IAAAE,GAAAC,EAAA,KAGAD,MCHA,IAAAE,EAAAC,EAAA,KAGAC,IACAF,KACAA,OCLA,IAAAG,EAAAC,EAAA,KAGAC,MCHA,IAAAC,GAAAC,EAAA,KACAC,IACAC,MCFA,IAAAC,EAAAC,EAAA,QCAA,IAAAC,EAAAC,EAAA,KACAC,MCDA,IAAAC,EAAAC,EAAA,KAGAC,MCHA,IAAAC,EAAAC,EAAA,QCAA,IAAAC,GAAAC,EAAA,KAGAD,IACAE,IACAC,MCLA,IAAAC,GAAAC,EAAA,KAGAD,IACAE,IACAC,IACAC,MCNA,IAAAC,EAAAC,EAAA,KAGAC,IACAF,KACAA,OCLA,IAAAG,GAAAC,EAAA,KACAC,IACAC,IACAC,IACAC,MCJA,IAAAC,GAAAC,EAAA,KACAC,IACAC,IACAC,MCHA,IAAAC,GAAAC,EAAA,KAGAC,IACAC,IACAC,MCLA,IAAAC,EAAAC,EAAA,KAGAC,IACAC,IACAC,IACAC,MCNA,IAAAC,EAAAC,EAAA,KAGAC,IACAF,KACAA,MCLA,IAQMG,GARNC,GAAAC,EAAA,KACAC,IACAC,IACAC,IACAC,IACAC,IAGMP,GAAa,WAAmB,MAAM,MAAM,KAAO,YCRzD,IAAAQ,GAAAC,EAAA,QCAA,IAAAC,GAAAC,EAAA,QCAA,IAAAC,GAAAC,EAAA,KAGAC,OCHA,IAAAC,GAAAC,EAAA,KAGAC,OCHA,IAAAC,GAAAC,EAAA,KAIAC,IAEAF,KACAA,OCPA,IAAAG,GAAAC,EAAA,QCAA,IAAAC,GAAAC,EAAA,KAIAC,IACAC,OCLA,IAAAC,GAAAC,EAAA,KAIAC,IACAC,KACAC,OCNA,IAAAC,GAAAC,EAAA,QCAA,IAAAC,GAAAC,EAAA,KAIAC,IACAC,OCLA,IAAAC,GAAAC,EAAA,KAIAC,IACAC,KACAC,OCNA,IAAAC,GAAAC,EAAA,KAIAC,IACAF,KACAA,OCNA,IAAAG,GAAAC,EAAA,QCAA,IAAAC,GAAAC,EAAA,KAGAC,IACAC,MCJA,IAAAC,GAAAC,EAAA,KAGAC,IACAC,IACAC,MCLA,IAAAC,GAAAC,EAAA,KAGAC,IACAF,KACAA,OCLA,IAAAG,EAAAC,EAAA,KAEAC,MCFA,IAAAC,GAAAC,EAAA,KAGAC,MCHA,IAAAC,GAAAC,EAAA,KAGAD,KAKAE,IACAC,MCTA,IAAAC,GAAAC,EAAA,KAGAD,KAKAE,IACAC,IACAC,MCVA,IAAAC,EAAAC,EAAA,KAGAC,IACAF,KACAA,OCLA,IAAAG,GAAAC,EAAA,KAGAC,IACAF,IACAA,MCLA,IAAAG,GAAAC,EAAA,KAGAC,IACAC,KACAC,MCLA,IAAAC,GAAAC,EAAA,KAIAC,IACAC,IACAC,OCNA,IAkBMC,GAlBNC,GAAAC,EAAA,KACAC,KACAC,KACAC,KACAC,KACAC,IACAC,IACAC,KACAC,IACAC,KASMX,GAAa,WAAmB,MAAM,MAAM,KAAO,YClBzD,IAAAY,GAAAC,EAAA,KAGAC,IACAC,IACAC,MCLA,IAAAC,GAAAC,EAAA,KAGAC,IACAC,MCJA,IAIMC,GAJNC,GAAAC,EAAA,KACAC,KACAC,KAEMJ,GAAe,IAAI,KAAK,OAAO,cAAc,sBAAsB,ICJzE,IAWMK,GAXNC,GAAAC,EAAA,KAEAC,IACAC,IACAC,IACAC,IACAC,IACAC,IACAC,KAGMT,GAAa,WAAmB,MAAM,MAAM,KAAO,YCXzD,IAIaU,GAGAC,GAYAC,GAnBbC,GAAAC,EAAA,KAIaJ,GAAK;AAAA,EAGLC,GAAO;AAAA,EAYPC,GAEV,WAAmB,MAAM,MAAM,KAAO,UAAYD,GAAOD,KCrB5D,IAAAK,GAAAC,EAAA,KAoBAC,KACAC,IACAC,KACAC,KACAC,KACAC,KACAC,KACAC,KACAC,KACAC,KACAC,OC9BA,IAAAC,GAAAC,EAAA,KAGAC,IACAC,IACAC,MCLA,IAAAC,GAAAC,EAAA,KAGAC,IACAC,IACAC,MCLA,IAAAC,GAAAC,EAAA,KAGAC,IACAF,KACAA,OCLA,IAAAG,GAAAC,EAAA,QCAA,IAAAC,GAAAC,EAAA,KAGAD,OCHA,IAAAE,GAAAC,EAAA,KAGAD,OCHA,IAAAE,GAAAC,EAAA,KAGAC,IACAF,KACAA,OCLA,IAAAG,GAAAC,EAAA,KAGAC,IAEAC,IACAC,IACAC,MCPA,IAAAC,GAAAC,EAAA,KAGAC,IAEAC,IACAC,MCNA,IAAAC,GAAAC,EAAA,KAGAC,IAEAF,KACAA,OCNA,IAAAG,GAAAC,EAAA,KAGAC,MCHA,IAAAC,GAAAC,EAAA,KAGAC,IACAC,KACAH,OCLA,IAAAI,GAAAC,EAAA,KAGAC,IACAC,IACAH,OCLA,IAAAI,GAAAC,EAAA,KAGAC,IACAF,KACAA,OCLA,IAAAG,GAAAC,EAAA,QCAA,IAAAC,GAAAC,EAAA,KAGAD,KACAE,OCJA,IAAAC,GAAAC,EAAA,KAGAD,KACAE,OCJA,IAAAC,GAAAC,EAAA,KAGAC,IACAF,KACAA,OCLA,IAAAG,GAAAC,EAAA,QCAA,IAAAC,GAAAC,EAAA,KAGAC,IAMAC,IACAC,MCVA,IAAAC,GAAAC,EAAA,KAGAC,IACAF,KACAA,OCLA,IAAAG,GAAAC,EAAA,QCAA,IAAAC,GAAAC,EAAA,KAGAD,KACAE,MCJA,IAAAC,GAAAC,EAAA,QCAA,IAAAC,GAAAC,EAAA,KAIAC,IACAF,KACAA,OCNA,IAAAG,GAAAC,EAAA,KAsCAC,IACAC,IACAC,IACAC,KACAC,KACAC,IACAC,KACAC,IACAC,KACAC,KACAC,KACAC,IACAC,KACAC,KACAC,KACAC,KACAC,KACAC,KACAC,KACAC,OCzDA,IAAAC,EAAAC,EAAA,KAAAC,KACAA,OCDA,IAAAC,GAAAC,EAAA,KAEAC,MCFA,IAAAC,GAAAC,EAAA,KAAAC,KACAC,IACAC,OCFA,IAAAC,GAAAC,EAAA,KAAAC,KACAC,IACAC,KACAC,MCHA,IAAAC,GAAAC,EAAA,QCAA,IAAAC,GAAAC,EAAA,QCAA,IAAAC,GAAAC,EAAA,QCAA,IAAaC,EAAbC,GAAAC,EAAA,KAAaF,EAAN,KAAc,CAIV,aAAc,CAAE,CAMhB,OAAOG,EAAqB,CAC/B,IAAMC,EAAsBD,EAAM,OAC5BE,EAAmB,IAAI,MAAMD,CAAW,EAAE,KAAK,GAAG,EAAE,KAAK,EAAE,EAGjE,KAAK,UAAU,MAAMC,CAAQ,KAAK,EAClC,KAAK,UAAU,MAAMF,CAAK,KAAK,EAC/B,KAAK,UAAU,MAAME,CAAQ,KAAK,EAClC,KAAK,UAAU,EAAE,CACrB,CAOA,MAAa,MAAMC,EAAmBC,EAA2C,CAE7E,IAAMC,EAAkB,OAAOF,CAAS,GAAK,GAG7C,OAAIC,GAAoB,CAACA,EAAiB,KAAKC,CAAO,GAElD,KAAK,UAAU,sBAAsBD,EAAiB,SAAS,CAAC,EAAE,EAG3D,KAAK,MAAMD,EAAWC,CAAgB,GAEtCC,CAEf,CAMO,UAAUC,EAAeC,EAAuB,CAC/CA,EAEA,QAAQ,IAAI,KAAKD,CAAK,GAAI,UAAUC,CAAM,EAAE,EAG5C,QAAQ,IAAID,CAAK,CAEzB,CACJ,ICvDA,IAAAE,GAAAC,EAAA,KAAAC,KACAC,KACAC,IAEAC,KACAC,KACAC,KACAC,IACAC,KACAC,KACAC,KACAC,M,60GCXA,IAAAC,GAAA,OAKMC,GALNC,GAAAC,EAAA,KAAAD,KACAE,KAEA,IAAIC,EAAQ,EAAE,OAAO,gBAAgB,EAE/BJ,GAAW,IAAI,OAAOK,EAAU,KCLrC,IAAM,CACH,IAAMC,EAAS,IAAI,UAAU,qBAAqB,EAClDA,EAAO,iBAAiB,OAAQ,IAAM,CAClC,QAAQ,IAAI,gCAAgC,CAChD,CAAC,EACDA,EAAO,iBAAiB,UAAYC,GAAU,CAC1C,QAAQ,IAAI,gCAAgC,EACxCA,EAAM,OAAS,WACf,OAAO,SAAS,OAAO,CAE/B,CAAC,CACL,GAAG,GACF,SAAY",
  "names": ["CliParameter", "init_cli_parameter", "__esmMin", "_CliParameter", "lGlobalParameters", "pCliCommand", "pParameter", "lUncheckedParameters", "lCliParameter", "lRequiredParameter", "lParameter", "lOptionalParameters", "lOptionalParameterName", "lOptionalParameter", "lConfiguration", "lGlobalParameterName", "lGlobalParameter", "lParameterName", "lParameterValue", "lClearedParameterValue", "lRootCommand", "pRootParameter", "pParameterName", "lValue", "pValue", "init_cli_command", "__esmMin", "init_cli_parameter", "init_import", "__esmMin", "isWindows", "init_os", "__esmMin", "init_assert_path", "__esmMin", "init_normalize", "__esmMin", "init_assert_path", "init_constants", "__esmMin", "init_normalize_string", "__esmMin", "init_constants", "init_util", "__esmMin", "init_constants", "init_normalize", "__esmMin", "init_normalize_string", "init_util", "init_join", "__esmMin", "init_assert_path", "init_normalize", "init_util", "__esmMin", "init_constants", "init_normalize", "__esmMin", "init_constants", "init_normalize_string", "init_util", "init_join", "__esmMin", "init_assert_path", "init_util", "init_normalize", "init_join", "__esmMin", "init_os", "init_from_file_url", "__esmMin", "init_from_file_url", "__esmMin", "init_from_file_url", "__esmMin", "init_from_file_url", "__esmMin", "init_os", "init_to_path_string", "__esmMin", "init_from_file_url", "init_empty_dir", "__esmMin", "init_join", "init_to_path_string", "init_get_file_info_type", "__esmMin", "init_ensure_dir", "__esmMin", "init_get_file_info_type", "init_dirname", "__esmMin", "init_assert_path", "init_strip_trailing_separators", "__esmMin", "init_dirname", "__esmMin", "init_strip_trailing_separators", "init_util", "init_dirname", "__esmMin", "init_constants", "init_strip_trailing_separators", "init_util", "init_dirname", "__esmMin", "init_os", "init_ensure_file", "__esmMin", "init_dirname", "init_ensure_dir", "init_get_file_info_type", "init_to_path_string", "init_ensure_link", "__esmMin", "init_dirname", "init_ensure_dir", "init_to_path_string", "init_resolve", "__esmMin", "init_normalize_string", "init_assert_path", "init_util", "init_resolve", "__esmMin", "init_constants", "init_normalize_string", "init_assert_path", "init_util", "init_resolve", "__esmMin", "init_os", "isWindows", "init_ensure_symlink", "__esmMin", "init_dirname", "init_resolve", "init_ensure_dir", "init_get_file_info_type", "init_to_path_string", "init_exists", "__esmMin", "init_glob_to_reg_exp", "__esmMin", "init_glob_to_regexp", "__esmMin", "init_glob_to_reg_exp", "init_glob_to_regexp", "__esmMin", "init_glob_to_reg_exp", "init_glob_to_regexp", "__esmMin", "init_os", "init_constants", "__esmMin", "init_normalize_glob", "__esmMin", "init_normalize", "init_constants", "init_join_globs", "__esmMin", "init_join", "init_constants", "init_normalize_glob", "init_constants", "__esmMin", "init_normalize_glob", "__esmMin", "init_normalize", "init_constants", "init_join_globs", "__esmMin", "init_join", "init_constants", "init_normalize_glob", "init_join_globs", "__esmMin", "init_os", "init_is_glob", "__esmMin", "init_is_absolute", "__esmMin", "init_assert_path", "init_util", "init_is_absolute", "__esmMin", "init_constants", "init_assert_path", "init_util", "init_is_absolute", "__esmMin", "init_os", "init_constants", "__esmMin", "init_os", "init_basename", "__esmMin", "init_assert_path", "init_basename", "__esmMin", "init_strip_trailing_separators", "init_util", "init_basename", "__esmMin", "init_constants", "init_strip_trailing_separators", "init_util", "init_basename", "__esmMin", "init_os", "init_normalize", "__esmMin", "init_os", "init_create_walk_entry", "__esmMin", "init_basename", "init_normalize", "init_to_path_string", "init_walk", "__esmMin", "init_join", "init_to_path_string", "init_create_walk_entry", "isWindows", "init_expand_glob", "__esmMin", "init_glob_to_regexp", "init_join_globs", "init_is_glob", "init_is_absolute", "init_resolve", "init_constants", "init_walk", "init_to_path_string", "init_create_walk_entry", "init_is_subdir", "__esmMin", "init_resolve", "init_constants", "init_to_path_string", "init_is_same_path", "__esmMin", "init_resolve", "init_to_path_string", "EXISTS_ERROR", "init_move", "__esmMin", "init_is_subdir", "init_is_same_path", "isWindows", "init_copy", "__esmMin", "init_basename", "init_join", "init_resolve", "init_ensure_dir", "init_get_file_info_type", "init_to_path_string", "init_is_subdir", "LF", "CRLF", "EOL", "init_eol", "__esmMin", "init_mod", "__esmMin", "init_empty_dir", "init_ensure_dir", "init_ensure_file", "init_ensure_link", "init_ensure_symlink", "init_exists", "init_expand_glob", "init_move", "init_copy", "init_walk", "init_eol", "init_extname", "__esmMin", "init_constants", "init_assert_path", "init_util", "init_extname", "__esmMin", "init_constants", "init_assert_path", "init_util", "init_extname", "__esmMin", "init_os", "init_format", "__esmMin", "init_format", "__esmMin", "init_format", "__esmMin", "init_format", "__esmMin", "init_os", "init_parse", "__esmMin", "init_constants", "init_strip_trailing_separators", "init_assert_path", "init_util", "init_parse", "__esmMin", "init_constants", "init_assert_path", "init_util", "init_parse", "__esmMin", "init_os", "init_relative", "__esmMin", "init_assert_path", "init_relative", "__esmMin", "init_util", "init_resolve", "init_relative", "__esmMin", "init_constants", "init_resolve", "init_relative", "__esmMin", "init_os", "init_to_file_url", "__esmMin", "init_to_file_url", "__esmMin", "init_is_absolute", "init_to_file_url", "__esmMin", "init_is_absolute", "init_to_file_url", "__esmMin", "init_os", "init_to_namespaced_path", "__esmMin", "init_to_namespaced_path", "__esmMin", "init_constants", "init_util", "init_resolve", "init_to_namespaced_path", "__esmMin", "init_os", "init_common", "__esmMin", "init_common", "__esmMin", "init_constants", "init_types", "__esmMin", "init_normalize_glob", "__esmMin", "init_os", "init_mod", "__esmMin", "init_basename", "init_constants", "init_dirname", "init_extname", "init_format", "init_from_file_url", "init_is_absolute", "init_join", "init_normalize", "init_parse", "init_relative", "init_resolve", "init_to_file_url", "init_to_namespaced_path", "init_common", "init_types", "init_glob_to_regexp", "init_is_glob", "init_join_globs", "init_normalize_glob", "init_file_system", "__esmMin", "init_mod", "init_package", "__esmMin", "init_file_system", "init_project", "__esmMin", "init_cli_packages", "init_file_system", "init_package", "init_cli_packages", "__esmMin", "init_source", "init_import", "init_project", "init_file_system", "init_process_context", "__esmMin", "init_process_parameter", "__esmMin", "init_process", "__esmMin", "Console", "init_console", "__esmMin", "pName", "lNameLength", "lFilling", "pQuestion", "pValidationRegex", "lAnswer", "pText", "pColor", "init_source", "__esmMin", "init_cli_command", "init_cli_packages", "init_cli_parameter", "init_process_context", "init_process_parameter", "init_process", "init_import", "init_package", "init_project", "init_console", "init_file_system", "source_exports", "myWorker", "init_source", "__esmMin", "init_Kartoffelgames_Environment_Test_Package", "Console", "Kartoffelgames_Environment_Test_Package_default", "socket", "event"]
}
